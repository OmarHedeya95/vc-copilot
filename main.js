/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) =>
  function __require() {
    return (
      mod ||
        (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, "default", { value: mod, enumerable: true })
      : target,
    mod
  )
);
var __toCommonJS = (mod) =>
  __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../../../../../../node_modules/binary-search/index.js
var require_binary_search = __commonJS({
  "../../../../../../../../node_modules/binary-search/index.js"(
    exports,
    module2
  ) {
    module2.exports = function (haystack, needle, comparator, low, high) {
      var mid, cmp;
      if (low === void 0) low = 0;
      else {
        low = low | 0;
        if (low < 0 || low >= haystack.length)
          throw new RangeError("invalid lower bound");
      }
      if (high === void 0) high = haystack.length - 1;
      else {
        high = high | 0;
        if (high < low || high >= haystack.length)
          throw new RangeError("invalid upper bound");
      }
      while (low <= high) {
        mid = low + ((high - low) >>> 1);
        cmp = +comparator(haystack[mid], needle, mid, haystack);
        if (cmp < 0) low = mid + 1;
        else if (cmp > 0) high = mid - 1;
        else return mid;
      }
      return ~low;
    };
  },
});

// ../../../../../../../../node_modules/num-sort/index.js
var require_num_sort = __commonJS({
  "../../../../../../../../node_modules/num-sort/index.js"(exports) {
    "use strict";
    function assertNumber(number) {
      if (typeof number !== "number") {
        throw new TypeError("Expected a number");
      }
    }
    exports.ascending = (left, right) => {
      assertNumber(left);
      assertNumber(right);
      if (Number.isNaN(left)) {
        return -1;
      }
      if (Number.isNaN(right)) {
        return 1;
      }
      return left - right;
    };
    exports.descending = (left, right) => {
      assertNumber(left);
      assertNumber(right);
      if (Number.isNaN(left)) {
        return 1;
      }
      if (Number.isNaN(right)) {
        return -1;
      }
      return right - left;
    };
  },
});

// ../../../../../../../../node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "../../../../../../../../node_modules/decamelize/index.js"(exports, module2) {
    "use strict";
    module2.exports = function (str3, sep) {
      if (typeof str3 !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str3
        .replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2")
        .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2")
        .toLowerCase();
    };
  },
});

// ../../../../../../../../node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "../../../../../../../../node_modules/camelcase/index.js"(exports, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(
      SEPARATORS.source + IDENTIFIER.source,
      "gu"
    );
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (
          isLastCharUpper &&
          isLastLastCharUpper &&
          LOWERCASE.test(character)
        ) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower =
            toLowerCase(character) === character &&
            toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper =
            toUpperCase(character) === character &&
            toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input
        .replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) =>
          toUpperCase(identifier)
        )
        .replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options,
      };
      if (Array.isArray(input)) {
        input = input
          .map((x) => x.trim())
          .filter((x) => x.length)
          .join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase =
        options.locale === false
          ? (string) => string.toLowerCase()
          : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase =
        options.locale === false
          ? (string) => string.toUpperCase()
          : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  },
});

// ../../../../../../../../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../../../../../../../../node_modules/ansi-styles/index.js"(
    exports,
    module2
  ) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 =
      (offset = 0) =>
      (code) =>
        `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m =
      (offset = 0) =>
      (red, green, blue) =>
        `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29],
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39],
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49],
        },
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`,
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false,
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false,
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi256();
      styles2.color.ansi16m = wrapAnsi16m();
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round(((red - 8) / 247) * 24) + 232;
            }
            return (
              16 +
              36 * Math.round((red / 255) * 5) +
              6 * Math.round((green / 255) * 5) +
              Math.round((blue / 255) * 5)
            );
          },
          enumerable: false,
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(
              hex.toString(16)
            );
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString
                .split("")
                .map((character) => character + character)
                .join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [(integer >> 16) & 255, (integer >> 8) & 255, integer & 255];
          },
          enumerable: false,
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false,
        },
      });
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles,
    });
  },
});

// ../../../../../../../../node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../../../../../../../node_modules/retry/lib/retry_operation.js"(
    exports,
    module2
  ) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = (options && options.maxRetryTime) || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function () {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function () {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function (err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self = this;
      this._timer = setTimeout(function () {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function () {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function (fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function () {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function (fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function (fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function () {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function () {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function () {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  },
});

// ../../../../../../../../node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../../../../../../../node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function (options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime,
      });
    };
    exports.timeouts = function (options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false,
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function (a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function (attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(
        random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt)
      );
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function (obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function (err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function () {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  },
});

// ../../../../../../../../node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../../../../../../../node_modules/retry/index.js"(exports, module2) {
    module2.exports = require_retry();
  },
});

// ../../../../../../../../node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "../../../../../../../../node_modules/p-retry/index.js"(exports, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      "NetworkError when attempting to fetch resource.",
      "The Internet connection appears to be offline.",
      "Network request failed",
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) =>
      networkErrorMsgs.includes(errorMessage);
    var pRetry4 = (input, options) =>
      new Promise((resolve, reject) => {
        options = {
          onFailedAttempt: () => {},
          retries: 10,
          ...options,
        };
        const operation = retry.operation(options);
        operation.attempt(async (attemptNumber) => {
          try {
            resolve(await input(attemptNumber));
          } catch (error) {
            if (!(error instanceof Error)) {
              reject(
                new TypeError(
                  `Non-error was thrown: "${error}". You should only throw errors.`
                )
              );
              return;
            }
            if (error instanceof AbortError) {
              operation.stop();
              reject(error.originalError);
            } else if (
              error instanceof TypeError &&
              !isNetworkError(error.message)
            ) {
              operation.stop();
              reject(error);
            } else {
              decorateErrorWithCounts(error, attemptNumber, options);
              try {
                await options.onFailedAttempt(error);
              } catch (error2) {
                reject(error2);
                return;
              }
              if (!operation.retry(error)) {
                reject(operation.mainError());
              }
            }
          }
        });
      });
    module2.exports = pRetry4;
    module2.exports.default = pRetry4;
    module2.exports.AbortError = AbortError;
  },
});

// ../../../../../../../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../../../../../../../node_modules/eventemitter3/index.js"(
    exports,
    module2
  ) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {}
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        (emitter._events[evt] = listener), emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
        events,
        name;
      if (this._eventsCount === 0) return names;
      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return (
              listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true
            );
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
          j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(
      event,
      fn,
      context,
      once
    ) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (
          listeners.fn === fn &&
          (!once || listeners.once) &&
          (!context || listeners.context === context)
        ) {
          clearEvent(this, evt);
        }
      } else {
        for (
          var i = 0, events = [], length = listeners.length;
          i < length;
          i++
        ) {
          if (
            listeners[i].fn !== fn ||
            (once && !listeners[i].once) ||
            (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(
      event
    ) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (typeof module2 !== "undefined") {
      module2.exports = EventEmitter;
    }
  },
});

// ../../../../../../../../node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "../../../../../../../../node_modules/p-finally/index.js"(exports, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {});
      return promise.then(
        (val) =>
          new Promise((resolve) => {
            resolve(onFinally());
          }).then(() => val),
        (err) =>
          new Promise((resolve) => {
            resolve(onFinally());
          }).then(() => {
            throw err;
          })
      );
    };
  },
});

// ../../../../../../../../node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "../../../../../../../../node_modules/p-timeout/index.js"(exports, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) =>
      new Promise((resolve, reject) => {
        if (typeof milliseconds !== "number" || milliseconds < 0) {
          throw new TypeError(
            "Expected `milliseconds` to be a positive number"
          );
        }
        if (milliseconds === Infinity) {
          resolve(promise);
          return;
        }
        const timer = setTimeout(() => {
          if (typeof fallback === "function") {
            try {
              resolve(fallback());
            } catch (error) {
              reject(error);
            }
            return;
          }
          const message =
            typeof fallback === "string"
              ? fallback
              : `Promise timed out after ${milliseconds} milliseconds`;
          const timeoutError =
            fallback instanceof Error ? fallback : new TimeoutError(message);
          if (typeof promise.cancel === "function") {
            promise.cancel();
          }
          reject(timeoutError);
        }, milliseconds);
        pFinally(promise.then(resolve, reject), () => {
          clearTimeout(timer);
        });
      });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  },
});

// ../../../../../../../../node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "../../../../../../../../node_modules/p-queue/dist/lower-bound.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = (count / 2) | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports.default = lowerBound;
  },
});

// ../../../../../../../../node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "../../../../../../../../node_modules/p-queue/dist/priority-queue.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run,
        };
        if (
          this.size &&
          this._queue[this.size - 1].priority >= options.priority
        ) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(
          this._queue,
          element,
          (a, b) => b.priority - a.priority
        );
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue
          .filter((element) => element.priority === options.priority)
          .map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports.default = PriorityQueue;
  },
});

// ../../../../../../../../node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "../../../../../../../../node_modules/p-queue/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventEmitter = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {};
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter {
      constructor(options) {
        var _a4, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign(
          {
            carryoverConcurrencyCount: false,
            intervalCap: Infinity,
            interval: 0,
            concurrency: Infinity,
            autoStart: true,
            queueClass: priority_queue_1.default,
          },
          options
        );
        if (
          !(typeof options.intervalCap === "number" && options.intervalCap >= 1)
        ) {
          throw new TypeError(
            `Expected \`intervalCap\` to be a number from 1 and up, got \`${
              (_b =
                (_a4 = options.intervalCap) === null || _a4 === void 0
                  ? void 0
                  : _a4.toString()) !== null && _b !== void 0
                ? _b
                : ""
            }\` (${typeof options.intervalCap})`
          );
        }
        if (
          options.interval === void 0 ||
          !(Number.isFinite(options.interval) && options.interval >= 0)
        ) {
          throw new TypeError(
            `Expected \`interval\` to be a finite number >= 0, got \`${
              (_d =
                (_c = options.interval) === null || _c === void 0
                  ? void 0
                  : _c.toString()) !== null && _d !== void 0
                ? _d
                : ""
            }\` (${typeof options.interval})`
          );
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored =
          options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return (
          this._isIntervalIgnored || this._intervalCount < this._intervalCap
        );
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount
              ? this._pendingCount
              : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (
            this._doesIntervalAllowAnother &&
            this._doesConcurrentAllowAnother
          ) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (
          this._intervalCount === 0 &&
          this._pendingCount === 0 &&
          this._intervalId
        ) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount
          ? this._pendingCount
          : 0;
        this._processQueue();
      }
      _processQueue() {
        while (this._tryToStartAnother()) {}
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(
            `Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`
          );
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation =
                this._timeout === void 0 && options.timeout === void 0
                  ? fn()
                  : p_timeout_1.default(
                      Promise.resolve(fn()),
                      options.timeout === void 0
                        ? this._timeout
                        : options.timeout,
                      () => {
                        if (
                          options.throwOnTimeout === void 0
                            ? this._throwOnTimeout
                            : options.throwOnTimeout
                        ) {
                          reject(timeoutError);
                        }
                        return void 0;
                      }
                    );
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      async addAll(functions, options) {
        return Promise.all(
          functions.map(async (function_) => this.add(function_, options))
        );
      }
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      pause() {
        this._isPaused = true;
      }
      clear() {
        this._queue = new this._queueClass();
      }
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      get size() {
        return this._queue.size;
      }
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      get pending() {
        return this._pendingCount;
      }
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports.default = PQueue;
  },
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VCCopilotPlugin,
  gpt_3_latest: () => gpt_3_latest,
  gpt_4_latest: () => gpt_4_latest2,
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/czekanowski.js
function czekanowskiSimilarity(a, b) {
  let up = 0;
  let down = 0;
  for (let i = 0; i < a.length; i++) {
    up += Math.min(a[i], b[i]);
    down += a[i] + b[i];
  }
  return (2 * up) / down;
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/distances/dice.js
function dice(a, b) {
  let a2 = 0;
  let b2 = 0;
  let prod2 = 0;
  for (let i = 0; i < a.length; i++) {
    a2 += a[i] * a[i];
    b2 += b[i] * b[i];
    prod2 += (a[i] - b[i]) * (a[i] - b[i]);
  }
  return prod2 / (a2 + b2);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/distances/intersection.js
function intersection(a, b) {
  let ans = 0;
  for (let i = 0; i < a.length; i++) {
    ans += Math.min(a[i], b[i]);
  }
  return 1 - ans;
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/kumarHassebrook.js
function kumarHassebrook(a, b) {
  let p = 0;
  let p2 = 0;
  let q2 = 0;
  for (let i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (p2 + q2 - p);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/distances/kulczynski.js
function kulczynski(a, b) {
  let up = 0;
  let down = 0;
  for (let i = 0; i < a.length; i++) {
    up += Math.abs(a[i] - b[i]);
    down += Math.min(a[i], b[i]);
  }
  return up / down;
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/distances/motyka.js
function motyka(a, b) {
  let up = 0;
  let down = 0;
  for (let i = 0; i < a.length; i++) {
    up += Math.min(a[i], b[i]);
    down += a[i] + b[i];
  }
  return 1 - up / down;
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/distances/squaredChord.js
function squaredChord(a, b) {
  let ans = 0;
  for (let i = 0; i < a.length; i++) {
    ans += (Math.sqrt(a[i]) - Math.sqrt(b[i])) ** 2;
  }
  return ans;
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/tanimoto.js
function tanimoto(a, b, bitvector) {
  if (bitvector) {
    let inter = 0;
    let union = 0;
    for (let j = 0; j < a.length; j++) {
      inter += a[j] && b[j];
      union += a[j] || b[j];
    }
    if (union === 0) {
      return 1;
    }
    return inter / union;
  } else {
    let p = 0;
    let q = 0;
    let m = 0;
    for (let i = 0; i < a.length; i++) {
      p += a[i];
      q += b[i];
      m += Math.min(a[i], b[i]);
    }
    return 1 - (p + q - 2 * m) / (p + q - m);
  }
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities.js
var similarities_exports = {};
__export(similarities_exports, {
  cosine: () => cosine,
  czekanowski: () => czekanowskiSimilarity,
  dice: () => dice2,
  intersection: () => intersection2,
  kulczynski: () => kulczynski2,
  kumarHassebrook: () => kumarHassebrook,
  motyka: () => motyka2,
  pearson: () => pearson2,
  squaredChord: () => squaredChord2,
  tanimoto: () => tanimoto,
  tree: () => src_exports,
});

// ../../../../../../../../node_modules/ml-tree-similarity/src/index.js
var src_exports = {};
__export(src_exports, {
  createTree: () => createTree,
  getFunction: () => getFunction,
  treeSimilarity: () => treeSimilarity,
});

// ../../../../../../../../node_modules/ml-tree-similarity/src/createTree.js
var import_binary_search = __toESM(require_binary_search());
var import_num_sort = __toESM(require_num_sort());
function createTree(spectrum, options = {}) {
  var X = spectrum[0];
  const {
    minWindow = 0.16,
    threshold = 0.01,
    from = X[0],
    to = X[X.length - 1],
  } = options;
  return mainCreateTree(
    spectrum[0],
    spectrum[1],
    from,
    to,
    minWindow,
    threshold
  );
}
function mainCreateTree(X, Y, from, to, minWindow, threshold) {
  if (to - from < minWindow) {
    return null;
  }
  var start = (0, import_binary_search.default)(
    X,
    from,
    import_num_sort.ascending
  );
  if (start < 0) {
    start = ~start;
  }
  var sum2 = 0;
  var center = 0;
  for (var i = start; i < X.length; i++) {
    if (X[i] >= to) {
      break;
    }
    sum2 += Y[i];
    center += X[i] * Y[i];
  }
  if (sum2 < threshold) {
    return null;
  }
  center /= sum2;
  if (center - from < 1e-6 || to - center < 1e-6) {
    return null;
  }
  if (center - from < minWindow / 4) {
    return mainCreateTree(X, Y, center, to, minWindow, threshold);
  } else {
    if (to - center < minWindow / 4) {
      return mainCreateTree(X, Y, from, center, minWindow, threshold);
    } else {
      return new Tree(
        sum2,
        center,
        mainCreateTree(X, Y, from, center, minWindow, threshold),
        mainCreateTree(X, Y, center, to, minWindow, threshold)
      );
    }
  }
}
var Tree = class {
  constructor(sum2, center, left, right) {
    this.sum = sum2;
    this.center = center;
    this.left = left;
    this.right = right;
  }
};

// ../../../../../../../../node_modules/ml-tree-similarity/src/getSimilarity.js
function getSimilarity(a, b, options = {}) {
  const { alpha = 0.1, beta = 0.33, gamma = 1e-3 } = options;
  if (a === null || b === null) {
    return 0;
  }
  if (Array.isArray(a)) {
    a = createTree(a);
  }
  if (Array.isArray(b)) {
    b = createTree(b);
  }
  var C =
    (alpha * Math.min(a.sum, b.sum)) / Math.max(a.sum, b.sum) +
    (1 - alpha) * Math.exp(-gamma * Math.abs(a.center - b.center));
  return (
    beta * C +
    ((1 - beta) *
      (getSimilarity(a.left, b.left, options) +
        getSimilarity(a.right, b.right, options))) /
      2
  );
}

// ../../../../../../../../node_modules/ml-tree-similarity/src/index.js
function treeSimilarity(A, B, options = {}) {
  return getSimilarity(A, B, options);
}
function getFunction(options = {}) {
  return (A, B) => getSimilarity(A, B, options);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/cosine.js
function cosine(a, b) {
  let p = 0;
  let p2 = 0;
  let q2 = 0;
  for (let i = 0; i < a.length; i++) {
    p += a[i] * b[i];
    p2 += a[i] * a[i];
    q2 += b[i] * b[i];
  }
  return p / (Math.sqrt(p2) * Math.sqrt(q2));
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/dice.js
function dice2(a, b) {
  return 1 - dice(a, b);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/intersection.js
function intersection2(a, b) {
  return 1 - intersection(a, b);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/kulczynski.js
function kulczynski2(a, b) {
  return 1 / kulczynski(a, b);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/motyka.js
function motyka2(a, b) {
  return 1 - motyka(a, b);
}

// ../../../../../../../../node_modules/is-any-array/lib-esm/index.js
var toString = Object.prototype.toString;
function isAnyArray(value) {
  const tag = toString.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}

// ../../../../../../../../node_modules/ml-array-sum/lib-es6/index.js
function sum(input) {
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var sumValue = 0;
  for (var i = 0; i < input.length; i++) {
    sumValue += input[i];
  }
  return sumValue;
}

// ../../../../../../../../node_modules/ml-array-mean/lib-es6/index.js
function mean(input) {
  return sum(input) / input.length;
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/pearson.js
function pearson2(a, b) {
  let avgA = mean(a);
  let avgB = mean(b);
  let newA = new Array(a.length);
  let newB = new Array(b.length);
  for (let i = 0; i < newA.length; i++) {
    newA[i] = a[i] - avgA;
    newB[i] = b[i] - avgB;
  }
  return cosine(newA, newB);
}

// ../../../../../../../../node_modules/ml-distance/lib-esm/similarities/squaredChord.js
function squaredChord2(a, b) {
  return 1 - squaredChord(a, b);
}

// ../../../../../../../../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues =
      typeof crypto !== "undefined" &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    }
  }
  return getRandomValues(rnds8);
}

// ../../../../../../../../node_modules/uuid/dist/esm-browser/regex.js
var regex_default =
  /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../../../../../../../../node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// ../../../../../../../../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (
    byteToHex[arr[offset + 0]] +
    byteToHex[arr[offset + 1]] +
    byteToHex[arr[offset + 2]] +
    byteToHex[arr[offset + 3]] +
    "-" +
    byteToHex[arr[offset + 4]] +
    byteToHex[arr[offset + 5]] +
    "-" +
    byteToHex[arr[offset + 6]] +
    byteToHex[arr[offset + 7]] +
    "-" +
    byteToHex[arr[offset + 8]] +
    byteToHex[arr[offset + 9]] +
    "-" +
    byteToHex[arr[offset + 10]] +
    byteToHex[arr[offset + 11]] +
    byteToHex[arr[offset + 12]] +
    byteToHex[arr[offset + 13]] +
    byteToHex[arr[offset + 14]] +
    byteToHex[arr[offset + 15]]
  );
}

// ../../../../../../../../node_modules/uuid/dist/esm-browser/native.js
var randomUUID =
  typeof crypto !== "undefined" &&
  crypto.randomUUID &&
  crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID,
};

// ../../../../../../../../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = (rnds[6] & 15) | 64;
  rnds[8] = (rnds[8] & 63) | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../../../../../../../node_modules/langchain/dist/load/map_keys.js
var import_decamelize = __toESM(require_decamelize(), 1);
var import_camelcase = __toESM(require_camelcase(), 1);
function keyToJson(key, map) {
  return (
    (map == null ? void 0 : map[key]) || (0, import_decamelize.default)(key)
  );
}
function mapKeys(fields, mapper, map) {
  const mapped = {};
  for (const key in fields) {
    if (Object.hasOwn(fields, key)) {
      mapped[mapper(key, map)] = fields[key];
    }
  }
  return mapped;
}

// ../../../../../../../../node_modules/langchain/dist/load/serializable.js
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root, secretsMap) {
  const result = shallowCopy(root);
  for (const [path, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === void 0) {
        break;
      }
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== void 0) {
      current[last] = {
        lc: 1,
        type: "secret",
        id: [secretId],
      };
    }
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed =
    typeof serializableClass.lc_name === "function" &&
    (typeof parentClass.lc_name !== "function" ||
      serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) {
    return serializableClass.lc_name();
  } else {
    return serializableClass.name;
  }
}
var Serializable = class {
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
  }
  get lc_secrets() {
    return void 0;
  }
  get lc_attributes() {
    return void 0;
  }
  get lc_aliases() {
    return void 0;
  }
  constructor(kwargs, ..._args) {
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false,
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.lc_kwargs = kwargs || {};
  }
  toJSON() {
    if (!this.lc_serializable) {
      return this.toJSONNotImplemented();
    }
    if (
      this.lc_kwargs instanceof Serializable ||
      typeof this.lc_kwargs !== "object" ||
      Array.isArray(this.lc_kwargs)
    ) {
      return this.toJSONNotImplemented();
    }
    const aliases = {};
    const secrets = {};
    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
      acc[key] = key in this ? this[key] : this.lc_kwargs[key];
      return acc;
    }, {});
    for (
      let current = Object.getPrototypeOf(this);
      current;
      current = Object.getPrototypeOf(current)
    ) {
      Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
      Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
      Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
    }
    Object.keys(secrets).forEach((keyPath) => {
      let read = this;
      let write = kwargs;
      const [last, ...partsReverse] = keyPath.split(".").reverse();
      for (const key of partsReverse.reverse()) {
        if (!(key in read) || read[key] === void 0) return;
        if (!(key in write) || write[key] === void 0) {
          if (typeof read[key] === "object" && read[key] != null) {
            write[key] = {};
          } else if (Array.isArray(read[key])) {
            write[key] = [];
          }
        }
        read = read[key];
        write = write[key];
      }
      if (last in read && read[last] !== void 0) {
        write[last] = write[last] || read[last];
      }
    });
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: mapKeys(
        Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs,
        keyToJson,
        aliases
      ),
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id,
    };
  }
};

// ../../../../../../../../node_modules/langchain/dist/callbacks/base.js
var BaseCallbackHandlerMethodsClass = class {};
var BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
  get lc_namespace() {
    return ["langchain", "callbacks", this.name];
  }
  get lc_secrets() {
    return void 0;
  }
  get lc_attributes() {
    return void 0;
  }
  get lc_aliases() {
    return void 0;
  }
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
  }
  constructor(input) {
    var _a4, _b, _c, _d, _e;
    super();
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false,
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "ignoreLLM", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false,
    });
    Object.defineProperty(this, "ignoreChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false,
    });
    Object.defineProperty(this, "ignoreAgent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false,
    });
    Object.defineProperty(this, "ignoreRetriever", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false,
    });
    Object.defineProperty(this, "awaitHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value:
        typeof process !== "undefined"
          ? ((_a4 = process.env) == null
              ? void 0
              : _a4.LANGCHAIN_CALLBACKS_BACKGROUND) !== "true"
          : true,
    });
    this.lc_kwargs = input || {};
    if (input) {
      this.ignoreLLM = (_b = input.ignoreLLM) != null ? _b : this.ignoreLLM;
      this.ignoreChain =
        (_c = input.ignoreChain) != null ? _c : this.ignoreChain;
      this.ignoreAgent =
        (_d = input.ignoreAgent) != null ? _d : this.ignoreAgent;
      this.ignoreRetriever =
        (_e = input.ignoreRetriever) != null ? _e : this.ignoreRetriever;
    }
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Serializable.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Serializable.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(methods) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default(),
        });
        Object.assign(this, methods);
      }
    }
    return new Handler();
  }
};

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/console.js
var import_ansi_styles = __toESM(require_ansi_styles(), 1);

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/tracer.js
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object"
    ? value
    : { [defaultKey]: value };
}
var BaseTracer = class extends BaseCallbackHandler {
  constructor(_fields) {
    super(...arguments);
    Object.defineProperty(this, "runMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map(),
    });
  }
  copy() {
    return this;
  }
  _addChildRun(parentRun, childRun) {
    parentRun.child_runs.push(childRun);
  }
  async _startTrace(run) {
    var _a4;
    if (run.parent_run_id !== void 0) {
      const parentRun = this.runMap.get(run.parent_run_id);
      if (parentRun) {
        this._addChildRun(parentRun, run);
        parentRun.child_execution_order = Math.max(
          parentRun.child_execution_order,
          run.child_execution_order
        );
      }
    }
    this.runMap.set(run.id, run);
    await ((_a4 = this.onRunCreate) == null ? void 0 : _a4.call(this, run));
  }
  async _endTrace(run) {
    var _a4;
    const parentRun =
      run.parent_run_id !== void 0 && this.runMap.get(run.parent_run_id);
    if (parentRun) {
      parentRun.child_execution_order = Math.max(
        parentRun.child_execution_order,
        run.child_execution_order
      );
    } else {
      await this.persistRun(run);
    }
    this.runMap.delete(run.id);
    await ((_a4 = this.onRunUpdate) == null ? void 0 : _a4.call(this, run));
  }
  _getExecutionOrder(parentRunId) {
    const parentRun = parentRunId !== void 0 && this.runMap.get(parentRunId);
    if (!parentRun) {
      return 1;
    }
    return parentRun.child_execution_order + 1;
  }
  async handleLLMStart(
    llm,
    prompts,
    runId,
    parentRunId,
    extraParams,
    tags,
    metadata,
    name
  ) {
    var _a4;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata
      ? { ...extraParams, metadata }
      : extraParams;
    const run = {
      id: runId,
      name: name != null ? name : llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString(),
        },
      ],
      inputs: { prompts },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams != null ? finalExtraParams : {},
      tags: tags || [],
    };
    await this._startTrace(run);
    await ((_a4 = this.onLLMStart) == null ? void 0 : _a4.call(this, run));
    return run;
  }
  async handleChatModelStart(
    llm,
    messages,
    runId,
    parentRunId,
    extraParams,
    tags,
    metadata,
    name
  ) {
    var _a4;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata
      ? { ...extraParams, metadata }
      : extraParams;
    const run = {
      id: runId,
      name: name != null ? name : llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString(),
        },
      ],
      inputs: { messages },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams != null ? finalExtraParams : {},
      tags: tags || [],
    };
    await this._startTrace(run);
    await ((_a4 = this.onLLMStart) == null ? void 0 : _a4.call(this, run));
    return run;
  }
  async handleLLMEnd(output, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run.end_time = Date.now();
    run.outputs = output;
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString(),
    });
    await ((_a4 = this.onLLMEnd) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleLLMError(error, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run.end_time = Date.now();
    run.error = error.message;
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString(),
    });
    await ((_a4 = this.onLLMError) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleChainStart(
    chain,
    inputs,
    runId,
    parentRunId,
    tags,
    metadata,
    runType,
    name
  ) {
    var _a4;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name != null ? name : chain.id[chain.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: chain,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString(),
        },
      ],
      inputs,
      execution_order,
      child_execution_order: execution_order,
      run_type: runType != null ? runType : "chain",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || [],
    };
    await this._startTrace(run);
    await ((_a4 = this.onChainStart) == null ? void 0 : _a4.call(this, run));
    return run;
  }
  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run) {
      throw new Error("No chain run to end.");
    }
    run.end_time = Date.now();
    run.outputs = _coerceToDict(outputs, "output");
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString(),
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await ((_a4 = this.onChainEnd) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run) {
      throw new Error("No chain run to end.");
    }
    run.end_time = Date.now();
    run.error = error.message;
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString(),
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await ((_a4 = this.onChainError) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    var _a4;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name != null ? name : tool.id[tool.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: tool,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString(),
        },
      ],
      inputs: { input },
      execution_order,
      child_execution_order: execution_order,
      run_type: "tool",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || [],
    };
    await this._startTrace(run);
    await ((_a4 = this.onToolStart) == null ? void 0 : _a4.call(this, run));
    return run;
  }
  async handleToolEnd(output, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
      throw new Error("No tool run to end");
    }
    run.end_time = Date.now();
    run.outputs = { output };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString(),
    });
    await ((_a4 = this.onToolEnd) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleToolError(error, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
      throw new Error("No tool run to end");
    }
    run.end_time = Date.now();
    run.error = error.message;
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString(),
    });
    await ((_a4 = this.onToolError) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleAgentAction(action, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
      return;
    }
    const agentRun = run;
    agentRun.actions = agentRun.actions || [];
    agentRun.actions.push(action);
    agentRun.events.push({
      name: "agent_action",
      time: new Date().toISOString(),
      kwargs: { action },
    });
    await ((_a4 = this.onAgentAction) == null ? void 0 : _a4.call(this, run));
  }
  async handleAgentEnd(action, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
      return;
    }
    run.events.push({
      name: "agent_end",
      time: new Date().toISOString(),
      kwargs: { action },
    });
    await ((_a4 = this.onAgentEnd) == null ? void 0 : _a4.call(this, run));
  }
  async handleRetrieverStart(
    retriever,
    query,
    runId,
    parentRunId,
    tags,
    metadata,
    name
  ) {
    var _a4;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name != null ? name : retriever.id[retriever.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: retriever,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString(),
        },
      ],
      inputs: { query },
      execution_order,
      child_execution_order: execution_order,
      run_type: "retriever",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || [],
    };
    await this._startTrace(run);
    await ((_a4 = this.onRetrieverStart) == null
      ? void 0
      : _a4.call(this, run));
    return run;
  }
  async handleRetrieverEnd(documents, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run.end_time = Date.now();
    run.outputs = { documents };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString(),
    });
    await ((_a4 = this.onRetrieverEnd) == null ? void 0 : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleRetrieverError(error, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run.end_time = Date.now();
    run.error = error.message;
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString(),
    });
    await ((_a4 = this.onRetrieverError) == null
      ? void 0
      : _a4.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleText(text, runId) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
      return;
    }
    run.events.push({
      name: "text",
      time: new Date().toISOString(),
      kwargs: { text },
    });
    await ((_a4 = this.onText) == null ? void 0 : _a4.call(this, run));
  }
  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
    var _a4;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
      throw new Error(
        `Invalid "runId" provided to "handleLLMNewToken" callback.`
      );
    }
    run.events.push({
      name: "new_token",
      time: new Date().toISOString(),
      kwargs: { token, idx, chunk: fields == null ? void 0 : fields.chunk },
    });
    await ((_a4 = this.onLLMNewToken) == null
      ? void 0
      : _a4.call(this, run, token));
    return run;
  }
};

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/console.js
function wrap(style, text) {
  return `${style.open}${text}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch (err) {
    return fallback;
  }
}
function elapsed(run) {
  if (!run.end_time) return "";
  const elapsed2 = run.end_time - run.start_time;
  if (elapsed2 < 1e3) {
    return `${elapsed2}ms`;
  }
  return `${(elapsed2 / 1e3).toFixed(2)}s`;
}
var { color } = import_ansi_styles.default;
var ConsoleCallbackHandler = class extends BaseTracer {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "console_callback_handler",
    });
  }
  persistRun(_run) {
    return Promise.resolve();
  }
  getParents(run) {
    const parents = [];
    let currentRun = run;
    while (currentRun.parent_run_id) {
      const parent = this.runMap.get(currentRun.parent_run_id);
      if (parent) {
        parents.push(parent);
        currentRun = parent;
      } else {
        break;
      }
    }
    return parents;
  }
  getBreadcrumbs(run) {
    const parents = this.getParents(run).reverse();
    const string = [...parents, run]
      .map((parent, i, arr) => {
        const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
        return i === arr.length - 1
          ? wrap(import_ansi_styles.default.bold, name)
          : name;
      })
      .join(" > ");
    return wrap(color.grey, string);
  }
  onChainStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(
        color.green,
        "[chain/start]"
      )} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(
        run.inputs,
        "[inputs]"
      )}`
    );
  }
  onChainEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(
        run
      )}] Exiting Chain run with output: ${tryJsonStringify(
        run.outputs,
        "[outputs]"
      )}`
    );
  }
  onChainError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(
        run
      )}] Chain run errored with error: ${tryJsonStringify(
        run.error,
        "[error]"
      )}`
    );
  }
  onLLMStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    const inputs =
      "prompts" in run.inputs
        ? { prompts: run.inputs.prompts.map((p) => p.trim()) }
        : run.inputs;
    console.log(
      `${wrap(
        color.green,
        "[llm/start]"
      )} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(
        inputs,
        "[inputs]"
      )}`
    );
  }
  onLLMEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(
        run
      )}] Exiting LLM run with output: ${tryJsonStringify(
        run.outputs,
        "[response]"
      )}`
    );
  }
  onLLMError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(
        run
      )}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`
    );
  }
  onToolStart(run) {
    var _a4;
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(
        color.green,
        "[tool/start]"
      )} [${crumbs}] Entering Tool run with input: "${
        (_a4 = run.inputs.input) == null ? void 0 : _a4.trim()
      }"`
    );
  }
  onToolEnd(run) {
    var _a4, _b;
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(
        run
      )}] Exiting Tool run with output: "${
        (_b = (_a4 = run.outputs) == null ? void 0 : _a4.output) == null
          ? void 0
          : _b.trim()
      }"`
    );
  }
  onToolError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(
        run
      )}] Tool run errored with error: ${tryJsonStringify(
        run.error,
        "[error]"
      )}`
    );
  }
  onRetrieverStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(
        color.green,
        "[retriever/start]"
      )} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(
        run.inputs,
        "[inputs]"
      )}`
    );
  }
  onRetrieverEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(
        run
      )}] Exiting Retriever run with output: ${tryJsonStringify(
        run.outputs,
        "[outputs]"
      )}`
    );
  }
  onRetrieverError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(
        run
      )}] Retriever run errored with error: ${tryJsonStringify(
        run.error,
        "[error]"
      )}`
    );
  }
  onAgentAction(run) {
    const agentRun = run;
    const crumbs = this.getBreadcrumbs(run);
    console.log(
      `${wrap(
        color.blue,
        "[agent/action]"
      )} [${crumbs}] Agent selected action: ${tryJsonStringify(
        agentRun.actions[agentRun.actions.length - 1],
        "[action]"
      )}`
    );
  }
};

// ../../../../../../../../node_modules/langsmith/dist/utils/async_caller.js
var import_p_retry = __toESM(require_p_retry(), 1);
var import_p_queue = __toESM(require_dist(), 1);
var STATUS_NO_RETRY = [400, 401, 403, 404, 405, 406, 407, 408, 409];
var AsyncCaller = class {
  constructor(params) {
    var _a4, _b;
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.maxConcurrency =
      (_a4 = params.maxConcurrency) != null ? _a4 : Infinity;
    this.maxRetries = (_b = params.maxRetries) != null ? _b : 6;
    const PQueue =
      "default" in import_p_queue.default
        ? import_p_queue.default.default
        : import_p_queue.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
  }
  call(callable, ...args) {
    return this.queue.add(
      () =>
        (0, import_p_retry.default)(
          () =>
            callable(...args).catch((error) => {
              if (error instanceof Error) {
                throw error;
              } else {
                throw new Error(error);
              }
            }),
          {
            onFailedAttempt(error) {
              var _a4;
              if (
                error.message.startsWith("Cancel") ||
                error.message.startsWith("TimeoutError") ||
                error.message.startsWith("AbortError")
              ) {
                throw error;
              }
              if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
                throw error;
              }
              const status =
                (_a4 = error == null ? void 0 : error.response) == null
                  ? void 0
                  : _a4.status;
              if (status && STATUS_NO_RETRY.includes(+status)) {
                throw error;
              }
            },
            retries: this.maxRetries,
            randomize: true,
          }
        ),
      { throwOnTimeout: true }
    );
  }
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          var _a4;
          (_a4 = options.signal) == null
            ? void 0
            : _a4.addEventListener("abort", () => {
                reject(new Error("AbortError"));
              });
        }),
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() =>
      fetch(...args).then((res) => (res.ok ? res : Promise.reject(res)))
    );
  }
};

// ../../../../../../../../node_modules/langsmith/dist/utils/messages.js
function isLangChainMessage(message) {
  return typeof (message == null ? void 0 : message._getType) === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content },
  };
  if (
    (message == null ? void 0 : message.additional_kwargs) &&
    Object.keys(message.additional_kwargs).length > 0
  ) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}

// ../../../../../../../../node_modules/langsmith/dist/utils/env.js
var isBrowser = () =>
  typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = () =>
  typeof globalThis === "object" &&
  globalThis.constructor &&
  globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom = () =>
  (typeof window !== "undefined" && window.name === "nodejs") ||
  (typeof navigator !== "undefined" &&
    (navigator.userAgent.includes("Node.js") ||
      navigator.userAgent.includes("jsdom")));
var isDeno = () => typeof Deno !== "undefined";
var isNode = () =>
  typeof process !== "undefined" &&
  typeof process.versions !== "undefined" &&
  typeof process.versions.node !== "undefined" &&
  !isDeno();
var getEnv = () => {
  let env;
  if (isBrowser()) {
    env = "browser";
  } else if (isNode()) {
    env = "node";
  } else if (isWebWorker()) {
    env = "webworker";
  } else if (isJsDom()) {
    env = "jsdom";
  } else if (isDeno()) {
    env = "deno";
  } else {
    env = "other";
  }
  return env;
};
var runtimeEnvironment;
async function getRuntimeEnvironment() {
  if (runtimeEnvironment === void 0) {
    const env = getEnv();
    const releaseEnv = getShas();
    runtimeEnvironment = {
      library: "langsmith",
      runtime: env,
      ...releaseEnv,
    };
  }
  return runtimeEnvironment;
}
function getEnvironmentVariable(name) {
  var _a4;
  try {
    return typeof process !== "undefined"
      ? (_a4 = process.env) == null
        ? void 0
        : _a4[name]
      : void 0;
  } catch (e) {
    return void 0;
  }
}
var cachedCommitSHAs;
function getShas() {
  if (cachedCommitSHAs !== void 0) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT",
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable(env);
    if (envVar !== void 0) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}

// ../../../../../../../../node_modules/langsmith/dist/client.js
var isLocalhost = (url) => {
  const strippedUrl = url.replace("http://", "").replace("https://", "");
  const hostname = strippedUrl.split("/")[0].split(":")[0];
  return (
    hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1"
  );
};
var raiseForStatus = async (response, operation) => {
  const body = await response.text();
  if (!response.ok) {
    throw new Error(
      `Failed to ${operation}: ${response.status} ${response.statusText} ${body}`
    );
  }
};
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str3) {
  if (str3 === void 0) {
    return void 0;
  }
  return str3
    .trim()
    .replace(/^"(.*)"$/, "$1")
    .replace(/^'(.*)'$/, "$1");
}
function hideInputs(inputs) {
  if (getEnvironmentVariable("LANGCHAIN_HIDE_INPUTS") === "true") {
    return {};
  }
  return inputs;
}
function hideOutputs(outputs) {
  if (getEnvironmentVariable("LANGCHAIN_HIDE_OUTPUTS") === "true") {
    return {};
  }
  return outputs;
}
function assertUuid(str3) {
  if (!validate_default(str3)) {
    throw new Error(`Invalid UUID: ${str3}`);
  }
}
var Client = class {
  constructor(config = {}) {
    var _a4, _b, _c, _d, _e, _f;
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null,
    });
    const defaultConfig = Client.getDefaultClientConfig();
    this.apiUrl =
      (_b = trimQuotes(
        (_a4 = config.apiUrl) != null ? _a4 : defaultConfig.apiUrl
      )) != null
        ? _b
        : "";
    this.apiKey = trimQuotes(
      (_c = config.apiKey) != null ? _c : defaultConfig.apiKey
    );
    this.webUrl = trimQuotes(
      (_d = config.webUrl) != null ? _d : defaultConfig.webUrl
    );
    this.validateApiKeyIfHosted();
    this.timeout_ms = (_e = config.timeout_ms) != null ? _e : 4e3;
    this.caller = new AsyncCaller(
      (_f = config.callerOptions) != null ? _f : {}
    );
  }
  static getDefaultClientConfig() {
    var _a4;
    const apiKey = getEnvironmentVariable("LANGCHAIN_API_KEY");
    const apiUrl =
      (_a4 = getEnvironmentVariable("LANGCHAIN_ENDPOINT")) != null
        ? _a4
        : apiKey
        ? "https://api.smith.langchain.com"
        : "http://localhost:1984";
    return {
      apiUrl,
      apiKey,
      webUrl: void 0,
    };
  }
  validateApiKeyIfHosted() {
    const isLocal = isLocalhost(this.apiUrl);
    if (!isLocal && !this.apiKey) {
      throw new Error(
        "API key must be provided when using hosted LangSmith API"
      );
    }
  }
  getHostUrl() {
    if (this.webUrl) {
      return this.webUrl;
    } else if (isLocalhost(this.apiUrl)) {
      this.webUrl = "http://localhost";
      return "http://localhost";
    } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
      this.webUrl = "https://dev.smith.langchain.com";
      return "https://dev.smith.langchain.com";
    } else {
      this.webUrl = "https://smith.langchain.com";
      return "https://smith.langchain.com";
    }
  }
  get headers() {
    const headers = {};
    if (this.apiKey) {
      headers["x-api-key"] = `${this.apiKey}`;
    }
    return headers;
  }
  async _getResponse(path, queryParams) {
    var _a4;
    const paramsString =
      (_a4 = queryParams == null ? void 0 : queryParams.toString()) != null
        ? _a4
        : "";
    const url = `${this.apiUrl}${path}?${paramsString}`;
    const response = await this.caller.call(fetch, url, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      throw new Error(
        `Failed to fetch ${path}: ${response.status} ${response.statusText}`
      );
    }
    return response;
  }
  async _get(path, queryParams) {
    const response = await this._getResponse(path, queryParams);
    return response.json();
  }
  async *_getPaginated(path, queryParams = new URLSearchParams()) {
    let offset = Number(queryParams.get("offset")) || 0;
    const limit = Number(queryParams.get("limit")) || 100;
    while (true) {
      queryParams.set("offset", String(offset));
      queryParams.set("limit", String(limit));
      const url = `${this.apiUrl}${path}?${queryParams}`;
      const response = await this.caller.call(fetch, url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      });
      if (!response.ok) {
        throw new Error(
          `Failed to fetch ${path}: ${response.status} ${response.statusText}`
        );
      }
      const items = await response.json();
      if (items.length === 0) {
        break;
      }
      yield items;
      if (items.length < limit) {
        break;
      }
      offset += items.length;
    }
  }
  async createRun(run) {
    var _a4;
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const extra = (_a4 = run.extra) != null ? _a4 : {};
    const runtimeEnv = await getRuntimeEnvironment();
    const session_name = run.project_name;
    delete run.project_name;
    const runCreate = {
      session_name,
      ...run,
      extra: {
        ...run.extra,
        runtime: {
          ...runtimeEnv,
          ...extra.runtime,
        },
      },
    };
    runCreate.inputs = hideInputs(runCreate.inputs);
    if (runCreate.outputs) {
      runCreate.outputs = hideOutputs(runCreate.outputs);
    }
    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {
      method: "POST",
      headers,
      body: JSON.stringify(runCreate),
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    await raiseForStatus(response, "create run");
  }
  async updateRun(runId, run) {
    assertUuid(runId);
    if (run.inputs) {
      run.inputs = hideInputs(run.inputs);
    }
    if (run.outputs) {
      run.outputs = hideOutputs(run.outputs);
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/runs/${runId}`,
      {
        method: "PATCH",
        headers,
        body: JSON.stringify(run),
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    await raiseForStatus(response, "update run");
  }
  async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
    assertUuid(runId);
    let run = await this._get(`/runs/${runId}`);
    if (loadChildRuns && run.child_run_ids) {
      run = await this._loadChildRuns(run);
    }
    return run;
  }
  async getRunUrl({ runId, run, projectOpts }) {
    if (run !== void 0) {
      let sessionId;
      if (run.session_id) {
        sessionId = run.session_id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectName) {
        sessionId = (
          await this.readProject({
            projectName: projectOpts == null ? void 0 : projectOpts.projectName,
          })
        ).id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectId) {
        sessionId = projectOpts == null ? void 0 : projectOpts.projectId;
      } else {
        const project = await this.readProject({
          projectName: getEnvironmentVariable("LANGCHAIN_PROJECT") || "default",
        });
        sessionId = project.id;
      }
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${
        run.id
      }?poll=true`;
    } else if (runId !== void 0) {
      const run_ = await this.readRun(runId);
      if (!run_.app_path) {
        throw new Error(`Run ${runId} has no app_path`);
      }
      const baseUrl = this.getHostUrl();
      return `${baseUrl}${run_.app_path}`;
    } else {
      throw new Error("Must provide either runId or run");
    }
  }
  async _loadChildRuns(run) {
    const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));
    const treemap = {};
    const runs = {};
    childRuns.sort((a, b) => {
      var _a4, _b;
      return (
        (_a4 = a == null ? void 0 : a.dotted_order) != null ? _a4 : ""
      ).localeCompare(
        (_b = b == null ? void 0 : b.dotted_order) != null ? _b : ""
      );
    });
    for (const childRun of childRuns) {
      if (
        childRun.parent_run_id === null ||
        childRun.parent_run_id === void 0
      ) {
        throw new Error(`Child run ${childRun.id} has no parent`);
      }
      if (!(childRun.parent_run_id in treemap)) {
        treemap[childRun.parent_run_id] = [];
      }
      treemap[childRun.parent_run_id].push(childRun);
      runs[childRun.id] = childRun;
    }
    run.child_runs = treemap[run.id] || [];
    for (const runId in treemap) {
      if (runId !== run.id) {
        runs[runId].child_runs = treemap[runId];
      }
    }
    return run;
  }
  async *listRuns({
    projectId,
    projectName,
    parentRunId,
    referenceExampleId,
    startTime,
    executionOrder,
    runType,
    error,
    id,
    limit,
    offset,
    query,
    filter,
  }) {
    const queryParams = new URLSearchParams();
    let projectId_ = projectId;
    if (projectName) {
      if (projectId) {
        throw new Error("Only one of projectId or projectName may be given");
      }
      projectId_ = (await this.readProject({ projectName })).id;
    }
    if (projectId_) {
      queryParams.append("session", projectId_);
    }
    if (parentRunId) {
      queryParams.append("parent_run", parentRunId);
    }
    if (referenceExampleId) {
      queryParams.append("reference_example", referenceExampleId);
    }
    if (startTime) {
      queryParams.append("start_time", startTime.toISOString());
    }
    if (executionOrder) {
      queryParams.append("execution_order", executionOrder.toString());
    }
    if (runType) {
      queryParams.append("run_type", runType);
    }
    if (error !== void 0) {
      queryParams.append("error", error.toString());
    }
    if (id !== void 0) {
      for (const id_ of id) {
        queryParams.append("id", id_);
      }
    }
    if (limit !== void 0) {
      queryParams.append("limit", limit.toString());
    }
    if (offset !== void 0) {
      queryParams.append("offset", offset.toString());
    }
    if (query !== void 0) {
      queryParams.append("query", query);
    }
    if (filter !== void 0) {
      queryParams.append("filter", filter);
    }
    for await (const runs of this._getPaginated("/runs", queryParams)) {
      yield* runs;
    }
  }
  async shareRun(runId, { shareId } = {}) {
    const data = {
      run_id: runId,
      share_token: shareId || v4_default(),
    };
    assertUuid(runId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/runs/${runId}/share`,
      {
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      throw new Error("Invalid response from server");
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async unshareRun(runId) {
    assertUuid(runId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/runs/${runId}/share`,
      {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    await raiseForStatus(response, "unshare run");
  }
  async readRunSharedLink(runId) {
    assertUuid(runId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/runs/${runId}/share`,
      {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      return void 0;
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async listSharedRuns(shareToken, { runIds } = {}) {
    const queryParams = new URLSearchParams({
      share_token: shareToken,
    });
    if (runIds !== void 0) {
      for (const runId of runIds) {
        queryParams.append("id", runId);
      }
    }
    assertUuid(shareToken);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/public/${shareToken}/runs${queryParams}`,
      {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    const runs = await response.json();
    return runs;
  }
  async readDatasetSharedSchema(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/datasets/${datasetId}/share`,
      {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${
      shareSchema.share_token
    }/d`;
    return shareSchema;
  }
  async shareDataset(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    const data = {
      dataset_id: datasetId,
    };
    assertUuid(datasetId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/datasets/${datasetId}/share`,
      {
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${
      shareSchema.share_token
    }/d`;
    return shareSchema;
  }
  async unshareDataset(datasetId) {
    assertUuid(datasetId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/datasets/${datasetId}/share`,
      {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    await raiseForStatus(response, "unshare dataset");
  }
  async readSharedDataset(shareToken) {
    assertUuid(shareToken);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/public/${shareToken}/datasets`,
      {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    const dataset = await response.json();
    return dataset;
  }
  async createProject({
    projectName,
    projectExtra,
    upsert,
    referenceDatasetId,
  }) {
    const upsert_ = upsert ? `?upsert=true` : "";
    const endpoint = `${this.apiUrl}/sessions${upsert_}`;
    const body = {
      name: projectName,
    };
    if (projectExtra !== void 0) {
      body["extra"] = projectExtra;
    }
    if (referenceDatasetId !== void 0) {
      body["reference_dataset_id"] = referenceDatasetId;
    }
    const response = await this.caller.call(fetch, endpoint, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    const result = await response.json();
    if (!response.ok) {
      throw new Error(
        `Failed to create session ${projectName}: ${response.status} ${response.statusText}`
      );
    }
    return result;
  }
  async readProject({ projectId, projectName }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(
          `Project[id=${projectId}, name=${projectName}] not found`
        );
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async _getTenantId() {
    if (this._tenantId !== null) {
      return this._tenantId;
    }
    const queryParams = new URLSearchParams({ limit: "1" });
    for await (const projects of this._getPaginated("/sessions", queryParams)) {
      this._tenantId = projects[0].tenant_id;
      return projects[0].tenant_id;
    }
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({
    projectIds,
    name,
    nameContains,
    referenceDatasetId,
    referenceDatasetName,
    referenceFree,
  } = {}) {
    const params = new URLSearchParams();
    if (projectIds !== void 0) {
      for (const projectId of projectIds) {
        params.append("id", projectId);
      }
    }
    if (name !== void 0) {
      params.append("name", name);
    }
    if (nameContains !== void 0) {
      params.append("name_contains", nameContains);
    }
    if (referenceDatasetId !== void 0) {
      params.append("reference_dataset", referenceDatasetId);
    } else if (referenceDatasetName !== void 0) {
      const dataset = await this.readDataset({
        datasetName: referenceDatasetName,
      });
      params.append("reference_dataset", dataset.id);
    }
    if (referenceFree !== void 0) {
      params.append("reference_free", referenceFree.toString());
    }
    for await (const projects of this._getPaginated("/sessions", params)) {
      yield* projects;
    }
  }
  async deleteProject({ projectId, projectName }) {
    let projectId_;
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide projectName or projectId");
    } else if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId === void 0) {
      projectId_ = (await this.readProject({ projectName })).id;
    } else {
      projectId_ = projectId;
    }
    assertUuid(projectId_);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/sessions/${projectId_}`,
      {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    await raiseForStatus(
      response,
      `delete session ${projectId_} (${projectName})`
    );
  }
  async uploadCsv({
    csvFile,
    fileName,
    inputKeys,
    outputKeys,
    description,
    dataType,
    name,
  }) {
    const url = `${this.apiUrl}/datasets/upload`;
    const formData = new FormData();
    formData.append("file", csvFile, fileName);
    inputKeys.forEach((key) => {
      formData.append("input_keys", key);
    });
    outputKeys.forEach((key) => {
      formData.append("output_keys", key);
    });
    if (description) {
      formData.append("description", description);
    }
    if (dataType) {
      formData.append("data_type", dataType);
    }
    if (name) {
      formData.append("name", name);
    }
    const response = await this.caller.call(fetch, url, {
      method: "POST",
      headers: this.headers,
      body: formData,
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      const result2 = await response.json();
      if (result2.detail && result2.detail.includes("already exists")) {
        throw new Error(`Dataset ${fileName} already exists`);
      }
      throw new Error(
        `Failed to upload CSV: ${response.status} ${response.statusText}`
      );
    }
    const result = await response.json();
    return result;
  }
  async createDataset(name, { description, dataType } = {}) {
    const body = {
      name,
      description,
    };
    if (dataType) {
      body.data_type = dataType;
    }
    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      const result2 = await response.json();
      if (result2.detail && result2.detail.includes("already exists")) {
        throw new Error(`Dataset ${name} already exists`);
      }
      throw new Error(
        `Failed to create dataset ${response.status} ${response.statusText}`
      );
    }
    const result = await response.json();
    return result;
  }
  async readDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    const params = new URLSearchParams({ limit: "1" });
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      assertUuid(datasetId);
      path += `/${datasetId}`;
    } else if (datasetName !== void 0) {
      params.append("name", datasetName);
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(
          `Dataset[id=${datasetId}, name=${datasetName}] not found`
        );
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
    const path = "/datasets";
    if (datasetId !== void 0) {
    } else if (datasetName !== void 0) {
      datasetId = (await this.readDataset({ datasetName })).id;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
    const datasetText = await response.text();
    const dataset = datasetText
      .trim()
      .split("\n")
      .map((line) => JSON.parse(line));
    return dataset;
  }
  async *listDatasets({
    limit = 100,
    offset = 0,
    datasetIds,
    datasetName,
    datasetNameContains,
  } = {}) {
    const path = "/datasets";
    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString(),
    });
    if (datasetIds !== void 0) {
      for (const id_ of datasetIds) {
        params.append("id", id_);
      }
    }
    if (datasetName !== void 0) {
      params.append("name", datasetName);
    }
    if (datasetNameContains !== void 0) {
      params.append("name_contains", datasetNameContains);
    }
    for await (const datasets of this._getPaginated(path, params)) {
      yield* datasets;
    }
  }
  async deleteDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    let datasetId_ = datasetId;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    if (datasetId_ !== void 0) {
      assertUuid(datasetId_);
      path += `/${datasetId_}`;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this.caller.call(fetch, this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      throw new Error(
        `Failed to delete ${path}: ${response.status} ${response.statusText}`
      );
    }
    await response.json();
  }
  async createExample(
    inputs,
    outputs,
    { datasetId, datasetName, createdAt, exampleId }
  ) {
    let datasetId_ = datasetId;
    if (datasetId_ === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const createdAt_ = createdAt || new Date();
    const data = {
      dataset_id: datasetId_,
      inputs,
      outputs,
      created_at: createdAt_.toISOString(),
      id: exampleId,
    };
    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      throw new Error(
        `Failed to create example: ${response.status} ${response.statusText}`
      );
    }
    const result = await response.json();
    return result;
  }
  async createLLMExample(input, generation, options) {
    return this.createExample({ input }, { output: generation }, options);
  }
  async createChatExample(input, generations, options) {
    const finalInput = input.map((message) => {
      if (isLangChainMessage(message)) {
        return convertLangChainMessageToExample(message);
      }
      return message;
    });
    const finalOutput = isLangChainMessage(generations)
      ? convertLangChainMessageToExample(generations)
      : generations;
    return this.createExample(
      { input: finalInput },
      { output: finalOutput },
      options
    );
  }
  async readExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    return await this._get(path);
  }
  async *listExamples({ datasetId, datasetName, exampleIds } = {}) {
    let datasetId_;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      datasetId_ = datasetId;
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      throw new Error("Must provide a datasetName or datasetId");
    }
    const params = new URLSearchParams({ dataset: datasetId_ });
    if (exampleIds !== void 0) {
      for (const id_ of exampleIds) {
        params.append("id", id_);
      }
    }
    for await (const examples of this._getPaginated("/examples", params)) {
      yield* examples;
    }
  }
  async deleteExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const response = await this.caller.call(fetch, this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      throw new Error(
        `Failed to delete ${path}: ${response.status} ${response.statusText}`
      );
    }
    await response.json();
  }
  async updateExample(exampleId, update) {
    assertUuid(exampleId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/examples/${exampleId}`,
      {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    if (!response.ok) {
      throw new Error(
        `Failed to update example ${exampleId}: ${response.status} ${response.statusText}`
      );
    }
    const result = await response.json();
    return result;
  }
  async evaluateRun(
    run,
    evaluator,
    { sourceInfo, loadChildRuns } = { loadChildRuns: false }
  ) {
    let run_;
    if (typeof run === "string") {
      run_ = await this.readRun(run, { loadChildRuns });
    } else if (typeof run === "object" && "id" in run) {
      run_ = run;
    } else {
      throw new Error(`Invalid run type: ${typeof run}`);
    }
    let referenceExample = void 0;
    if (
      run_.reference_example_id !== null &&
      run_.reference_example_id !== void 0
    ) {
      referenceExample = await this.readExample(run_.reference_example_id);
    }
    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
    let sourceInfo_ = sourceInfo != null ? sourceInfo : {};
    if (feedbackResult.evaluatorInfo) {
      sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };
    }
    return await this.createFeedback(run_.id, feedbackResult.key, {
      score: feedbackResult.score,
      value: feedbackResult.value,
      comment: feedbackResult.comment,
      correction: feedbackResult.correction,
      sourceInfo: sourceInfo_,
      feedbackSourceType: "model",
    });
  }
  async createFeedback(
    runId,
    key,
    {
      score,
      value,
      correction,
      comment,
      sourceInfo,
      feedbackSourceType = "api",
      sourceRunId,
      feedbackId,
      eager = false,
    }
  ) {
    var _a4;
    const feedback_source = {
      type: feedbackSourceType != null ? feedbackSourceType : "api",
      metadata: sourceInfo != null ? sourceInfo : {},
    };
    if (
      sourceRunId !== void 0 &&
      (feedback_source == null ? void 0 : feedback_source.metadata) !==
        void 0 &&
      !feedback_source.metadata["__run"]
    ) {
      feedback_source.metadata["__run"] = { run_id: sourceRunId };
    }
    if (
      (feedback_source == null ? void 0 : feedback_source.metadata) !==
        void 0 &&
      ((_a4 = feedback_source.metadata["__run"]) == null
        ? void 0
        : _a4.run_id) !== void 0
    ) {
      assertUuid(feedback_source.metadata["__run"].run_id);
    }
    const feedback = {
      id: feedbackId != null ? feedbackId : v4_default(),
      run_id: runId,
      key,
      score,
      value,
      correction,
      comment,
      feedback_source,
    };
    const url = `${this.apiUrl}/feedback` + (eager ? "/eager" : "");
    const response = await this.caller.call(fetch, url, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedback),
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    await raiseForStatus(response, "create feedback");
    return feedback;
  }
  async updateFeedback(feedbackId, { score, value, correction, comment }) {
    const feedbackUpdate = {};
    if (score !== void 0 && score !== null) {
      feedbackUpdate["score"] = score;
    }
    if (value !== void 0 && value !== null) {
      feedbackUpdate["value"] = value;
    }
    if (correction !== void 0 && correction !== null) {
      feedbackUpdate["correction"] = correction;
    }
    if (comment !== void 0 && comment !== null) {
      feedbackUpdate["comment"] = comment;
    }
    assertUuid(feedbackId);
    const response = await this.caller.call(
      fetch,
      `${this.apiUrl}/feedback/${feedbackId}`,
      {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(feedbackUpdate),
        signal: AbortSignal.timeout(this.timeout_ms),
      }
    );
    await raiseForStatus(response, "update feedback");
  }
  async readFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this._get(path);
    return response;
  }
  async deleteFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this.caller.call(fetch, this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
    });
    if (!response.ok) {
      throw new Error(
        `Failed to delete ${path}: ${response.status} ${response.statusText}`
      );
    }
    await response.json();
  }
  async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
    const queryParams = new URLSearchParams();
    if (runIds) {
      queryParams.append("run", runIds.join(","));
    }
    if (feedbackKeys) {
      for (const key of feedbackKeys) {
        queryParams.append("key", key);
      }
    }
    if (feedbackSourceTypes) {
      for (const type of feedbackSourceTypes) {
        queryParams.append("source", type);
      }
    }
    for await (const feedbacks of this._getPaginated(
      "/feedback",
      queryParams
    )) {
      yield* feedbacks;
    }
  }
};

// ../../../../../../../../node_modules/langchain/dist/util/env.js
var isBrowser2 = () =>
  typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker2 = () =>
  typeof globalThis === "object" &&
  globalThis.constructor &&
  globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom2 = () =>
  (typeof window !== "undefined" && window.name === "nodejs") ||
  (typeof navigator !== "undefined" &&
    (navigator.userAgent.includes("Node.js") ||
      navigator.userAgent.includes("jsdom")));
var isDeno2 = () => typeof Deno !== "undefined";
var isNode2 = () =>
  typeof process !== "undefined" &&
  typeof process.versions !== "undefined" &&
  typeof process.versions.node !== "undefined" &&
  !isDeno2();
var getEnv2 = () => {
  let env;
  if (isBrowser2()) {
    env = "browser";
  } else if (isNode2()) {
    env = "node";
  } else if (isWebWorker2()) {
    env = "webworker";
  } else if (isJsDom2()) {
    env = "jsdom";
  } else if (isDeno2()) {
    env = "deno";
  } else {
    env = "other";
  }
  return env;
};
var runtimeEnvironment2;
async function getRuntimeEnvironment2() {
  if (runtimeEnvironment2 === void 0) {
    const env = getEnv2();
    runtimeEnvironment2 = {
      library: "langchain-js",
      runtime: env,
    };
  }
  return runtimeEnvironment2;
}
function getEnvironmentVariable2(name) {
  var _a4;
  try {
    return typeof process !== "undefined"
      ? (_a4 = process.env) == null
        ? void 0
        : _a4[name]
      : void 0;
  } catch (e) {
    return void 0;
  }
}

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/tracer_langchain.js
var LangChainTracer = class extends BaseTracer {
  constructor(fields = {}) {
    var _a4;
    super(fields);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "langchain_tracer",
    });
    Object.defineProperty(this, "projectName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "exampleId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    const { exampleId, projectName, client } = fields;
    this.projectName =
      (_a4 =
        projectName != null
          ? projectName
          : getEnvironmentVariable2("LANGCHAIN_PROJECT")) != null
        ? _a4
        : getEnvironmentVariable2("LANGCHAIN_SESSION");
    this.exampleId = exampleId;
    this.client = client != null ? client : new Client({});
  }
  async _convertToCreate(run, example_id = void 0) {
    return {
      ...run,
      extra: {
        ...run.extra,
        runtime: await getRuntimeEnvironment2(),
      },
      child_runs: void 0,
      session_name: this.projectName,
      reference_example_id: run.parent_run_id ? void 0 : example_id,
    };
  }
  async persistRun(_run) {}
  async _persistRunSingle(run) {
    const persistedRun = await this._convertToCreate(run, this.exampleId);
    await this.client.createRun(persistedRun);
  }
  async _updateRunSingle(run) {
    const runUpdate = {
      end_time: run.end_time,
      error: run.error,
      outputs: run.outputs,
      events: run.events,
      inputs: run.inputs,
    };
    await this.client.updateRun(run.id, runUpdate);
  }
  async onRetrieverStart(run) {
    await this._persistRunSingle(run);
  }
  async onRetrieverEnd(run) {
    await this._updateRunSingle(run);
  }
  async onRetrieverError(run) {
    await this._updateRunSingle(run);
  }
  async onLLMStart(run) {
    await this._persistRunSingle(run);
  }
  async onLLMEnd(run) {
    await this._updateRunSingle(run);
  }
  async onLLMError(run) {
    await this._updateRunSingle(run);
  }
  async onChainStart(run) {
    await this._persistRunSingle(run);
  }
  async onChainEnd(run) {
    await this._updateRunSingle(run);
  }
  async onChainError(run) {
    await this._updateRunSingle(run);
  }
  async onToolStart(run) {
    await this._persistRunSingle(run);
  }
  async onToolEnd(run) {
    await this._updateRunSingle(run);
  }
  async onToolError(run) {
    await this._updateRunSingle(run);
  }
};

// ../../../../../../../../node_modules/langchain/dist/memory/base.js
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m._getType() === "human") {
      role = humanPrefix;
    } else if (m._getType() === "ai") {
      role = aiPrefix;
    } else if (m._getType() === "system") {
      role = "System";
    } else if (m._getType() === "function") {
      role = "Function";
    } else if (m._getType() === "generic") {
      role = m.role;
    } else {
      throw new Error(`Got unsupported message type: ${m}`);
    }
    const nameStr = m.name ? `${m.name}, ` : "";
    string_messages.push(`${role}: ${nameStr}${m.content}`);
  }
  return string_messages.join("\n");
}

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/tracer_langchain_v1.js
var LangChainTracerV1 = class extends BaseTracer {
  constructor() {
    super();
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "langchain_tracer",
    });
    Object.defineProperty(this, "endpoint", {
      enumerable: true,
      configurable: true,
      writable: true,
      value:
        getEnvironmentVariable2("LANGCHAIN_ENDPOINT") ||
        "http://localhost:1984",
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        "Content-Type": "application/json",
      },
    });
    Object.defineProperty(this, "session", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    const apiKey = getEnvironmentVariable2("LANGCHAIN_API_KEY");
    if (apiKey) {
      this.headers["x-api-key"] = apiKey;
    }
  }
  async newSession(sessionName) {
    const sessionCreate = {
      start_time: Date.now(),
      name: sessionName,
    };
    const session = await this.persistSession(sessionCreate);
    this.session = session;
    return session;
  }
  async loadSession(sessionName) {
    const endpoint = `${this.endpoint}/sessions?name=${sessionName}`;
    return this._handleSessionResponse(endpoint);
  }
  async loadDefaultSession() {
    const endpoint = `${this.endpoint}/sessions?name=default`;
    return this._handleSessionResponse(endpoint);
  }
  async convertV2RunToRun(run) {
    var _a4, _b;
    const session =
      (_a4 = this.session) != null ? _a4 : await this.loadDefaultSession();
    const serialized = run.serialized;
    let runResult;
    if (run.run_type === "llm") {
      const prompts = run.inputs.prompts
        ? run.inputs.prompts
        : run.inputs.messages.map((x) => getBufferString(x));
      const llmRun = {
        uuid: run.id,
        start_time: run.start_time,
        end_time: run.end_time,
        execution_order: run.execution_order,
        child_execution_order: run.child_execution_order,
        serialized,
        type: run.run_type,
        session_id: session.id,
        prompts,
        response: run.outputs,
      };
      runResult = llmRun;
    } else if (run.run_type === "chain") {
      const child_runs = await Promise.all(
        run.child_runs.map((child_run) => this.convertV2RunToRun(child_run))
      );
      const chainRun = {
        uuid: run.id,
        start_time: run.start_time,
        end_time: run.end_time,
        execution_order: run.execution_order,
        child_execution_order: run.child_execution_order,
        serialized,
        type: run.run_type,
        session_id: session.id,
        inputs: run.inputs,
        outputs: run.outputs,
        child_llm_runs: child_runs.filter(
          (child_run) => child_run.type === "llm"
        ),
        child_chain_runs: child_runs.filter(
          (child_run) => child_run.type === "chain"
        ),
        child_tool_runs: child_runs.filter(
          (child_run) => child_run.type === "tool"
        ),
      };
      runResult = chainRun;
    } else if (run.run_type === "tool") {
      const child_runs = await Promise.all(
        run.child_runs.map((child_run) => this.convertV2RunToRun(child_run))
      );
      const toolRun = {
        uuid: run.id,
        start_time: run.start_time,
        end_time: run.end_time,
        execution_order: run.execution_order,
        child_execution_order: run.child_execution_order,
        serialized,
        type: run.run_type,
        session_id: session.id,
        tool_input: run.inputs.input,
        output: (_b = run.outputs) == null ? void 0 : _b.output,
        action: JSON.stringify(serialized),
        child_llm_runs: child_runs.filter(
          (child_run) => child_run.type === "llm"
        ),
        child_chain_runs: child_runs.filter(
          (child_run) => child_run.type === "chain"
        ),
        child_tool_runs: child_runs.filter(
          (child_run) => child_run.type === "tool"
        ),
      };
      runResult = toolRun;
    } else {
      throw new Error(`Unknown run type: ${run.run_type}`);
    }
    return runResult;
  }
  async persistRun(run) {
    let endpoint;
    let v1Run;
    if (run.run_type !== void 0) {
      v1Run = await this.convertV2RunToRun(run);
    } else {
      v1Run = run;
    }
    if (v1Run.type === "llm") {
      endpoint = `${this.endpoint}/llm-runs`;
    } else if (v1Run.type === "chain") {
      endpoint = `${this.endpoint}/chain-runs`;
    } else {
      endpoint = `${this.endpoint}/tool-runs`;
    }
    const response = await fetch(endpoint, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(v1Run),
    });
    if (!response.ok) {
      console.error(
        `Failed to persist run: ${response.status} ${response.statusText}`
      );
    }
  }
  async persistSession(sessionCreate) {
    const endpoint = `${this.endpoint}/sessions`;
    const response = await fetch(endpoint, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(sessionCreate),
    });
    if (!response.ok) {
      console.error(
        `Failed to persist session: ${response.status} ${response.statusText}, using default session.`
      );
      return {
        id: 1,
        ...sessionCreate,
      };
    }
    return {
      id: (await response.json()).id,
      ...sessionCreate,
    };
  }
  async _handleSessionResponse(endpoint) {
    const response = await fetch(endpoint, {
      method: "GET",
      headers: this.headers,
    });
    let tracerSession;
    if (!response.ok) {
      console.error(
        `Failed to load session: ${response.status} ${response.statusText}`
      );
      tracerSession = {
        id: 1,
        start_time: Date.now(),
      };
      this.session = tracerSession;
      return tracerSession;
    }
    const resp = await response.json();
    if (resp.length === 0) {
      tracerSession = {
        id: 1,
        start_time: Date.now(),
      };
      this.session = tracerSession;
      return tracerSession;
    }
    [tracerSession] = resp;
    this.session = tracerSession;
    return tracerSession;
  }
};

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/initialize.js
async function getTracingCallbackHandler(session) {
  const tracer = new LangChainTracerV1();
  if (session) {
    await tracer.loadSession(session);
  } else {
    await tracer.loadDefaultSession();
  }
  return tracer;
}
async function getTracingV2CallbackHandler() {
  return new LangChainTracer();
}

// ../../../../../../../../node_modules/langchain/dist/callbacks/promises.js
var import_p_queue2 = __toESM(require_dist(), 1);
var queue;
function createQueue() {
  const PQueue =
    "default" in import_p_queue2.default
      ? import_p_queue2.default.default
      : import_p_queue2.default;
  return new PQueue({
    autoStart: true,
    concurrency: 1,
  });
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    await promiseFn();
  } else {
    if (typeof queue === "undefined") {
      queue = createQueue();
    }
    void queue.add(promiseFn);
  }
}

// ../../../../../../../../node_modules/langchain/dist/callbacks/manager.js
function parseCallbackConfigArg(arg) {
  if (!arg) {
    return {};
  } else if (Array.isArray(arg) || "name" in arg) {
    return { callbacks: arg };
  } else {
    return arg;
  }
}
var BaseCallbackManager = class {
  setHandler(handler) {
    return this.setHandlers([handler]);
  }
};
var BaseRunManager = class {
  constructor(
    runId,
    handlers,
    inheritableHandlers,
    tags,
    inheritableTags,
    metadata,
    inheritableMetadata,
    _parentRunId
  ) {
    Object.defineProperty(this, "runId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: runId,
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: handlers,
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableHandlers,
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tags,
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableTags,
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: metadata,
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableMetadata,
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _parentRunId,
    });
  }
  async handleText(text) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          try {
            await ((_a4 = handler.handleText) == null
              ? void 0
              : _a4.call(
                  handler,
                  text,
                  this.runId,
                  this._parentRunId,
                  this.tags
                ));
          } catch (err) {
            console.error(
              `Error in handler ${handler.constructor.name}, handleText: ${err}`
            );
          }
        }, handler.awaitHandlers)
      )
    );
  }
};
var CallbackManagerForRetrieverRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleRetrieverEnd(documents) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreRetriever) {
            try {
              await ((_a4 = handler.handleRetrieverEnd) == null
                ? void 0
                : _a4.call(
                    handler,
                    documents,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleRetriever`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleRetrieverError(err) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreRetriever) {
            try {
              await ((_a4 = handler.handleRetrieverError) == null
                ? void 0
                : _a4.call(
                    handler,
                    err,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (error) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
};
var CallbackManagerForLLMRun = class extends BaseRunManager {
  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreLLM) {
            try {
              await ((_a4 = handler.handleLLMNewToken) == null
                ? void 0
                : _a4.call(
                    handler,
                    token,
                    idx != null ? idx : { prompt: 0, completion: 0 },
                    this.runId,
                    this._parentRunId,
                    this.tags,
                    fields
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleLLMError(err) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreLLM) {
            try {
              await ((_a4 = handler.handleLLMError) == null
                ? void 0
                : _a4.call(
                    handler,
                    err,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err2) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleLLMError: ${err2}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleLLMEnd(output) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreLLM) {
            try {
              await ((_a4 = handler.handleLLMEnd) == null
                ? void 0
                : _a4.call(
                    handler,
                    output,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
};
var CallbackManagerForChainRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreChain) {
            try {
              await ((_a4 = handler.handleChainError) == null
                ? void 0
                : _a4.call(
                    handler,
                    err,
                    this.runId,
                    this._parentRunId,
                    this.tags,
                    kwargs
                  ));
            } catch (err2) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleChainError: ${err2}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreChain) {
            try {
              await ((_a4 = handler.handleChainEnd) == null
                ? void 0
                : _a4.call(
                    handler,
                    output,
                    this.runId,
                    this._parentRunId,
                    this.tags,
                    kwargs
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleAgentAction(action) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreAgent) {
            try {
              await ((_a4 = handler.handleAgentAction) == null
                ? void 0
                : _a4.call(
                    handler,
                    action,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleAgentEnd(action) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreAgent) {
            try {
              await ((_a4 = handler.handleAgentEnd) == null
                ? void 0
                : _a4.call(
                    handler,
                    action,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
};
var CallbackManagerForToolRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleToolError(err) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreAgent) {
            try {
              await ((_a4 = handler.handleToolError) == null
                ? void 0
                : _a4.call(
                    handler,
                    err,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err2) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleToolError: ${err2}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
  async handleToolEnd(output) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreAgent) {
            try {
              await ((_a4 = handler.handleToolEnd) == null
                ? void 0
                : _a4.call(
                    handler,
                    output,
                    this.runId,
                    this._parentRunId,
                    this.tags
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
  }
};
var CallbackManager = class extends BaseCallbackManager {
  constructor(parentRunId) {
    super();
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: [],
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: [],
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {},
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {},
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "callback_manager",
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.handlers = [];
    this.inheritableHandlers = [];
    this._parentRunId = parentRunId;
  }
  async handleLLMStart(
    llm,
    prompts,
    _runId = void 0,
    _parentRunId = void 0,
    extraParams = void 0,
    _tags = void 0,
    _metadata = void 0,
    runName = void 0
  ) {
    return Promise.all(
      prompts.map(async (prompt) => {
        const runId = v4_default();
        await Promise.all(
          this.handlers.map((handler) =>
            consumeCallback(async () => {
              var _a4;
              if (!handler.ignoreLLM) {
                try {
                  await ((_a4 = handler.handleLLMStart) == null
                    ? void 0
                    : _a4.call(
                        handler,
                        llm,
                        [prompt],
                        runId,
                        this._parentRunId,
                        extraParams,
                        this.tags,
                        this.metadata,
                        runName
                      ));
                } catch (err) {
                  console.error(
                    `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`
                  );
                }
              }
            }, handler.awaitHandlers)
          )
        );
        return new CallbackManagerForLLMRun(
          runId,
          this.handlers,
          this.inheritableHandlers,
          this.tags,
          this.inheritableTags,
          this.metadata,
          this.inheritableMetadata,
          this._parentRunId
        );
      })
    );
  }
  async handleChatModelStart(
    llm,
    messages,
    _runId = void 0,
    _parentRunId = void 0,
    extraParams = void 0,
    _tags = void 0,
    _metadata = void 0,
    runName = void 0
  ) {
    return Promise.all(
      messages.map(async (messageGroup) => {
        const runId = v4_default();
        await Promise.all(
          this.handlers.map((handler) =>
            consumeCallback(async () => {
              var _a4, _b;
              if (!handler.ignoreLLM) {
                try {
                  if (handler.handleChatModelStart) {
                    await ((_a4 = handler.handleChatModelStart) == null
                      ? void 0
                      : _a4.call(
                          handler,
                          llm,
                          [messageGroup],
                          runId,
                          this._parentRunId,
                          extraParams,
                          this.tags,
                          this.metadata,
                          runName
                        ));
                  } else if (handler.handleLLMStart) {
                    const messageString = getBufferString(messageGroup);
                    await ((_b = handler.handleLLMStart) == null
                      ? void 0
                      : _b.call(
                          handler,
                          llm,
                          [messageString],
                          runId,
                          this._parentRunId,
                          extraParams,
                          this.tags,
                          this.metadata,
                          runName
                        ));
                  }
                } catch (err) {
                  console.error(
                    `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`
                  );
                }
              }
            }, handler.awaitHandlers)
          )
        );
        return new CallbackManagerForLLMRun(
          runId,
          this.handlers,
          this.inheritableHandlers,
          this.tags,
          this.inheritableTags,
          this.metadata,
          this.inheritableMetadata,
          this._parentRunId
        );
      })
    );
  }
  async handleChainStart(
    chain,
    inputs,
    runId = v4_default(),
    runType = void 0,
    _tags = void 0,
    _metadata = void 0,
    runName = void 0
  ) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreChain) {
            try {
              await ((_a4 = handler.handleChainStart) == null
                ? void 0
                : _a4.call(
                    handler,
                    chain,
                    inputs,
                    runId,
                    this._parentRunId,
                    this.tags,
                    this.metadata,
                    runType,
                    runName
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleChainStart: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
    return new CallbackManagerForChainRun(
      runId,
      this.handlers,
      this.inheritableHandlers,
      this.tags,
      this.inheritableTags,
      this.metadata,
      this.inheritableMetadata,
      this._parentRunId
    );
  }
  async handleToolStart(
    tool,
    input,
    runId = v4_default(),
    _parentRunId = void 0,
    _tags = void 0,
    _metadata = void 0,
    runName = void 0
  ) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreAgent) {
            try {
              await ((_a4 = handler.handleToolStart) == null
                ? void 0
                : _a4.call(
                    handler,
                    tool,
                    input,
                    runId,
                    this._parentRunId,
                    this.tags,
                    this.metadata,
                    runName
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleToolStart: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
    return new CallbackManagerForToolRun(
      runId,
      this.handlers,
      this.inheritableHandlers,
      this.tags,
      this.inheritableTags,
      this.metadata,
      this.inheritableMetadata,
      this._parentRunId
    );
  }
  async handleRetrieverStart(
    retriever,
    query,
    runId = v4_default(),
    _parentRunId = void 0,
    _tags = void 0,
    _metadata = void 0,
    runName = void 0
  ) {
    await Promise.all(
      this.handlers.map((handler) =>
        consumeCallback(async () => {
          var _a4;
          if (!handler.ignoreRetriever) {
            try {
              await ((_a4 = handler.handleRetrieverStart) == null
                ? void 0
                : _a4.call(
                    handler,
                    retriever,
                    query,
                    runId,
                    this._parentRunId,
                    this.tags,
                    this.metadata,
                    runName
                  ));
            } catch (err) {
              console.error(
                `Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`
              );
            }
          }
        }, handler.awaitHandlers)
      )
    );
    return new CallbackManagerForRetrieverRun(
      runId,
      this.handlers,
      this.inheritableHandlers,
      this.tags,
      this.inheritableTags,
      this.metadata,
      this.inheritableMetadata,
      this._parentRunId
    );
  }
  addHandler(handler, inherit = true) {
    this.handlers.push(handler);
    if (inherit) {
      this.inheritableHandlers.push(handler);
    }
  }
  removeHandler(handler) {
    this.handlers = this.handlers.filter((_handler) => _handler !== handler);
    this.inheritableHandlers = this.inheritableHandlers.filter(
      (_handler) => _handler !== handler
    );
  }
  setHandlers(handlers, inherit = true) {
    this.handlers = [];
    this.inheritableHandlers = [];
    for (const handler of handlers) {
      this.addHandler(handler, inherit);
    }
  }
  addTags(tags, inherit = true) {
    this.removeTags(tags);
    this.tags.push(...tags);
    if (inherit) {
      this.inheritableTags.push(...tags);
    }
  }
  removeTags(tags) {
    this.tags = this.tags.filter((tag) => !tags.includes(tag));
    this.inheritableTags = this.inheritableTags.filter(
      (tag) => !tags.includes(tag)
    );
  }
  addMetadata(metadata, inherit = true) {
    this.metadata = { ...this.metadata, ...metadata };
    if (inherit) {
      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };
    }
  }
  removeMetadata(metadata) {
    for (const key of Object.keys(metadata)) {
      delete this.metadata[key];
      delete this.inheritableMetadata[key];
    }
  }
  copy(additionalHandlers = [], inherit = true) {
    const manager = new CallbackManager(this._parentRunId);
    for (const handler of this.handlers) {
      const inheritable = this.inheritableHandlers.includes(handler);
      manager.addHandler(handler, inheritable);
    }
    for (const tag of this.tags) {
      const inheritable = this.inheritableTags.includes(tag);
      manager.addTags([tag], inheritable);
    }
    for (const key of Object.keys(this.metadata)) {
      const inheritable = Object.keys(this.inheritableMetadata).includes(key);
      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
    }
    for (const handler of additionalHandlers) {
      if (
        manager.handlers
          .filter((h) => h.name === "console_callback_handler")
          .some((h) => h.name === handler.name)
      ) {
        continue;
      }
      manager.addHandler(handler, inherit);
    }
    return manager;
  }
  static fromHandlers(handlers) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default(),
        });
        Object.assign(this, handlers);
      }
    }
    const manager = new this();
    manager.addHandler(new Handler());
    return manager;
  }
  static async configure(
    inheritableHandlers,
    localHandlers,
    inheritableTags,
    localTags,
    inheritableMetadata,
    localMetadata,
    options
  ) {
    var _a4, _b;
    let callbackManager;
    if (inheritableHandlers || localHandlers) {
      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
        callbackManager = new CallbackManager();
        callbackManager.setHandlers(
          (_a4 =
            inheritableHandlers == null
              ? void 0
              : inheritableHandlers.map(ensureHandler)) != null
            ? _a4
            : [],
          true
        );
      } else {
        callbackManager = inheritableHandlers;
      }
      callbackManager = callbackManager.copy(
        Array.isArray(localHandlers)
          ? localHandlers.map(ensureHandler)
          : localHandlers == null
          ? void 0
          : localHandlers.handlers,
        false
      );
    }
    const verboseEnabled =
      getEnvironmentVariable2("LANGCHAIN_VERBOSE") === "true" ||
      (options == null ? void 0 : options.verbose);
    const tracingV2Enabled =
      getEnvironmentVariable2("LANGCHAIN_TRACING_V2") === "true";
    const tracingEnabled =
      tracingV2Enabled ||
      ((_b = getEnvironmentVariable2("LANGCHAIN_TRACING")) != null
        ? _b
        : false);
    if (verboseEnabled || tracingEnabled) {
      if (!callbackManager) {
        callbackManager = new CallbackManager();
      }
      if (
        verboseEnabled &&
        !callbackManager.handlers.some(
          (handler) => handler.name === ConsoleCallbackHandler.prototype.name
        )
      ) {
        const consoleHandler = new ConsoleCallbackHandler();
        callbackManager.addHandler(consoleHandler, true);
      }
      if (
        tracingEnabled &&
        !callbackManager.handlers.some(
          (handler) => handler.name === "langchain_tracer"
        )
      ) {
        if (tracingV2Enabled) {
          callbackManager.addHandler(await getTracingV2CallbackHandler(), true);
        } else {
          const session =
            getEnvironmentVariable2("LANGCHAIN_PROJECT") &&
            getEnvironmentVariable2("LANGCHAIN_SESSION");
          callbackManager.addHandler(
            await getTracingCallbackHandler(session),
            true
          );
        }
      }
    }
    if (inheritableTags || localTags) {
      if (callbackManager) {
        callbackManager.addTags(inheritableTags != null ? inheritableTags : []);
        callbackManager.addTags(localTags != null ? localTags : [], false);
      }
    }
    if (inheritableMetadata || localMetadata) {
      if (callbackManager) {
        callbackManager.addMetadata(
          inheritableMetadata != null ? inheritableMetadata : {}
        );
        callbackManager.addMetadata(
          localMetadata != null ? localMetadata : {},
          false
        );
      }
    }
    return callbackManager;
  }
};
function ensureHandler(handler) {
  if ("name" in handler) {
    return handler;
  }
  return BaseCallbackHandler.fromMethods(handler);
}

// ../../../../../../../../node_modules/langchain/dist/schema/runnable/base.js
var import_p_retry3 = __toESM(require_p_retry(), 1);

// ../../../../../../../../node_modules/langchain/dist/util/fast-json-patch/src/core.js
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate2,
  validator: () => validator,
});

// ../../../../../../../../node_modules/langchain/dist/util/fast-json-patch/src/helpers.js
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys2 = new Array(obj.length);
    for (let k = 0; k < keys2.length; k++) {
      keys2[k] = "" + k;
    }
    return keys2;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  let keys = [];
  for (let i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str3) {
  let i = 0;
  const len = str3.length;
  let charCode;
  while (i < len) {
    charCode = str3.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1) return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i2 = 0, len = obj.length; i2 < len; i2++) {
        if (hasUndefined(obj[i2])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value =
      typeof args[key] === "object"
        ? JSON.stringify(args[key], null, 2)
        : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(`${key}: ${value}`);
    }
  }
  return messageParts.join("\n");
}
var PatchError = class extends Error {
  constructor(message, name, index, operation, tree) {
    super(
      patchErrorMessageFormatter(message, { name, index, operation, tree })
    );
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: name,
    });
    Object.defineProperty(this, "index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: index,
    });
    Object.defineProperty(this, "operation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: operation,
    });
    Object.defineProperty(this, "tree", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tree,
    });
    Object.setPrototypeOf(this, new.target.prototype);
    this.message = patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree,
    });
  }
};

// ../../../../../../../../node_modules/langchain/dist/util/fast-json-patch/src/core.js
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function (obj, key, document) {
    obj[key] = this.value;
    return { newDocument: document };
  },
  remove: function (obj, key, document) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document, removed };
  },
  replace: function (obj, key, document) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document, removed };
  },
  move: function (obj, key, document) {
    let removed = getValueByPointer(document, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    const originalValue = applyOperation(document, {
      op: "remove",
      path: this.from,
    }).removed;
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: originalValue,
    });
    return { newDocument: document, removed };
  },
  copy: function (obj, key, document) {
    const valueToCopy = getValueByPointer(document, this.from);
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: _deepClone(valueToCopy),
    });
    return { newDocument: document };
  },
  test: function (obj, key, document) {
    return { newDocument: document, test: _areEquals(obj[key], this.value) };
  },
  _get: function (obj, key, document) {
    this.value = obj[key];
    return { newDocument: document };
  },
};
var arrOps = {
  add: function (arr, i, document) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document, index: i };
  },
  remove: function (arr, i, document) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document, removed: removedList[0] };
  },
  replace: function (arr, i, document) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get,
};
function getValueByPointer(document, pointer) {
  if (pointer == "") {
    return document;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(
  document,
  operation,
  validateOperation = false,
  mutateDocument = true,
  banPrototypeModifications = true,
  index = 0
) {
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    let returnValue = { newDocument: document };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError(
          "Test operation failed",
          "TEST_OPERATION_FAILED",
          index,
          operation,
          document
        );
      }
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError(
          "Operation `op` property is not one of operations defined in RFC-6902",
          "OPERATION_OP_INVALID",
          index,
          operation,
          document
        );
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document = _deepClone(document);
    }
    const path = operation.path || "";
    const keys = path.split("/");
    let obj = document;
    let t = 1;
    let len = keys.length;
    let existingPathFragment = void 0;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (
        banPrototypeModifications &&
        (key == "__proto__" ||
          (key == "prototype" && t > 0 && keys[t - 1] == "constructor"))
      ) {
        throw new TypeError(
          "JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README"
        );
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError(
              "Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index",
              "OPERATION_PATH_ILLEGAL_ARRAY_INDEX",
              index,
              operation,
              document
            );
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError(
              "The specified index MUST NOT be greater than the number of elements in the array",
              "OPERATION_VALUE_OUT_OF_BOUNDS",
              index,
              operation,
              document
            );
          }
          const returnValue = arrOps[operation.op].call(
            operation,
            obj,
            key,
            document
          );
          if (returnValue.test === false) {
            throw new JsonPatchError(
              "Test operation failed",
              "TEST_OPERATION_FAILED",
              index,
              operation,
              document
            );
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          const returnValue = objOps[operation.op].call(
            operation,
            obj,
            key,
            document
          );
          if (returnValue.test === false) {
            throw new JsonPatchError(
              "Test operation failed",
              "TEST_OPERATION_FAILED",
              index,
              operation,
              document
            );
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError(
          "Cannot perform operation at the desired path",
          "OPERATION_PATH_UNRESOLVABLE",
          index,
          operation,
          document
        );
      }
    }
  }
}
function applyPatch(
  document,
  patch,
  validateOperation,
  mutateDocument = true,
  banPrototypeModifications = true
) {
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError(
        "Patch sequence must be an array",
        "SEQUENCE_NOT_AN_ARRAY"
      );
    }
  }
  if (!mutateDocument) {
    document = _deepClone(document);
  }
  const results = new Array(patch.length);
  for (let i = 0, length = patch.length; i < length; i++) {
    results[i] = applyOperation(
      document,
      patch[i],
      validateOperation,
      true,
      banPrototypeModifications,
      i
    );
    document = results[i].newDocument;
  }
  results.newDocument = document;
  return results;
}
function applyReducer(document, operation, index) {
  const operationResult = applyOperation(document, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError(
      "Test operation failed",
      "TEST_OPERATION_FAILED",
      index,
      operation,
      document
    );
  }
  return operationResult.newDocument;
}
function validator(operation, index, document, existingPathFragment) {
  if (
    typeof operation !== "object" ||
    operation === null ||
    Array.isArray(operation)
  ) {
    throw new JsonPatchError(
      "Operation is not an object",
      "OPERATION_NOT_AN_OBJECT",
      index,
      operation,
      document
    );
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError(
      "Operation `op` property is not one of operations defined in RFC-6902",
      "OPERATION_OP_INVALID",
      index,
      operation,
      document
    );
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError(
      "Operation `path` property is not a string",
      "OPERATION_PATH_INVALID",
      index,
      operation,
      document
    );
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError(
      'Operation `path` property must start with "/"',
      "OPERATION_PATH_INVALID",
      index,
      operation,
      document
    );
  } else if (
    (operation.op === "move" || operation.op === "copy") &&
    typeof operation.from !== "string"
  ) {
    throw new JsonPatchError(
      "Operation `from` property is not present (applicable in `move` and `copy` operations)",
      "OPERATION_FROM_REQUIRED",
      index,
      operation,
      document
    );
  } else if (
    (operation.op === "add" ||
      operation.op === "replace" ||
      operation.op === "test") &&
    operation.value === void 0
  ) {
    throw new JsonPatchError(
      "Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)",
      "OPERATION_VALUE_REQUIRED",
      index,
      operation,
      document
    );
  } else if (
    (operation.op === "add" ||
      operation.op === "replace" ||
      operation.op === "test") &&
    hasUndefined(operation.value)
  ) {
    throw new JsonPatchError(
      "Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)",
      "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",
      index,
      operation,
      document
    );
  } else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError(
          "Cannot perform an `add` operation at the desired path",
          "OPERATION_PATH_CANNOT_ADD",
          index,
          operation,
          document
        );
      }
    } else if (
      operation.op === "replace" ||
      operation.op === "remove" ||
      operation.op === "_get"
    ) {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError(
          "Cannot perform the operation at a path that does not exist",
          "OPERATION_PATH_UNRESOLVABLE",
          index,
          operation,
          document
        );
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: void 0,
      };
      var error = validate2([existingValue], document);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError(
          "Cannot perform the operation from a path that does not exist",
          "OPERATION_FROM_UNRESOLVABLE",
          index,
          operation,
          document
        );
      }
    }
  }
}
function validate2(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError(
        "Patch sequence must be an array",
        "SEQUENCE_NOT_AN_ARRAY"
      );
    }
    if (document) {
      applyPatch(
        _deepClone(document),
        _deepClone(sequence),
        externalValidator || true
      );
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a),
      arrB = Array.isArray(b),
      i,
      length,
      key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; ) if (!_areEquals(a[i], b[i])) return false;
      return true;
    }
    if (arrA != arrB) return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0; ) if (!b.hasOwnProperty(keys[i])) return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key])) return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// ../../../../../../../../node_modules/langchain/dist/util/fast-json-patch/index.js
var fast_json_patch_default = {
  ...core_exports,
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent,
};

// ../../../../../../../../node_modules/langchain/dist/util/stream.js
var IterableReadableStream = class extends ReadableStream {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "reader", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
  }
  ensureReader() {
    if (!this.reader) {
      this.reader = this.getReader();
    }
  }
  async next() {
    this.ensureReader();
    try {
      const result = await this.reader.read();
      if (result.done) this.reader.releaseLock();
      return {
        done: result.done,
        value: result.value,
      };
    } catch (e) {
      this.reader.releaseLock();
      throw e;
    }
  }
  async return() {
    this.ensureReader();
    const cancelPromise = this.reader.cancel();
    this.reader.releaseLock();
    await cancelPromise;
    return { done: true, value: void 0 };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  static fromReadableStream(stream) {
    const reader = stream.getReader();
    return new IterableReadableStream({
      start(controller) {
        return pump();
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            return pump();
          });
        }
      },
      cancel() {
        reader.releaseLock();
      },
    });
  }
  static fromAsyncGenerator(generator) {
    return new IterableReadableStream({
      async pull(controller) {
        const { value, done } = await generator.next();
        if (done) {
          controller.close();
        }
        controller.enqueue(value);
      },
    });
  }
};

// ../../../../../../../../node_modules/langchain/dist/callbacks/handlers/log_stream.js
var RunLogPatch = class {
  constructor(fields) {
    Object.defineProperty(this, "ops", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.ops = fields.ops;
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch({}, ops);
    return new RunLog({
      ops,
      state: states[states.length - 1].newDocument,
    });
  }
};
var RunLog = class extends RunLogPatch {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.state = fields.state;
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch(this.state, other.ops);
    return new RunLog({ ops, state: states[states.length - 1].newDocument });
  }
};
var LogStreamCallbackHandler = class extends BaseTracer {
  constructor(fields) {
    var _a4;
    super(fields);
    Object.defineProperty(this, "autoClose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "keyMapByRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {},
    });
    Object.defineProperty(this, "counterMapByRunName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {},
    });
    Object.defineProperty(this, "transformStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "writer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "receiveStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "log_stream_tracer",
    });
    this.autoClose =
      (_a4 = fields == null ? void 0 : fields.autoClose) != null ? _a4 : true;
    this.includeNames = fields == null ? void 0 : fields.includeNames;
    this.includeTypes = fields == null ? void 0 : fields.includeTypes;
    this.includeTags = fields == null ? void 0 : fields.includeTags;
    this.excludeNames = fields == null ? void 0 : fields.excludeNames;
    this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
    this.excludeTags = fields == null ? void 0 : fields.excludeTags;
    this.transformStream = new TransformStream();
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(
      this.transformStream.readable
    );
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {}
  _includeRun(run) {
    var _a4;
    if (run.parent_run_id === void 0) {
      return false;
    }
    const runTags = (_a4 = run.tags) != null ? _a4 : [];
    let include =
      this.includeNames === void 0 &&
      this.includeTags === void 0 &&
      this.includeTypes === void 0;
    if (this.includeNames !== void 0) {
      include = include || this.includeNames.includes(run.name);
    }
    if (this.includeTypes !== void 0) {
      include = include || this.includeTypes.includes(run.run_type);
    }
    if (this.includeTags !== void 0) {
      include =
        include ||
        runTags.find((tag) => {
          var _a5;
          return (_a5 = this.includeTags) == null ? void 0 : _a5.includes(tag);
        }) !== void 0;
    }
    if (this.excludeNames !== void 0) {
      include = include && !this.excludeNames.includes(run.name);
    }
    if (this.excludeTypes !== void 0) {
      include = include && !this.excludeTypes.includes(run.run_type);
    }
    if (this.excludeTags !== void 0) {
      include =
        include &&
        runTags.every((tag) => {
          var _a5;
          return !((_a5 = this.excludeTags) == null
            ? void 0
            : _a5.includes(tag));
        });
    }
    return include;
  }
  async onRunCreate(run) {
    var _a4, _b, _c;
    if (run.parent_run_id === void 0) {
      await this.writer.write(
        new RunLogPatch({
          ops: [
            {
              op: "replace",
              path: "",
              value: {
                id: run.id,
                streamed_output: [],
                final_output: void 0,
                logs: {},
              },
            },
          ],
        })
      );
    }
    if (!this._includeRun(run)) {
      return;
    }
    if (this.counterMapByRunName[run.name] === void 0) {
      this.counterMapByRunName[run.name] = 0;
    }
    this.counterMapByRunName[run.name] += 1;
    const count = this.counterMapByRunName[run.name];
    this.keyMapByRunId[run.id] =
      count === 1 ? run.name : `${run.name}:${count}`;
    const logEntry = {
      id: run.id,
      name: run.name,
      type: run.run_type,
      tags: (_a4 = run.tags) != null ? _a4 : [],
      metadata:
        (_c = (_b = run.extra) == null ? void 0 : _b.metadata) != null
          ? _c
          : {},
      start_time: new Date(run.start_time).toISOString(),
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0,
    };
    await this.writer.write(
      new RunLogPatch({
        ops: [
          {
            op: "add",
            path: `/logs/${this.keyMapByRunId[run.id]}`,
            value: logEntry,
          },
        ],
      })
    );
  }
  async onRunUpdate(run) {
    try {
      const runName = this.keyMapByRunId[run.id];
      if (runName === void 0) {
        return;
      }
      const ops = [
        {
          op: "add",
          path: `/logs/${runName}/final_output`,
          value: run.outputs,
        },
      ];
      if (run.end_time !== void 0) {
        ops.push({
          op: "add",
          path: `/logs/${runName}/end_time`,
          value: new Date(run.end_time).toISOString(),
        });
      }
      const patch = new RunLogPatch({ ops });
      await this.writer.write(patch);
    } finally {
      if (run.parent_run_id === void 0) {
        const patch = new RunLogPatch({
          ops: [
            {
              op: "replace",
              path: "/final_output",
              value: run.outputs,
            },
          ],
        });
        await this.writer.write(patch);
        if (this.autoClose) {
          await this.writer.close();
        }
      }
    }
  }
  async onLLMNewToken(run, token) {
    const runName = this.keyMapByRunId[run.id];
    if (runName === void 0) {
      return;
    }
    const patch = new RunLogPatch({
      ops: [
        {
          op: "add",
          path: `/logs/${runName}/streamed_output_str/-`,
          value: token,
        },
      ],
    });
    await this.writer.write(patch);
  }
};

// ../../../../../../../../node_modules/langchain/dist/schema/runnable/config.js
async function getCallbackMangerForConfig(config) {
  return CallbackManager.configure(
    config == null ? void 0 : config.callbacks,
    void 0,
    config == null ? void 0 : config.tags,
    void 0,
    config == null ? void 0 : config.metadata
  );
}

// ../../../../../../../../node_modules/langchain/dist/util/async_caller.js
var import_p_retry2 = __toESM(require_p_retry(), 1);
var import_p_queue3 = __toESM(require_dist(), 1);
var STATUS_NO_RETRY2 = [400, 401, 402, 403, 404, 405, 406, 407, 408, 409];
var defaultFailedAttemptHandler = (error) => {
  var _a4, _b, _c;
  if (
    error.message.startsWith("Cancel") ||
    error.message.startsWith("TimeoutError") ||
    error.name === "TimeoutError" ||
    error.message.startsWith("AbortError") ||
    error.name === "AbortError"
  ) {
    throw error;
  }
  if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
    throw error;
  }
  const status =
    (_b =
      (_a4 = error == null ? void 0 : error.response) == null
        ? void 0
        : _a4.status) != null
      ? _b
      : error == null
      ? void 0
      : error.status;
  if (status && STATUS_NO_RETRY2.includes(+status)) {
    throw error;
  }
  if (
    ((_c = error == null ? void 0 : error.error) == null ? void 0 : _c.code) ===
    "insufficient_quota"
  ) {
    const err = new Error(error == null ? void 0 : error.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
var AsyncCaller2 = class {
  constructor(params) {
    var _a4, _b, _c;
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.maxConcurrency =
      (_a4 = params.maxConcurrency) != null ? _a4 : Infinity;
    this.maxRetries = (_b = params.maxRetries) != null ? _b : 6;
    this.onFailedAttempt =
      (_c = params.onFailedAttempt) != null ? _c : defaultFailedAttemptHandler;
    const PQueue =
      "default" in import_p_queue3.default
        ? import_p_queue3.default.default
        : import_p_queue3.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
  }
  call(callable, ...args) {
    return this.queue.add(
      () =>
        (0, import_p_retry2.default)(
          () =>
            callable(...args).catch((error) => {
              if (error instanceof Error) {
                throw error;
              } else {
                throw new Error(error);
              }
            }),
          {
            onFailedAttempt: this.onFailedAttempt,
            retries: this.maxRetries,
            randomize: true,
          }
        ),
      { throwOnTimeout: true }
    );
  }
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          var _a4;
          (_a4 = options.signal) == null
            ? void 0
            : _a4.addEventListener("abort", () => {
                reject(new Error("AbortError"));
              });
        }),
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() =>
      fetch(...args).then((res) => (res.ok ? res : Promise.reject(res)))
    );
  }
};

// ../../../../../../../../node_modules/langchain/dist/schema/runnable/base.js
function _coerceToDict2(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object"
    ? value
    : { [defaultKey]: value };
}
var Runnable = class extends Serializable {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "lc_runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
  }
  bind(kwargs) {
    return new RunnableBinding({ bound: this, kwargs, config: {} });
  }
  map() {
    return new RunnableEach({ bound: this });
  }
  withRetry(fields) {
    return new RunnableRetry({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
      ...fields,
    });
  }
  withConfig(config) {
    return new RunnableBinding({
      bound: this,
      config,
      kwargs: {},
    });
  }
  withFallbacks(fields) {
    return new RunnableWithFallbacks({
      runnable: this,
      fallbacks: fields.fallbacks,
    });
  }
  _getOptionsList(options, length = 0) {
    if (Array.isArray(options)) {
      if (options.length !== length) {
        throw new Error(
          `Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`
        );
      }
      return options;
    }
    return Array.from({ length }, () => options);
  }
  async batch(inputs, options, batchOptions) {
    const configList = this._getOptionsList(
      options != null ? options : {},
      inputs.length
    );
    const caller = new AsyncCaller2({
      maxConcurrency:
        batchOptions == null ? void 0 : batchOptions.maxConcurrency,
      onFailedAttempt: (e) => {
        throw e;
      },
    });
    const batchCalls = inputs.map((input, i) =>
      caller.call(async () => {
        try {
          const result = await this.invoke(input, configList[i]);
          return result;
        } catch (e) {
          if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
            return e;
          }
          throw e;
        }
      })
    );
    return Promise.all(batchCalls);
  }
  async *_streamIterator(input, options) {
    yield this.invoke(input, options);
  }
  async stream(input, options) {
    return IterableReadableStream.fromAsyncGenerator(
      this._streamIterator(input, options)
    );
  }
  _separateRunnableConfigFromCallOptions(options = {}) {
    const runnableConfig = {
      callbacks: options.callbacks,
      tags: options.tags,
      metadata: options.metadata,
      runName: options.runName,
    };
    const callOptions = { ...options };
    delete callOptions.callbacks;
    delete callOptions.tags;
    delete callOptions.metadata;
    delete callOptions.runName;
    return [runnableConfig, callOptions];
  }
  async _callWithConfig(func, input, options) {
    const callbackManager_ = await getCallbackMangerForConfig(options);
    const runManager = await (callbackManager_ == null
      ? void 0
      : callbackManager_.handleChainStart(
          this.toJSON(),
          _coerceToDict2(input, "input"),
          void 0,
          options == null ? void 0 : options.runType,
          void 0,
          void 0,
          options == null ? void 0 : options.runName
        ));
    let output;
    try {
      output = await func.bind(this)(input, options, runManager);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null
      ? void 0
      : runManager.handleChainEnd(_coerceToDict2(output, "output")));
    return output;
  }
  async _batchWithConfig(func, inputs, options, batchOptions) {
    const optionsList = this._getOptionsList(
      options != null ? options : {},
      inputs.length
    );
    const callbackManagers = await Promise.all(
      optionsList.map(getCallbackMangerForConfig)
    );
    const runManagers = await Promise.all(
      callbackManagers.map((callbackManager, i) =>
        callbackManager == null
          ? void 0
          : callbackManager.handleChainStart(
              this.toJSON(),
              _coerceToDict2(inputs[i], "input"),
              void 0,
              optionsList[i].runType,
              void 0,
              void 0,
              optionsList[i].runName
            )
      )
    );
    let outputs;
    try {
      outputs = await func(inputs, optionsList, runManagers, batchOptions);
    } catch (e) {
      await Promise.all(
        runManagers.map((runManager) =>
          runManager == null ? void 0 : runManager.handleChainError(e)
        )
      );
      throw e;
    }
    await Promise.all(
      runManagers.map((runManager) =>
        runManager == null
          ? void 0
          : runManager.handleChainEnd(_coerceToDict2(outputs, "output"))
      )
    );
    return outputs;
  }
  async *_transformStreamWithConfig(inputGenerator, transformer, options) {
    let finalInput;
    let finalInputSupported = true;
    let finalOutput;
    let finalOutputSupported = true;
    const callbackManager_ = await getCallbackMangerForConfig(options);
    let runManager;
    const serializedRepresentation = this.toJSON();
    async function* wrapInputForTracing() {
      for await (const chunk of inputGenerator) {
        if (!runManager) {
          runManager = await (callbackManager_ == null
            ? void 0
            : callbackManager_.handleChainStart(
                serializedRepresentation,
                { input: "" },
                void 0,
                options == null ? void 0 : options.runType,
                void 0,
                void 0,
                options == null ? void 0 : options.runName
              ));
        }
        if (finalInputSupported) {
          if (finalInput === void 0) {
            finalInput = chunk;
          } else {
            try {
              finalInput = finalInput.concat(chunk);
            } catch (e) {
              finalInput = void 0;
              finalInputSupported = false;
            }
          }
        }
        yield chunk;
      }
    }
    const wrappedInputGenerator = wrapInputForTracing();
    try {
      const outputIterator = transformer(
        wrappedInputGenerator,
        runManager,
        options
      );
      for await (const chunk of outputIterator) {
        yield chunk;
        if (finalOutputSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = finalOutput.concat(chunk);
            } catch (e) {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
        }
      }
    } catch (e) {
      await (runManager == null
        ? void 0
        : runManager.handleChainError(e, void 0, void 0, void 0, {
            inputs: _coerceToDict2(finalInput, "input"),
          }));
      throw e;
    }
    await (runManager == null
      ? void 0
      : runManager.handleChainEnd(
          finalOutput != null ? finalOutput : {},
          void 0,
          void 0,
          void 0,
          { inputs: _coerceToDict2(finalInput, "input") }
        ));
  }
  _patchConfig(config = {}, callbackManager = void 0) {
    const newConfig = { ...config };
    if (callbackManager !== void 0) {
      delete newConfig.runName;
      return { ...newConfig, callbacks: callbackManager };
    }
    return newConfig;
  }
  pipe(coerceable) {
    return new RunnableSequence({
      first: this,
      last: _coerceToRunnable(coerceable),
    });
  }
  async *transform(generator, options) {
    let finalChunk;
    for await (const chunk of generator) {
      if (finalChunk === void 0) {
        finalChunk = chunk;
      } else {
        finalChunk = finalChunk.concat(chunk);
      }
    }
    yield* this._streamIterator(finalChunk, options);
  }
  async *streamLog(input, options, streamOptions) {
    const stream = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
    });
    const config = options != null ? options : {};
    const { callbacks } = config;
    if (callbacks === void 0) {
      config.callbacks = [stream];
    } else if (Array.isArray(callbacks)) {
      config.callbacks = callbacks.concat([stream]);
    } else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.inheritableHandlers.push(stream);
      config.callbacks = copiedCallbacks;
    }
    const runnableStream = await this.stream(input, config);
    async function consumeRunnableStream() {
      try {
        for await (const chunk of runnableStream) {
          const patch = new RunLogPatch({
            ops: [
              {
                op: "add",
                path: "/streamed_output/-",
                value: chunk,
              },
            ],
          });
          await stream.writer.write(patch);
        }
      } finally {
        await stream.writer.close();
      }
    }
    const runnableStreamPromise = consumeRunnableStream();
    try {
      for await (const log of stream) {
        yield log;
      }
    } finally {
      await runnableStreamPromise;
    }
  }
  static isRunnable(thing) {
    return thing ? thing.lc_runnable : false;
  }
};
var RunnableBinding = class extends Runnable {
  static lc_name() {
    return "RunnableBinding";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.bound = fields.bound;
    this.kwargs = fields.kwargs;
    this.config = fields.config;
  }
  _mergeConfig(options) {
    var _a4, _b, _c;
    const copy = { ...this.config };
    if (options) {
      for (const key of Object.keys(options)) {
        if (key === "metadata") {
          copy[key] = { ...copy[key], ...options[key] };
        } else if (key === "tags") {
          copy[key] = ((_a4 = copy[key]) != null ? _a4 : []).concat(
            (_b = options[key]) != null ? _b : []
          );
        } else {
          copy[key] = (_c = options[key]) != null ? _c : copy[key];
        }
      }
    }
    return copy;
  }
  bind(kwargs) {
    return this.constructor({
      bound: this.bound,
      kwargs: { ...this.kwargs, ...kwargs },
      config: this.config,
    });
  }
  withConfig(config) {
    return this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: { ...this.config, ...config },
    });
  }
  withRetry(fields) {
    return this.constructor({
      bound: this.bound.withRetry(fields),
      kwargs: this.kwargs,
      config: this.config,
    });
  }
  async invoke(input, options) {
    return this.bound.invoke(
      input,
      this._mergeConfig({ ...options, ...this.kwargs })
    );
  }
  async batch(inputs, options, batchOptions) {
    const mergedOptions = Array.isArray(options)
      ? options.map((individualOption) =>
          this._mergeConfig({
            ...individualOption,
            ...this.kwargs,
          })
        )
      : this._mergeConfig({ ...options, ...this.kwargs });
    return this.bound.batch(inputs, mergedOptions, batchOptions);
  }
  async *_streamIterator(input, options) {
    yield* this.bound._streamIterator(
      input,
      this._mergeConfig({ ...options, ...this.kwargs })
    );
  }
  async stream(input, options) {
    return this.bound.stream(
      input,
      this._mergeConfig({ ...options, ...this.kwargs })
    );
  }
  async *transform(generator, options) {
    yield* this.bound.transform(
      generator,
      this._mergeConfig({ ...options, ...this.kwargs })
    );
  }
  static isRunnableBinding(thing) {
    return thing.bound && Runnable.isRunnable(thing.bound);
  }
};
var RunnableEach = class extends Runnable {
  static lc_name() {
    return "RunnableEach";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    Object.defineProperty(this, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.bound = fields.bound;
  }
  bind(kwargs) {
    return new RunnableEach({
      bound: this.bound.bind(kwargs),
    });
  }
  async invoke(inputs, config) {
    return this._callWithConfig(this._invoke, inputs, config);
  }
  async _invoke(inputs, config, runManager) {
    return this.bound.batch(
      inputs,
      this._patchConfig(
        config,
        runManager == null ? void 0 : runManager.getChild()
      )
    );
  }
};
var RunnableRetry = class extends RunnableBinding {
  static lc_name() {
    return "RunnableRetry";
  }
  constructor(fields) {
    var _a4, _b;
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    Object.defineProperty(this, "maxAttemptNumber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3,
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => {},
    });
    this.maxAttemptNumber =
      (_a4 = fields.maxAttemptNumber) != null ? _a4 : this.maxAttemptNumber;
    this.onFailedAttempt =
      (_b = fields.onFailedAttempt) != null ? _b : this.onFailedAttempt;
  }
  _patchConfigForRetry(attempt, config, runManager) {
    const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
    return this._patchConfig(
      config,
      runManager == null ? void 0 : runManager.getChild(tag)
    );
  }
  async _invoke(input, config, runManager) {
    return (0, import_p_retry3.default)(
      (attemptNumber) =>
        super.invoke(
          input,
          this._patchConfigForRetry(attemptNumber, config, runManager)
        ),
      {
        onFailedAttempt: this.onFailedAttempt,
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true,
      }
    );
  }
  async invoke(input, config) {
    return this._callWithConfig(this._invoke, input, config);
  }
  async _batch(inputs, configs, runManagers, batchOptions) {
    const resultsMap = {};
    try {
      await (0, import_p_retry3.default)(
        async (attemptNumber) => {
          const remainingIndexes = inputs
            .map((_, i) => i)
            .filter(
              (i) =>
                resultsMap[i.toString()] === void 0 ||
                resultsMap[i.toString()] instanceof Error
            );
          const remainingInputs = remainingIndexes.map((i) => inputs[i]);
          const patchedConfigs = remainingIndexes.map((i) =>
            this._patchConfigForRetry(
              attemptNumber,
              configs == null ? void 0 : configs[i],
              runManagers == null ? void 0 : runManagers[i]
            )
          );
          const results = await super.batch(remainingInputs, patchedConfigs, {
            ...batchOptions,
            returnExceptions: true,
          });
          let firstException;
          for (let i = 0; i < results.length; i += 1) {
            const result = results[i];
            const resultMapIndex = remainingIndexes[i];
            if (result instanceof Error) {
              if (firstException === void 0) {
                firstException = result;
              }
            }
            resultsMap[resultMapIndex.toString()] = result;
          }
          if (firstException) {
            throw firstException;
          }
          return results;
        },
        {
          onFailedAttempt: this.onFailedAttempt,
          retries: Math.max(this.maxAttemptNumber - 1, 0),
          randomize: true,
        }
      );
    } catch (e) {
      if (
        (batchOptions == null ? void 0 : batchOptions.returnExceptions) !== true
      ) {
        throw e;
      }
    }
    return Object.keys(resultsMap)
      .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))
      .map((key) => resultsMap[parseInt(key, 10)]);
  }
  async batch(inputs, options, batchOptions) {
    return this._batchWithConfig(
      this._batch.bind(this),
      inputs,
      options,
      batchOptions
    );
  }
};
var RunnableSequence = class extends Runnable {
  static lc_name() {
    return "RunnableSequence";
  }
  constructor(fields) {
    var _a4;
    super(fields);
    Object.defineProperty(this, "first", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "middle", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: [],
    });
    Object.defineProperty(this, "last", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    this.first = fields.first;
    this.middle = (_a4 = fields.middle) != null ? _a4 : this.middle;
    this.last = fields.last;
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(input, options) {
    const callbackManager_ = await getCallbackMangerForConfig(options);
    const runManager = await (callbackManager_ == null
      ? void 0
      : callbackManager_.handleChainStart(
          this.toJSON(),
          _coerceToDict2(input, "input"),
          void 0,
          void 0,
          void 0,
          void 0,
          options == null ? void 0 : options.runName
        ));
    let nextStepInput = input;
    let finalOutput;
    try {
      const initialSteps = [this.first, ...this.middle];
      for (let i = 0; i < initialSteps.length; i += 1) {
        const step = initialSteps[i];
        nextStepInput = await step.invoke(
          nextStepInput,
          this._patchConfig(
            options,
            runManager == null
              ? void 0
              : runManager.getChild(`seq:step:${i + 1}`)
          )
        );
      }
      finalOutput = await this.last.invoke(
        nextStepInput,
        this._patchConfig(
          options,
          runManager == null
            ? void 0
            : runManager.getChild(`seq:step:${this.steps.length}`)
        )
      );
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null
      ? void 0
      : runManager.handleChainEnd(_coerceToDict2(finalOutput, "output")));
    return finalOutput;
  }
  async batch(inputs, options, batchOptions) {
    const configList = this._getOptionsList(
      options != null ? options : {},
      inputs.length
    );
    const callbackManagers = await Promise.all(
      configList.map(getCallbackMangerForConfig)
    );
    const runManagers = await Promise.all(
      callbackManagers.map((callbackManager, i) =>
        callbackManager == null
          ? void 0
          : callbackManager.handleChainStart(
              this.toJSON(),
              _coerceToDict2(inputs[i], "input"),
              void 0,
              void 0,
              void 0,
              void 0,
              configList[i].runName
            )
      )
    );
    let nextStepInputs = inputs;
    let finalOutputs;
    try {
      const initialSteps = [this.first, ...this.middle];
      for (let i = 0; i < initialSteps.length; i += 1) {
        const step = initialSteps[i];
        nextStepInputs = await step.batch(
          nextStepInputs,
          runManagers.map((runManager, j) =>
            this._patchConfig(
              configList[j],
              runManager == null
                ? void 0
                : runManager.getChild(`seq:step:${i + 1}`)
            )
          ),
          batchOptions
        );
      }
      finalOutputs = await this.last.batch(
        nextStepInputs,
        runManagers.map((runManager) =>
          this._patchConfig(
            configList[this.steps.length - 1],
            runManager == null
              ? void 0
              : runManager.getChild(`seq:step:${this.steps.length}`)
          )
        ),
        batchOptions
      );
    } catch (e) {
      await Promise.all(
        runManagers.map((runManager) =>
          runManager == null ? void 0 : runManager.handleChainError(e)
        )
      );
      throw e;
    }
    await Promise.all(
      runManagers.map((runManager, i) =>
        runManager == null
          ? void 0
          : runManager.handleChainEnd(_coerceToDict2(finalOutputs[i], "output"))
      )
    );
    return finalOutputs;
  }
  async *_streamIterator(input, options) {
    const callbackManager_ = await getCallbackMangerForConfig(options);
    const runManager = await (callbackManager_ == null
      ? void 0
      : callbackManager_.handleChainStart(
          this.toJSON(),
          _coerceToDict2(input, "input"),
          void 0,
          void 0,
          void 0,
          void 0,
          options == null ? void 0 : options.runName
        ));
    let nextStepInput = input;
    const steps = [this.first, ...this.middle, this.last];
    const streamingStartStepIndex = Math.min(
      steps.length - 1,
      steps.length -
        [...steps].reverse().findIndex((step) => {
          var _a4;
          const isDefaultImplementation =
            step.transform === Runnable.prototype.transform;
          const boundRunnableIsDefaultImplementation =
            RunnableBinding.isRunnableBinding(step) &&
            ((_a4 = step.bound) == null ? void 0 : _a4.transform) ===
              Runnable.prototype.transform;
          return (
            isDefaultImplementation || boundRunnableIsDefaultImplementation
          );
        }) -
        1
    );
    try {
      const invokeSteps = steps.slice(0, streamingStartStepIndex);
      for (let i = 0; i < invokeSteps.length; i += 1) {
        const step = invokeSteps[i];
        nextStepInput = await step.invoke(
          nextStepInput,
          this._patchConfig(
            options,
            runManager == null
              ? void 0
              : runManager.getChild(`seq:step:${i + 1}`)
          )
        );
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    let concatSupported = true;
    let finalOutput;
    try {
      let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(
        nextStepInput,
        this._patchConfig(
          options,
          runManager == null
            ? void 0
            : runManager.getChild(`seq:step:${streamingStartStepIndex + 1}`)
        )
      );
      const finalSteps = steps.slice(streamingStartStepIndex + 1);
      for (let i = 0; i < finalSteps.length; i += 1) {
        const step = finalSteps[i];
        finalGenerator = await step.transform(
          finalGenerator,
          this._patchConfig(
            options,
            runManager == null
              ? void 0
              : runManager.getChild(
                  `seq:step:${streamingStartStepIndex + i + 2}`
                )
          )
        );
      }
      for await (const chunk of finalGenerator) {
        yield chunk;
        if (concatSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = finalOutput.concat(chunk);
            } catch (e) {
              finalOutput = void 0;
              concatSupported = false;
            }
          }
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null
      ? void 0
      : runManager.handleChainEnd(_coerceToDict2(finalOutput, "output")));
  }
  pipe(coerceable) {
    if (RunnableSequence.isRunnableSequence(coerceable)) {
      return new RunnableSequence({
        first: this.first,
        middle: this.middle.concat([
          this.last,
          coerceable.first,
          ...coerceable.middle,
        ]),
        last: coerceable.last,
      });
    } else {
      return new RunnableSequence({
        first: this.first,
        middle: [...this.middle, this.last],
        last: _coerceToRunnable(coerceable),
      });
    }
  }
  static isRunnableSequence(thing) {
    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
  }
  static from([first, ...runnables]) {
    return new RunnableSequence({
      first: _coerceToRunnable(first),
      middle: runnables.slice(0, -1).map(_coerceToRunnable),
      last: _coerceToRunnable(runnables[runnables.length - 1]),
    });
  }
};
var RunnableMap = class extends Runnable {
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "steps", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.steps = {};
    for (const [key, value] of Object.entries(fields.steps)) {
      this.steps[key] = _coerceToRunnable(value);
    }
  }
  static from(steps) {
    return new RunnableMap({ steps });
  }
  async invoke(input, options) {
    const callbackManager_ = await getCallbackMangerForConfig(options);
    const runManager = await (callbackManager_ == null
      ? void 0
      : callbackManager_.handleChainStart(
          this.toJSON(),
          {
            input,
          },
          void 0,
          void 0,
          void 0,
          void 0,
          options == null ? void 0 : options.runName
        ));
    const output = {};
    try {
      await Promise.all(
        Object.entries(this.steps).map(async ([key, runnable]) => {
          output[key] = await runnable.invoke(
            input,
            this._patchConfig(
              options,
              runManager == null ? void 0 : runManager.getChild(key)
            )
          );
        })
      );
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(output));
    return output;
  }
};
var RunnableLambda = class extends Runnable {
  static lc_name() {
    return "RunnableLambda";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    Object.defineProperty(this, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.func = fields.func;
  }
  static from(func) {
    return new RunnableLambda({
      func,
    });
  }
  async _invoke(input, config, runManager) {
    let output = await this.func(input);
    if (output && Runnable.isRunnable(output)) {
      output = await output.invoke(
        input,
        this._patchConfig(
          config,
          runManager == null ? void 0 : runManager.getChild()
        )
      );
    }
    return output;
  }
  async invoke(input, options) {
    return this._callWithConfig(this._invoke, input, options);
  }
};
var RunnableWithFallbacks = class extends Runnable {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "schema", "runnable"],
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "fallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.runnable = fields.runnable;
    this.fallbacks = fields.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const fallback of this.fallbacks) {
      yield fallback;
    }
  }
  async invoke(input, options) {
    const callbackManager_ = await CallbackManager.configure(
      options == null ? void 0 : options.callbacks,
      void 0,
      options == null ? void 0 : options.tags,
      void 0,
      options == null ? void 0 : options.metadata
    );
    const runManager = await (callbackManager_ == null
      ? void 0
      : callbackManager_.handleChainStart(
          this.toJSON(),
          _coerceToDict2(input, "input"),
          void 0,
          void 0,
          void 0,
          void 0,
          options == null ? void 0 : options.runName
        ));
    let firstError;
    for (const runnable of this.runnables()) {
      try {
        const output = await runnable.invoke(
          input,
          this._patchConfig(
            options,
            runManager == null ? void 0 : runManager.getChild()
          )
        );
        await (runManager == null
          ? void 0
          : runManager.handleChainEnd(_coerceToDict2(output, "output")));
        return output;
      } catch (e) {
        if (firstError === void 0) {
          firstError = e;
        }
      }
    }
    if (firstError === void 0) {
      throw new Error("No error stored at end of fallback.");
    }
    await (runManager == null
      ? void 0
      : runManager.handleChainError(firstError));
    throw firstError;
  }
  async batch(inputs, options, batchOptions) {
    if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
      throw new Error("Not implemented.");
    }
    const configList = this._getOptionsList(
      options != null ? options : {},
      inputs.length
    );
    const callbackManagers = await Promise.all(
      configList.map((config) =>
        CallbackManager.configure(
          config == null ? void 0 : config.callbacks,
          void 0,
          config == null ? void 0 : config.tags,
          void 0,
          config == null ? void 0 : config.metadata
        )
      )
    );
    const runManagers = await Promise.all(
      callbackManagers.map((callbackManager, i) =>
        callbackManager == null
          ? void 0
          : callbackManager.handleChainStart(
              this.toJSON(),
              _coerceToDict2(inputs[i], "input"),
              void 0,
              void 0,
              void 0,
              void 0,
              configList[i].runName
            )
      )
    );
    let firstError;
    for (const runnable of this.runnables()) {
      try {
        const outputs = await runnable.batch(
          inputs,
          runManagers.map((runManager, j) =>
            this._patchConfig(
              configList[j],
              runManager == null ? void 0 : runManager.getChild()
            )
          ),
          batchOptions
        );
        await Promise.all(
          runManagers.map((runManager, i) =>
            runManager == null
              ? void 0
              : runManager.handleChainEnd(_coerceToDict2(outputs[i], "output"))
          )
        );
        return outputs;
      } catch (e) {
        if (firstError === void 0) {
          firstError = e;
        }
      }
    }
    if (!firstError) {
      throw new Error("No error stored at end of fallbacks.");
    }
    await Promise.all(
      runManagers.map((runManager) =>
        runManager == null ? void 0 : runManager.handleChainError(firstError)
      )
    );
    throw firstError;
  }
};
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function") {
    return new RunnableLambda({ func: coerceable });
  } else if (Runnable.isRunnable(coerceable)) {
    return coerceable;
  } else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
    const runnables = {};
    for (const [key, value] of Object.entries(coerceable)) {
      runnables[key] = _coerceToRunnable(value);
    }
    return new RunnableMap({
      steps: runnables,
    });
  } else {
    throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
  }
}

// ../../../../../../../../node_modules/langchain/dist/schema/retriever.js
var BaseRetriever = class extends Runnable {
  constructor(fields) {
    var _a4, _b, _c;
    super(fields);
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "verbose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.callbacks = fields == null ? void 0 : fields.callbacks;
    this.tags =
      (_a4 = fields == null ? void 0 : fields.tags) != null ? _a4 : [];
    this.metadata =
      (_b = fields == null ? void 0 : fields.metadata) != null ? _b : {};
    this.verbose =
      (_c = fields == null ? void 0 : fields.verbose) != null ? _c : false;
  }
  _getRelevantDocuments(_query, _callbacks) {
    throw new Error("Not implemented!");
  }
  async invoke(input, options) {
    return this.getRelevantDocuments(input, options);
  }
  async getRelevantDocuments(query, config) {
    const parsedConfig = parseCallbackConfigArg(config);
    const callbackManager_ = await CallbackManager.configure(
      parsedConfig.callbacks,
      this.callbacks,
      parsedConfig.tags,
      this.tags,
      parsedConfig.metadata,
      this.metadata,
      { verbose: this.verbose }
    );
    const runManager = await (callbackManager_ == null
      ? void 0
      : callbackManager_.handleRetrieverStart(
          this.toJSON(),
          query,
          void 0,
          void 0,
          void 0,
          void 0,
          parsedConfig.runName
        ));
    try {
      const results = await this._getRelevantDocuments(query, runManager);
      await (runManager == null
        ? void 0
        : runManager.handleRetrieverEnd(results));
      return results;
    } catch (error) {
      await (runManager == null
        ? void 0
        : runManager.handleRetrieverError(error));
      throw error;
    }
  }
};

// ../../../../../../../../node_modules/langchain/dist/vectorstores/base.js
var VectorStoreRetriever = class extends BaseRetriever {
  static lc_name() {
    return "VectorStoreRetriever";
  }
  get lc_namespace() {
    return ["langchain", "retrievers", "base"];
  }
  _vectorstoreType() {
    return this.vectorStore._vectorstoreType();
  }
  constructor(fields) {
    var _a4, _b;
    super(fields);
    Object.defineProperty(this, "vectorStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "k", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4,
    });
    Object.defineProperty(this, "searchType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "similarity",
    });
    Object.defineProperty(this, "searchKwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "filter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.vectorStore = fields.vectorStore;
    this.k = (_a4 = fields.k) != null ? _a4 : this.k;
    this.searchType = (_b = fields.searchType) != null ? _b : this.searchType;
    this.filter = fields.filter;
    if (fields.searchType === "mmr") {
      this.searchKwargs = fields.searchKwargs;
    }
  }
  async _getRelevantDocuments(query, runManager) {
    if (this.searchType === "mmr") {
      if (typeof this.vectorStore.maxMarginalRelevanceSearch !== "function") {
        throw new Error(
          `The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`
        );
      }
      return this.vectorStore.maxMarginalRelevanceSearch(
        query,
        {
          k: this.k,
          filter: this.filter,
          ...this.searchKwargs,
        },
        runManager == null ? void 0 : runManager.getChild("vectorstore")
      );
    }
    return this.vectorStore.similaritySearch(
      query,
      this.k,
      this.filter,
      runManager == null ? void 0 : runManager.getChild("vectorstore")
    );
  }
  async addDocuments(documents, options) {
    return this.vectorStore.addDocuments(documents, options);
  }
};
var VectorStore = class extends Serializable {
  constructor(embeddings, dbConfig) {
    super(dbConfig);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "vectorstores", this._vectorstoreType()],
    });
    Object.defineProperty(this, "embeddings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.embeddings = embeddings;
  }
  async delete(_params) {
    throw new Error("Not implemented.");
  }
  async similaritySearch(query, k = 4, filter = void 0, _callbacks = void 0) {
    const results = await this.similaritySearchVectorWithScore(
      await this.embeddings.embedQuery(query),
      k,
      filter
    );
    return results.map((result) => result[0]);
  }
  async similaritySearchWithScore(
    query,
    k = 4,
    filter = void 0,
    _callbacks = void 0
  ) {
    return this.similaritySearchVectorWithScore(
      await this.embeddings.embedQuery(query),
      k,
      filter
    );
  }
  static fromTexts(_texts, _metadatas, _embeddings, _dbConfig) {
    throw new Error(
      "the Langchain vectorstore implementation you are using forgot to override this, please report a bug"
    );
  }
  static fromDocuments(_docs, _embeddings, _dbConfig) {
    throw new Error(
      "the Langchain vectorstore implementation you are using forgot to override this, please report a bug"
    );
  }
  asRetriever(kOrFields, filter, callbacks, tags, metadata, verbose) {
    var _a4;
    if (typeof kOrFields === "number") {
      return new VectorStoreRetriever({
        vectorStore: this,
        k: kOrFields,
        filter,
        tags: [...(tags != null ? tags : []), this._vectorstoreType()],
        metadata,
        verbose,
        callbacks,
      });
    } else {
      const params = {
        vectorStore: this,
        k: kOrFields == null ? void 0 : kOrFields.k,
        filter: kOrFields == null ? void 0 : kOrFields.filter,
        tags: [
          ...((_a4 = kOrFields == null ? void 0 : kOrFields.tags) != null
            ? _a4
            : []),
          this._vectorstoreType(),
        ],
        metadata: kOrFields == null ? void 0 : kOrFields.metadata,
        verbose: kOrFields == null ? void 0 : kOrFields.verbose,
        callbacks: kOrFields == null ? void 0 : kOrFields.callbacks,
        searchType: kOrFields == null ? void 0 : kOrFields.searchType,
      };
      if ((kOrFields == null ? void 0 : kOrFields.searchType) === "mmr") {
        return new VectorStoreRetriever({
          ...params,
          searchKwargs: kOrFields.searchKwargs,
        });
      }
      return new VectorStoreRetriever({ ...params });
    }
  }
};

// ../../../../../../../../node_modules/langchain/dist/document.js
var Document = class {
  constructor(fields) {
    var _a4;
    Object.defineProperty(this, "pageContent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.pageContent = fields.pageContent
      ? fields.pageContent.toString()
      : this.pageContent;
    this.metadata = (_a4 = fields.metadata) != null ? _a4 : {};
  }
};

// ../../../../../../../../node_modules/langchain/dist/vectorstores/memory.js
var MemoryVectorStore = class extends VectorStore {
  _vectorstoreType() {
    return "memory";
  }
  constructor(embeddings, { similarity, ...rest } = {}) {
    super(embeddings, rest);
    Object.defineProperty(this, "memoryVectors", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: [],
    });
    Object.defineProperty(this, "similarity", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.similarity =
      similarity != null ? similarity : similarities_exports.cosine;
  }
  async addDocuments(documents) {
    const texts = documents.map(({ pageContent }) => pageContent);
    return this.addVectors(
      await this.embeddings.embedDocuments(texts),
      documents
    );
  }
  async addVectors(vectors, documents) {
    const memoryVectors = vectors.map((embedding, idx) => ({
      content: documents[idx].pageContent,
      embedding,
      metadata: documents[idx].metadata,
    }));
    this.memoryVectors = this.memoryVectors.concat(memoryVectors);
  }
  async similaritySearchVectorWithScore(query, k, filter) {
    const filterFunction = (memoryVector) => {
      if (!filter) {
        return true;
      }
      const doc = new Document({
        metadata: memoryVector.metadata,
        pageContent: memoryVector.content,
      });
      return filter(doc);
    };
    const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);
    const searches = filteredMemoryVectors
      .map((vector, index) => ({
        similarity: this.similarity(query, vector.embedding),
        index,
      }))
      .sort((a, b) => (a.similarity > b.similarity ? -1 : 0))
      .slice(0, k);
    const result = searches.map((search) => [
      new Document({
        metadata: filteredMemoryVectors[search.index].metadata,
        pageContent: filteredMemoryVectors[search.index].content,
      }),
      search.similarity,
    ]);
    return result;
  }
  static async fromTexts(texts, metadatas, embeddings, dbConfig) {
    const docs = [];
    for (let i = 0; i < texts.length; i += 1) {
      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
      const newDoc = new Document({
        pageContent: texts[i],
        metadata,
      });
      docs.push(newDoc);
    }
    return MemoryVectorStore.fromDocuments(docs, embeddings, dbConfig);
  }
  static async fromDocuments(docs, embeddings, dbConfig) {
    const instance = new this(embeddings, dbConfig);
    await instance.addDocuments(docs);
    return instance;
  }
  static async fromExistingIndex(embeddings, dbConfig) {
    const instance = new this(embeddings, dbConfig);
    return instance;
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/version.mjs
var VERSION = "4.19.0";

// ../../../../../../../../node_modules/langchain/node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(
      `you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`
    );
  }
  if (kind) {
    throw new Error(
      `can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``
    );
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// ../../../../../../../../node_modules/langchain/node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported
    ? `You may need to use polyfills`
    : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(
      `this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`
    );
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData:
      typeof FormData !== "undefined"
        ? FormData
        : class FormData {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`
              );
            }
          },
    Blob:
      typeof Blob !== "undefined"
        ? Blob
        : class Blob {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`
              );
            }
          },
    File:
      typeof File !== "undefined"
        ? File
        : class File {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`
              );
            }
          },
    ReadableStream:
      typeof ReadableStream !== "undefined"
        ? ReadableStream
        : class ReadableStream {
            constructor() {
              throw new Error(
                `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`
              );
            }
          },
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form),
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error(
        "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads"
      );
    },
    isFsReadStream: (value) => false,
  };
}

// ../../../../../../../../node_modules/langchain/node_modules/openai/_shims/index.mjs
if (!kind) setShims(getRuntime(), { auto: true });

// ../../../../../../../../node_modules/langchain/node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  OpenAIError: () => OpenAIError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError,
});
var OpenAIError = class extends Error {};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message)
      ? typeof error.message === "string"
        ? error.message
        : JSON.stringify(error.message)
      : error
      ? JSON.stringify(error)
      : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause) this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {};

// ../../../../../../../../node_modules/langchain/node_modules/openai/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new OpenAIError(
          `Attempted to iterate over a response with no body`
        );
      }
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse) yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse) yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
        );
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done) continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") return;
        throw e;
      } finally {
        if (!done) controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
        );
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done) continue;
          if (line) yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") return;
        throw e;
      } finally {
        if (!done) controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue2) => {
      return {
        next: () => {
          if (queue2.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        },
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller),
    ];
  }
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done) return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a4;
        await ((_a4 = iter.return) == null ? void 0 : _a4.call(iter));
      },
    });
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length) return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks,
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(
      text[text.length - 1] || ""
    );
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a4;
    if (bytes == null) return "";
    if (typeof bytes === "string") return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
      );
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a4 = this.textDecoder) != null
          ? _a4
          : (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
      );
    }
    throw new OpenAIError(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
    );
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set([
  "\n",
  "\r",
  "\v",
  "\f",
  "",
  "",
  "",
  "\x85",
  "\u2028",
  "\u2029",
]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str3, delimiter) {
  const index = str3.indexOf(delimiter);
  if (index !== -1) {
    return [
      str3.substring(0, index),
      delimiter,
      str3.substring(index + delimiter.length),
    ];
  }
  return [str3, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator]) return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done) reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}

// ../../../../../../../../node_modules/langchain/node_modules/openai/uploads.mjs
var isResponseLike = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.url === "string" &&
  typeof value.blob === "function";
var isFileLike = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.name === "string" &&
  typeof value.lastModified === "number" &&
  isBlobLike(value);
var isBlobLike = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.size === "number" &&
  typeof value.type === "string" &&
  typeof value.text === "function" &&
  typeof value.slice === "function" &&
  typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a4, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name ||
      (name =
        (_a4 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null
          ? _a4
          : "unknown_file");
    return new File2([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a4;
  let parts = [];
  if (
    typeof value === "string" ||
    ArrayBuffer.isView(value) ||
    value instanceof ArrayBuffer
  ) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${
        (_a4 = value == null ? void 0 : value.constructor) == null
          ? void 0
          : _a4.name
      }; props: ${propsForError(value)}`
    );
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a4;
  return (
    getStringFromMaybeBuffer(value.name) ||
    getStringFromMaybeBuffer(value.filename) ||
    ((_a4 = getStringFromMaybeBuffer(value.path)) == null
      ? void 0
      : _a4.split(/[\\/]/).pop())
  );
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string") return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer) return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) =>
  body &&
  typeof body === "object" &&
  body.body &&
  body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(
    Object.entries(body || {}).map(([key, value]) =>
      addFormValue(form, key, value)
    )
  );
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0) return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`
    );
  }
  if (
    typeof value === "string" ||
    typeof value === "number" ||
    typeof value === "boolean"
  ) {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(
      value.map((entry) => addFormValue(form, key + "[]", entry))
    );
  } else if (typeof value === "object") {
    await Promise.all(
      Object.entries(value).map(([name, prop]) =>
        addFormValue(form, `${key}[${name}]`, prop)
      )
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
    );
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/core.mjs
var __classPrivateFieldSet = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var __classPrivateFieldGet = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug(
      "response",
      response.status,
      response.url,
      response.headers,
      response.body
    );
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  if (contentType == null ? void 0 : contentType.includes("application/json")) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) =>
      transform(await this.parseResponse(props))
    );
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([
      this.parse(),
      this.asResponse(),
    ]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    httpAgent,
    fetch: overridenFetch,
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch != null ? overridenFetch : fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts),
    };
  }
  validateHeaders(headers, customHeaders) {}
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(
      Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 }))
    );
  }
  getAPIList(path, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a4, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body)
      ? options.body.body
      : options.body
      ? JSON.stringify(options.body, null, 2)
      : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a4 = options.timeout) != null ? _a4 : this.timeout;
    const httpAgent =
      (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null
        ? _c
        : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (
      typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null
        ? void 0
        : _d.timeout) === "number" &&
      minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)
    ) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...(contentLength && { "Content-Length": contentLength }),
      ...this.defaultHeaders(options),
      ...headers,
    };
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach(
      (key) => reqHeaders[key] === null && delete reqHeaders[key]
    );
    const req = {
      method,
      ...(body && { body }),
      headers: reqHeaders,
      ...(httpAgent && { agent: httpAgent }),
      signal: (_f = options.signal) != null ? _f : null,
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  async prepareRequest(request4, { url, options }) {}
  parseHeaders(headers) {
    return !headers
      ? {}
      : Symbol.iterator in headers
      ? Object.fromEntries(Array.from(headers).map((header) => [...header]))
      : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a4, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining =
        (_a4 = options.maxRetries) != null ? _a4 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(
      url,
      req,
      timeout,
      controller
    ).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response
        .text()
        .catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(
        response.status,
        errJSON,
        errMessage,
        responseHeaders
      );
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page3, options) {
    const request4 = this.makeRequest(options, null);
    return new PagePromise(this, request4, Page3);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path)
      ? new URL(path)
      : new URL(
          this.baseURL +
            (this.baseURL.endsWith("/") && path.startsWith("/")
              ? path.slice(1)
              : path)
        );
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query)
      .filter(([_, value]) => typeof value !== "undefined")
      .map(([key, value]) => {
        if (
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean"
        ) {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new OpenAIError(
          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
        );
      })
      .join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal) signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient()
      .fetch.call(void 0, url, { signal: controller.signal, ...options })
      .finally(() => {
        clearTimeout(timeout);
      });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true") return true;
    if (shouldRetryHeader === "false") return false;
    if (response.status === 408) return true;
    if (response.status === 409) return true;
    if (response.status === 429) return true;
    if (response.status >= 500) return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a4;
    let timeoutMillis;
    const retryAfterHeader =
      responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader) {
      const timeoutSeconds = parseInt(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (
      !timeoutMillis ||
      !Number.isInteger(timeoutMillis) ||
      timeoutMillis <= 0 ||
      timeoutMillis > 60 * 1e3
    ) {
      const maxRetries =
        (_a4 = options.maxRetries) != null ? _a4 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(
        retriesRemaining,
        maxRetries
      );
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(
      initialRetryDelay * Math.pow(2, numRetries),
      maxRetryDelay
    );
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length) return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError(
        "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
      );
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [
        ...Object.entries(nextOptions.query || {}),
        ...nextInfo.url.searchParams.entries(),
      ];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(
      this,
      _AbstractPage_client,
      "f"
    ).requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[((_AbstractPage_client = /* @__PURE__ */ new WeakMap()),
  Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request4, Page3) {
    super(
      request4,
      async (props) =>
        new Page3(
          client,
          props.response,
          await defaultParseResponse(props),
          props.options
        )
    );
  }
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(headers.entries()), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    },
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryResponse: true,
};
var isRequestOptions = (obj) => {
  return (
    typeof obj === "object" &&
    obj !== null &&
    !isEmptyObj(obj) &&
    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))
  );
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version,
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version,
    };
  }
  if (
    Object.prototype.toString.call(
      typeof process !== "undefined" ? process : 0
    ) === "[object process]"
  ) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version,
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version,
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown",
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    {
      key: "safari",
      pattern:
        /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/,
    },
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32") return "x32";
  if (arch === "x86_64" || arch === "x64") return "x64";
  if (arch === "arm") return "arm";
  if (arch === "aarch64" || arch === "arm64") return "arm64";
  if (arch) return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios")) return "iOS";
  if (platform === "android") return "Android";
  if (platform === "darwin") return "MacOS";
  if (platform === "win32") return "Windows";
  if (platform === "freebsd") return "FreeBSD";
  if (platform === "openbsd") return "OpenBSD";
  if (platform === "linux") return "Linux";
  if (platform) return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null
    ? _platformHeaders
    : (_platformHeaders = getPlatformProperties());
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error) return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a4, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a4 = process.env) == null ? void 0 : _a4[env]) != null
      ? _b
      : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) == null ? void 0 : _c.get) == null
      ? void 0
      : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj) return true;
  for (const _k in obj) return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 3) | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    typeof window !== "undefined" &&
    typeof window.document !== "undefined" &&
    typeof navigator !== "undefined"
  );
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data;
  }
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info) return null;
    if ("params" in info) return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length) return null;
    return params;
  }
  nextPageInfo() {
    var _a4, _b;
    if (!((_a4 = this.data) == null ? void 0 : _a4.length)) {
      return null;
    }
    const next =
      (_b = this.data[this.data.length - 1]) == null ? void 0 : _b.id;
    if (!next) return null;
    return { params: { after: next } };
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a4;
    return this._client.post("/chat/completions", {
      body,
      ...options,
      stream: (_a4 = body.stream) != null ? _a4 : false,
    });
  }
};
(function (Completions8) {})(Completions || (Completions = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
(function (Chat6) {
  Chat6.Completions = Completions;
})(Chat || (Chat = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      __binaryResponse: true,
    });
  }
};
(function (Speech3) {})(Speech || (Speech = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post(
      "/audio/transcriptions",
      multipartFormRequestOptions({ body, ...options })
    );
  }
};
(function (Transcriptions4) {})(Transcriptions || (Transcriptions = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post(
      "/audio/translations",
      multipartFormRequestOptions({ body, ...options })
    );
  }
};
(function (Translations4) {})(Translations || (Translations = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
(function (Audio4) {
  Audio4.Transcriptions = Transcriptions;
  Audio4.Translations = Translations;
  Audio4.Speech = Speech;
})(Audio || (Audio = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/assistants/files.mjs
var Files = class extends APIResource {
  create(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}/files`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(assistantId, fileId, options) {
    return this._client.get(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(assistantId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(assistantId, {}, query);
    }
    return this._client.getAPIList(
      `/assistants/${assistantId}/files`,
      AssistantFilesPage,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
  del(assistantId, fileId, options) {
    return this._client.delete(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
var AssistantFilesPage = class extends CursorPage {};
(function (Files7) {
  Files7.AssistantFilesPage = AssistantFilesPage;
})(Files || (Files = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/assistants/assistants.mjs
var Assistants = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
var AssistantsPage = class extends CursorPage {};
(function (Assistants3) {
  Assistants3.AssistantsPage = AssistantsPage;
  Assistants3.Files = Files;
  Assistants3.AssistantFilesPage = AssistantFilesPage;
})(Assistants || (Assistants = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// ../../../../../../../../node_modules/langchain/node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldSet2 = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var __classPrivateFieldGet2 = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_connectedPromise;
var _AbstractChatCompletionRunner_resolveConnectedPromise;
var _AbstractChatCompletionRunner_rejectConnectedPromise;
var _AbstractChatCompletionRunner_endPromise;
var _AbstractChatCompletionRunner_resolveEndPromise;
var _AbstractChatCompletionRunner_rejectEndPromise;
var _AbstractChatCompletionRunner_listeners;
var _AbstractChatCompletionRunner_ended;
var _AbstractChatCompletionRunner_errored;
var _AbstractChatCompletionRunner_aborted;
var _AbstractChatCompletionRunner_catchingPromiseCreated;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_handleError;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class {
  constructor() {
    _AbstractChatCompletionRunner_instances.add(this);
    this.controller = new AbortController();
    _AbstractChatCompletionRunner_connectedPromise.set(this, void 0);
    _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {});
    _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {});
    _AbstractChatCompletionRunner_endPromise.set(this, void 0);
    _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {});
    _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {});
    _AbstractChatCompletionRunner_listeners.set(this, {});
    this._chatCompletions = [];
    this.messages = [];
    _AbstractChatCompletionRunner_ended.set(this, false);
    _AbstractChatCompletionRunner_errored.set(this, false);
    _AbstractChatCompletionRunner_aborted.set(this, false);
    _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);
    _AbstractChatCompletionRunner_handleError.set(this, (error) => {
      __classPrivateFieldSet2(
        this,
        _AbstractChatCompletionRunner_errored,
        true,
        "f"
      );
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet2(
          this,
          _AbstractChatCompletionRunner_aborted,
          true,
          "f"
        );
        return this._emit("abort", error);
      }
      if (error instanceof OpenAIError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const openAIError = new OpenAIError(error.message);
        openAIError.cause = error;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new OpenAIError(String(error)));
    });
    __classPrivateFieldSet2(
      this,
      _AbstractChatCompletionRunner_connectedPromise,
      new Promise((resolve, reject) => {
        __classPrivateFieldSet2(
          this,
          _AbstractChatCompletionRunner_resolveConnectedPromise,
          resolve,
          "f"
        );
        __classPrivateFieldSet2(
          this,
          _AbstractChatCompletionRunner_rejectConnectedPromise,
          reject,
          "f"
        );
      }),
      "f"
    );
    __classPrivateFieldSet2(
      this,
      _AbstractChatCompletionRunner_endPromise,
      new Promise((resolve, reject) => {
        __classPrivateFieldSet2(
          this,
          _AbstractChatCompletionRunner_resolveEndPromise,
          resolve,
          "f"
        );
        __classPrivateFieldSet2(
          this,
          _AbstractChatCompletionRunner_rejectEndPromise,
          reject,
          "f"
        );
      }),
      "f"
    );
    __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_connectedPromise,
      "f"
    ).catch(() => {});
    __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_endPromise,
      "f"
    ).catch(() => {});
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_handleError, "f"));
    }, 0);
  }
  _addChatCompletion(chatCompletion) {
    var _a4;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message =
      (_a4 = chatCompletion.choices[0]) == null ? void 0 : _a4.message;
    if (message) this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (
        (isFunctionMessage(message) || isToolMessage(message)) &&
        message.content
      ) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  _connected() {
    if (this.ended) return;
    __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_resolveConnectedPromise,
      "f"
    ).call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_ended,
      "f"
    );
  }
  get errored() {
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_errored,
      "f"
    );
  }
  get aborted() {
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_aborted,
      "f"
    );
  }
  abort() {
    this.controller.abort();
  }
  on(event, listener) {
    const listeners =
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_listeners,
        "f"
      )[event] ||
      (__classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_listeners,
        "f"
      )[event] = []);
    listeners.push({ listener });
    return this;
  }
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_listeners,
      "f"
    )[event];
    if (!listeners) return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0) listeners.splice(index, 1);
    return this;
  }
  once(event, listener) {
    const listeners =
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_listeners,
        "f"
      )[event] ||
      (__classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_listeners,
        "f"
      )[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(
        this,
        _AbstractChatCompletionRunner_catchingPromiseCreated,
        true,
        "f"
      );
      if (event !== "error") this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(
      this,
      _AbstractChatCompletionRunner_catchingPromiseCreated,
      true,
      "f"
    );
    await __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_endPromise,
      "f"
    );
  }
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalContent
    ).call(this);
  }
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalMessage
    ).call(this);
  }
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCall
    ).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCallResult
    ).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_calculateTotalUsage
    ).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet2(
        this,
        _AbstractChatCompletionRunner_ended,
        true,
        "f"
      );
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_resolveEndPromise,
        "f"
      ).call(this);
    }
    const listeners = __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_listeners,
      "f"
    )[event];
    if (listeners) {
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_listeners,
        "f"
      )[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (
        !__classPrivateFieldGet2(
          this,
          _AbstractChatCompletionRunner_catchingPromiseCreated,
          "f"
        ) &&
        !(listeners == null ? void 0 : listeners.length)
      ) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_rejectConnectedPromise,
        "f"
      ).call(this, error);
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_rejectEndPromise,
        "f"
      ).call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (
        !__classPrivateFieldGet2(
          this,
          _AbstractChatCompletionRunner_catchingPromiseCreated,
          "f"
        ) &&
        !(listeners == null ? void 0 : listeners.length)
      ) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_rejectConnectedPromise,
        "f"
      ).call(this, error);
      __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_rejectEndPromise,
        "f"
      ).call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion) this._emit("finalChatCompletion", completion);
    const finalMessage = this.messages[this.messages.length - 1];
    if (finalMessage) this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalContent
    ).call(this);
    if (finalContent) this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCall
    ).call(this);
    if (finalFunctionCall) this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCallResult
    ).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit(
        "totalUsage",
        __classPrivateFieldGet2(
          this,
          _AbstractChatCompletionRunner_instances,
          "m",
          _AbstractChatCompletionRunner_calculateTotalUsage
        ).call(this)
      );
    }
  }
  async _createChatCompletion(completions, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted) this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(
      this,
      _AbstractChatCompletionRunner_instances,
      "m",
      _AbstractChatCompletionRunner_validateParams
    ).call(this, params);
    const chatCompletion = await completions.create(
      { ...params, stream: false },
      { ...options, signal: this.controller.signal }
    );
    this._connected();
    return this._addChatCompletion(chatCompletion);
  }
  async _runChatCompletion(completions, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(completions, params, options);
  }
  async _runFunctions(completions, params, options) {
    var _a4;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall =
      typeof function_call !== "string" &&
      (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description,
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(
        completions,
        {
          ...restParams,
          function_call,
          functions,
          messages: [...this.messages],
        },
        options
      );
      const message =
        (_a4 = chatCompletion.choices[0]) == null ? void 0 : _a4.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call) return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(
          name
        )}. Available options are: ${functions
          .map((f) => JSON.stringify(f.name))
          .join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(
          name
        )}. ${JSON.stringify(
          singleFunctionToCall
        )} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error),
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_instances,
        "m",
        _AbstractChatCompletionRunner_stringifyFunctionCallResult
      ).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall) return;
    }
  }
  async _runTools(completions, params, options) {
    var _a4, _b;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall =
      typeof tool_choice !== "string" &&
      ((_a4 = tool_choice == null ? void 0 : tool_choice.function) == null
        ? void 0
        : _a4.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.tools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] =
          f.function;
      }
    }
    const tools =
      "tools" in params
        ? params.tools.map((t) =>
            t.type === "function"
              ? {
                  type: "function",
                  function: {
                    name: t.function.name || t.function.function.name,
                    parameters: t.function.parameters,
                    description: t.function.description,
                  },
                }
              : t
          )
        : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(
        completions,
        {
          ...restParams,
          tool_choice,
          tools,
          messages: [...this.messages],
        },
        options
      );
      const message =
        (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls) return;
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function") continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(
            name
          )}. Available options are: ${tools
            .map((f) => JSON.stringify(f.function.name))
            .join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(
            name
          )}. ${JSON.stringify(
            singleFunctionToCall
          )} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn)
            ? await fn.parse(args)
            : args;
        } catch (error) {
          const content2 =
            error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet2(
          this,
          _AbstractChatCompletionRunner_instances,
          "m",
          _AbstractChatCompletionRunner_stringifyFunctionCallResult
        ).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) return;
      }
    }
  }
};
(_AbstractChatCompletionRunner_connectedPromise =
  /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_resolveConnectedPromise =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_rejectConnectedPromise =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_endPromise = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_resolveEndPromise =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_rejectEndPromise =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_listeners = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_ended = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_errored = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_aborted = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_catchingPromiseCreated =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_handleError = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet()),
  (_AbstractChatCompletionRunner_getFinalContent =
    function _AbstractChatCompletionRunner_getFinalContent2() {
      return __classPrivateFieldGet2(
        this,
        _AbstractChatCompletionRunner_instances,
        "m",
        _AbstractChatCompletionRunner_getFinalMessage
      ).call(this).content;
    }),
  (_AbstractChatCompletionRunner_getFinalMessage =
    function _AbstractChatCompletionRunner_getFinalMessage2() {
      let i = this.messages.length;
      while (i-- > 0) {
        const message = this.messages[i];
        if (isAssistantMessage(message)) {
          return message;
        }
      }
      throw new OpenAIError(
        "stream ended without producing a ChatCompletionMessage with role=assistant"
      );
    }),
  (_AbstractChatCompletionRunner_getFinalFunctionCall =
    function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if (
          isAssistantMessage(message) &&
          (message == null ? void 0 : message.function_call)
        ) {
          return message.function_call;
        }
      }
      return;
    }),
  (_AbstractChatCompletionRunner_getFinalFunctionCallResult =
    function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if (isFunctionMessage(message) && message.content != null) {
          return message.content;
        }
      }
      return;
    }),
  (_AbstractChatCompletionRunner_calculateTotalUsage =
    function _AbstractChatCompletionRunner_calculateTotalUsage2() {
      const total = {
        completion_tokens: 0,
        prompt_tokens: 0,
        total_tokens: 0,
      };
      for (const { usage } of this._chatCompletions) {
        if (usage) {
          total.completion_tokens += usage.completion_tokens;
          total.prompt_tokens += usage.prompt_tokens;
          total.total_tokens += usage.total_tokens;
        }
      }
      return total;
    }),
  (_AbstractChatCompletionRunner_validateParams =
    function _AbstractChatCompletionRunner_validateParams2(params) {
      if (params.n != null && params.n > 1) {
        throw new OpenAIError(
          "ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly."
        );
      }
    }),
  (_AbstractChatCompletionRunner_stringifyFunctionCallResult =
    function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(
      rawContent
    ) {
      return typeof rawContent === "string"
        ? rawContent
        : rawContent === void 0
        ? "undefined"
        : JSON.stringify(rawContent);
    });

// ../../../../../../../../node_modules/langchain/node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class extends AbstractChatCompletionRunner {
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionRunner();
    runner._run(() => runner._runFunctions(completions, params, options));
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionRunner();
    runner._run(() => runner._runTools(completions, params, options));
    return runner;
  }
  _addMessage(message) {
    super._addMessage(message);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldGet3 = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var __classPrivateFieldSet3 = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class extends AbstractChatCompletionRunner {
  constructor() {
    super(...arguments);
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet3(
      this,
      _ChatCompletionStream_currentChatCompletionSnapshot,
      "f"
    );
  }
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(completions, params, options) {
    const runner = new ChatCompletionStream();
    runner._run(() =>
      runner._runChatCompletion(
        completions,
        { ...params, stream: true },
        {
          ...options,
          headers: {
            ...(options == null ? void 0 : options.headers),
            "X-Stainless-Helper-Method": "stream",
          },
        }
      )
    );
    return runner;
  }
  async _createChatCompletion(completions, params, options) {
    var _a4;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted) this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(
      this,
      _ChatCompletionStream_instances,
      "m",
      _ChatCompletionStream_beginRequest
    ).call(this);
    const stream = await completions.create(
      { ...params, stream: true },
      { ...options, signal: this.controller.signal }
    );
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet3(
        this,
        _ChatCompletionStream_instances,
        "m",
        _ChatCompletionStream_addChunk
      ).call(this, chunk);
    }
    if ((_a4 = stream.controller.signal) == null ? void 0 : _a4.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(
      __classPrivateFieldGet3(
        this,
        _ChatCompletionStream_instances,
        "m",
        _ChatCompletionStream_endRequest
      ).call(this)
    );
  }
  async _fromReadableStream(readableStream, options) {
    var _a4;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted) this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(
      this,
      _ChatCompletionStream_instances,
      "m",
      _ChatCompletionStream_beginRequest
    ).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(
          __classPrivateFieldGet3(
            this,
            _ChatCompletionStream_instances,
            "m",
            _ChatCompletionStream_endRequest
          ).call(this)
        );
      }
      __classPrivateFieldGet3(
        this,
        _ChatCompletionStream_instances,
        "m",
        _ChatCompletionStream_addChunk
      ).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a4 = stream.controller.signal) == null ? void 0 : _a4.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(
      __classPrivateFieldGet3(
        this,
        _ChatCompletionStream_instances,
        "m",
        _ChatCompletionStream_endRequest
      ).call(this)
    );
  }
  [((_ChatCompletionStream_currentChatCompletionSnapshot =
    /* @__PURE__ */ new WeakMap()),
  (_ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet()),
  (_ChatCompletionStream_beginRequest =
    function _ChatCompletionStream_beginRequest3() {
      if (this.ended) return;
      __classPrivateFieldSet3(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot,
        void 0,
        "f"
      );
    }),
  (_ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk3(
    chunk
  ) {
    var _a4, _b, _c;
    if (this.ended) return;
    const completion = __classPrivateFieldGet3(
      this,
      _ChatCompletionStream_instances,
      "m",
      _ChatCompletionStream_accumulateChatCompletion
    ).call(this, chunk);
    this._emit("chunk", chunk, completion);
    const delta =
      (_b = (_a4 = chunk.choices[0]) == null ? void 0 : _a4.delta) == null
        ? void 0
        : _b.content;
    const snapshot = (_c = completion.choices[0]) == null ? void 0 : _c.message;
    if (
      delta != null &&
      (snapshot == null ? void 0 : snapshot.role) === "assistant" &&
      (snapshot == null ? void 0 : snapshot.content)
    ) {
      this._emit("content", delta, snapshot.content);
    }
  }),
  (_ChatCompletionStream_endRequest =
    function _ChatCompletionStream_endRequest3() {
      if (this.ended) {
        throw new OpenAIError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet3(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot,
        "f"
      );
      if (!snapshot) {
        throw new OpenAIError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet3(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot,
        void 0,
        "f"
      );
      return finalizeChatCompletion(snapshot);
    }),
  (_ChatCompletionStream_accumulateChatCompletion =
    function _ChatCompletionStream_accumulateChatCompletion3(chunk) {
      var _a5, _b2, _c;
      var _a4, _b;
      let snapshot = __classPrivateFieldGet3(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot,
        "f"
      );
      const { choices, ...rest } = chunk;
      if (!snapshot) {
        snapshot = __classPrivateFieldSet3(
          this,
          _ChatCompletionStream_currentChatCompletionSnapshot,
          {
            ...rest,
            choices: [],
          },
          "f"
        );
      } else {
        Object.assign(snapshot, rest);
      }
      for (const { delta, finish_reason, index, ...other } of chunk.choices) {
        let choice = snapshot.choices[index];
        if (!choice) {
          snapshot.choices[index] = {
            finish_reason,
            index,
            message: delta,
            ...other,
          };
          continue;
        }
        if (finish_reason) choice.finish_reason = finish_reason;
        Object.assign(choice, other);
        if (!delta) continue;
        const { content, function_call, role, tool_calls } = delta;
        if (content)
          choice.message.content = (choice.message.content || "") + content;
        if (role) choice.message.role = role;
        if (function_call) {
          if (!choice.message.function_call) {
            choice.message.function_call = function_call;
          } else {
            if (function_call.name)
              choice.message.function_call.name = function_call.name;
            if (function_call.arguments) {
              (_a5 = (_a4 = choice.message.function_call).arguments) != null
                ? _a5
                : (_a4.arguments = "");
              choice.message.function_call.arguments += function_call.arguments;
            }
          }
        }
        if (tool_calls) {
          if (!choice.message.tool_calls) choice.message.tool_calls = [];
          for (const { index: index2, id, type, function: fn } of tool_calls) {
            const tool_call =
              (_b2 = (_b = choice.message.tool_calls)[index2]) != null
                ? _b2
                : (_b[index2] = {});
            if (id) tool_call.id = id;
            if (type) tool_call.type = type;
            if (fn)
              (_c = tool_call.function) != null
                ? _c
                : (tool_call.function = { arguments: "" });
            if (fn == null ? void 0 : fn.name)
              tool_call.function.name = fn.name;
            if (fn == null ? void 0 : fn.arguments)
              tool_call.function.arguments += fn.arguments;
          }
        }
      }
      return snapshot;
    }),
  Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader(void 0);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve) => readQueue.push(resolve)).then(
            (chunk2) =>
              chunk2
                ? { value: chunk2, done: false }
                : { value: void 0, done: true }
          );
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
    };
  }
  toReadableStream() {
    const stream = new Stream(
      this[Symbol.asyncIterator].bind(this),
      this.controller
    );
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot) {
  const { id, choices, created, model } = snapshot;
  return {
    id,
    choices: choices.map(({ message, finish_reason, index }) => {
      if (!finish_reason)
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      const { content = null, function_call, tool_calls } = message;
      const role = message.role;
      if (!role) throw new OpenAIError(`missing role for choice ${index}`);
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null)
          throw new OpenAIError(
            `missing function_call.arguments for choice ${index}`
          );
        if (!name)
          throw new OpenAIError(
            `missing function_call.name for choice ${index}`
          );
        return {
          message: { content, function_call: { arguments: args, name }, role },
          finish_reason,
          index,
        };
      }
      if (tool_calls) {
        return {
          index,
          finish_reason,
          message: {
            role,
            content,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2 } = tool_call;
              const { arguments: args, name } = fn || {};
              if (id2 == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              if (type == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              if (name == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              if (args == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              return { id: id2, type, function: { name, arguments: args } };
            }),
          },
        };
      }
      return { message: { content, role }, finish_reason, index };
    }),
    created,
    model,
    object: "chat.completion",
  };
}
function str(x) {
  return JSON.stringify(x);
}

// ../../../../../../../../node_modules/langchain/node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner();
    runner._run(() =>
      runner._runFunctions(completions, params, {
        ...options,
        headers: {
          ...(options == null ? void 0 : options.headers),
          "X-Stainless-Helper-Method": "runFunctions",
        },
      })
    );
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner();
    runner._run(() =>
      runner._runTools(completions, params, {
        ...options,
        headers: {
          ...(options == null ? void 0 : options.headers),
          "X-Stainless-Helper-Method": "runTools",
        },
      })
    );
    return runner;
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(
        this._client.chat.completions,
        body,
        options
      );
    }
    return ChatCompletionRunner.runFunctions(
      this._client.chat.completions,
      body,
      options
    );
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(
        this._client.chat.completions,
        body,
        options
      );
    }
    return ChatCompletionRunner.runTools(
      this._client.chat.completions,
      body,
      options
    );
  }
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(
      this._client.chat.completions,
      body,
      options
    );
  }
};

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function (Chat6) {
  Chat6.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/threads/messages/files.mjs
var Files2 = class extends APIResource {
  retrieve(threadId, messageId, fileId, options) {
    return this._client.get(
      `/threads/${threadId}/messages/${messageId}/files/${fileId}`,
      {
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
  list(threadId, messageId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, messageId, {}, query);
    }
    return this._client.getAPIList(
      `/threads/${threadId}/messages/${messageId}/files`,
      MessageFilesPage,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var MessageFilesPage = class extends CursorPage {};
(function (Files7) {
  Files7.MessageFilesPage = MessageFilesPage;
})(Files2 || (Files2 = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/threads/messages/messages.mjs
var Messages = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files2(this._client);
  }
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(
      `/threads/${threadId}/messages`,
      ThreadMessagesPage,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var ThreadMessagesPage = class extends CursorPage {};
(function (Messages3) {
  Messages3.ThreadMessagesPage = ThreadMessagesPage;
  Messages3.Files = Files2;
  Messages3.MessageFilesPage = MessageFilesPage;
})(Messages || (Messages = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, options) {
    return this._client.get(
      `/threads/${threadId}/runs/${runId}/steps/${stepId}`,
      {
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(
      `/threads/${threadId}/runs/${runId}/steps`,
      RunStepsPage,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var RunStepsPage = class extends CursorPage {};
(function (Steps3) {
  Steps3.RunStepsPage = RunStepsPage;
})(Steps || (Steps = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/runs`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(
      `/threads/${threadId}/runs/${runId}/submit_tool_outputs`,
      {
        body,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var RunsPage = class extends CursorPage {};
(function (Runs3) {
  Runs3.RunsPage = RunsPage;
  Runs3.Steps = Steps;
  Runs3.RunStepsPage = RunStepsPage;
})(Runs || (Runs = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
(function (Threads3) {
  Threads3.Runs = Runs;
  Threads3.RunsPage = RunsPage;
  Threads3.Messages = Messages;
  Threads3.ThreadMessagesPage = ThreadMessagesPage;
})(Threads || (Threads = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
(function (Beta3) {
  Beta3.Chat = Chat2;
  Beta3.Assistants = Assistants;
  Beta3.AssistantsPage = AssistantsPage;
  Beta3.Threads = Threads;
})(Beta || (Beta = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    var _a4;
    return this._client.post("/completions", {
      body,
      ...options,
      stream: (_a4 = body.stream) != null ? _a4 : false,
    });
  }
};
(function (Completions8) {})(Completions3 || (Completions3 = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};
(function (Embeddings4) {})(Embeddings || (Embeddings = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  create(body, options) {
    return this._client.post("/edits", { body, ...options });
  }
};
(function (Edits3) {})(Edits || (Edits = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/files.mjs
var Files3 = class extends APIResource {
  create(body, options) {
    return this._client.post(
      "/files",
      multipartFormRequestOptions({ body, ...options })
    );
  }
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, {
      query,
      ...options,
    });
  }
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      __binaryResponse: true,
    });
  }
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: {
        Accept: "application/json",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  async waitForProcessing(
    id,
    { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}
  ) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set([
      "processed",
      "error",
      "deleted",
    ]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends Page {};
(function (Files7) {
  Files7.FileObjectsPage = FileObjectsPage;
})(Files3 || (Files3 = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  create(body, options) {
    return this._client.post("/fine-tunes", { body, ...options });
  }
  retrieve(fineTuneId, options) {
    return this._client.get(`/fine-tunes/${fineTuneId}`, options);
  }
  list(options) {
    return this._client.getAPIList("/fine-tunes", FineTunesPage, options);
  }
  cancel(fineTuneId, options) {
    return this._client.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a4;
    return this._client.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream:
        (_a4 = query == null ? void 0 : query.stream) != null ? _a4 : false,
    });
  }
};
var FineTunesPage = class extends Page {};
(function (FineTunes3) {
  FineTunes3.FineTunesPage = FineTunesPage;
})(FineTunes || (FineTunes = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, {
      query,
      ...options,
    });
  }
  cancel(fineTuningJobId, options) {
    return this._client.post(
      `/fine_tuning/jobs/${fineTuningJobId}/cancel`,
      options
    );
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(
      `/fine_tuning/jobs/${fineTuningJobId}/events`,
      FineTuningJobEventsPage,
      {
        query,
        ...options,
      }
    );
  }
};
var FineTuningJobsPage = class extends CursorPage {};
var FineTuningJobEventsPage = class extends CursorPage {};
(function (Jobs3) {
  Jobs3.FineTuningJobsPage = FineTuningJobsPage;
  Jobs3.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(Jobs || (Jobs = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
};
(function (FineTuning3) {
  FineTuning3.Jobs = Jobs;
  FineTuning3.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning3.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  createVariation(body, options) {
    return this._client.post(
      "/images/variations",
      multipartFormRequestOptions({ body, ...options })
    );
  }
  edit(body, options) {
    return this._client.post(
      "/images/edits",
      multipartFormRequestOptions({ body, ...options })
    );
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};
(function (Images3) {})(Images || (Images = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {};
(function (Models4) {
  Models4.ModelsPage = ModelsPage;
})(Models || (Models = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};
(function (Moderations3) {})(Moderations || (Moderations = {}));

// ../../../../../../../../node_modules/langchain/node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  constructor({
    apiKey = readEnv("OPENAI_API_KEY"),
    organization = ((_a4) =>
      (_a4 = readEnv("OPENAI_ORG_ID")) != null ? _a4 : null)(),
    ...opts
  } = {}) {
    var _a5, _b;
    if (apiKey === void 0) {
      throw new OpenAIError(
        "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' })."
      );
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: (_a5 = opts.baseURL) != null ? _a5 : `https://api.openai.com/v1`,
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError(
        "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
      );
    }
    super({
      baseURL: options.baseURL,
      timeout: (_b = options.timeout) != null ? _b : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch,
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files3(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this.beta = new Beta(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders,
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var {
  OpenAIError: OpenAIError2,
  APIError: APIError2,
  APIConnectionError: APIConnectionError2,
  APIConnectionTimeoutError: APIConnectionTimeoutError2,
  APIUserAbortError: APIUserAbortError2,
  NotFoundError: NotFoundError2,
  ConflictError: ConflictError2,
  RateLimitError: RateLimitError2,
  BadRequestError: BadRequestError2,
  AuthenticationError: AuthenticationError2,
  InternalServerError: InternalServerError2,
  PermissionDeniedError: PermissionDeniedError2,
  UnprocessableEntityError: UnprocessableEntityError2,
} = error_exports;
(function (OpenAI3) {
  OpenAI3.toFile = toFile;
  OpenAI3.fileFromPath = fileFromPath;
  OpenAI3.Page = Page;
  OpenAI3.CursorPage = CursorPage;
  OpenAI3.Completions = Completions3;
  OpenAI3.Chat = Chat;
  OpenAI3.Edits = Edits;
  OpenAI3.Embeddings = Embeddings;
  OpenAI3.Files = Files3;
  OpenAI3.FileObjectsPage = FileObjectsPage;
  OpenAI3.Images = Images;
  OpenAI3.Audio = Audio;
  OpenAI3.Moderations = Moderations;
  OpenAI3.Models = Models;
  OpenAI3.ModelsPage = ModelsPage;
  OpenAI3.FineTuning = FineTuning;
  OpenAI3.FineTunes = FineTunes;
  OpenAI3.FineTunesPage = FineTunesPage;
  OpenAI3.Beta = Beta;
})(OpenAI || (OpenAI = {}));

// ../../../../../../../../node_modules/langchain/dist/util/chunk.js
var chunkArray = (arr, chunkSize) =>
  arr.reduce((chunks, elem, index) => {
    const chunkIndex = Math.floor(index / chunkSize);
    const chunk = chunks[chunkIndex] || [];
    chunks[chunkIndex] = chunk.concat([elem]);
    return chunks;
  }, []);

// ../../../../../../../../node_modules/langchain/dist/embeddings/base.js
var Embeddings2 = class {
  constructor(params) {
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    this.caller = new AsyncCaller2(params != null ? params : {});
  }
};

// ../../../../../../../../node_modules/langchain/dist/util/azure.js
function getEndpoint(config) {
  const {
    azureOpenAIApiDeploymentName,
    azureOpenAIApiInstanceName,
    azureOpenAIApiKey,
    azureOpenAIBasePath,
    baseURL,
  } = config;
  if (
    azureOpenAIApiKey &&
    azureOpenAIBasePath &&
    azureOpenAIApiDeploymentName
  ) {
    return `${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`;
  }
  if (azureOpenAIApiKey) {
    if (!azureOpenAIApiInstanceName) {
      throw new Error(
        "azureOpenAIApiInstanceName is required when using azureOpenAIApiKey"
      );
    }
    if (!azureOpenAIApiDeploymentName) {
      throw new Error(
        "azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey"
      );
    }
    return `https://${azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${azureOpenAIApiDeploymentName}`;
  }
  return baseURL;
}

// ../../../../../../../../node_modules/langchain/dist/util/openai.js
function wrapOpenAIClientError(e) {
  let error;
  if (e.constructor.name === APIConnectionTimeoutError2.name) {
    error = new Error(e.message);
    error.name = "TimeoutError";
  } else if (e.constructor.name === APIUserAbortError2.name) {
    error = new Error(e.message);
    error.name = "AbortError";
  } else {
    error = e;
  }
  return error;
}

// ../../../../../../../../node_modules/langchain/dist/embeddings/openai.js
var OpenAIEmbeddings = class extends Embeddings2 {
  constructor(fields, configuration) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    const fieldsWithDefaults = { maxConcurrency: 2, ...fields };
    super(fieldsWithDefaults);
    Object.defineProperty(this, "modelName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "text-embedding-ada-002",
    });
    Object.defineProperty(this, "batchSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 512,
    });
    Object.defineProperty(this, "stripNewLines", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true,
    });
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "azureOpenAIApiVersion", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "azureOpenAIApiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "azureOpenAIApiInstanceName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "azureOpenAIApiDeploymentName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "azureOpenAIBasePath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "organization", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    Object.defineProperty(this, "clientConfig", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0,
    });
    let apiKey =
      (_a4 =
        fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.openAIApiKey) != null
        ? _a4
        : getEnvironmentVariable2("OPENAI_API_KEY");
    const azureApiKey =
      (_b =
        fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.azureOpenAIApiKey) != null
        ? _b
        : getEnvironmentVariable2("AZURE_OPENAI_API_KEY");
    if (!azureApiKey && !apiKey) {
      throw new Error("OpenAI or Azure OpenAI API key not found");
    }
    const azureApiInstanceName =
      (_c =
        fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.azureOpenAIApiInstanceName) != null
        ? _c
        : getEnvironmentVariable2("AZURE_OPENAI_API_INSTANCE_NAME");
    const azureApiDeploymentName =
      (_d =
        (fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.azureOpenAIApiEmbeddingsDeploymentName) ||
        (fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.azureOpenAIApiDeploymentName)) != null
        ? _d
        : getEnvironmentVariable2(
            "AZURE_OPENAI_API_EMBEDDINGS_DEPLOYMENT_NAME"
          ) || getEnvironmentVariable2("AZURE_OPENAI_API_DEPLOYMENT_NAME");
    const azureApiVersion =
      (_e =
        fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.azureOpenAIApiVersion) != null
        ? _e
        : getEnvironmentVariable2("AZURE_OPENAI_API_VERSION");
    this.azureOpenAIBasePath =
      (_f =
        fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.azureOpenAIBasePath) != null
        ? _f
        : getEnvironmentVariable2("AZURE_OPENAI_BASE_PATH");
    this.organization =
      (_h =
        (_g =
          fieldsWithDefaults == null
            ? void 0
            : fieldsWithDefaults.configuration) == null
          ? void 0
          : _g.organization) != null
        ? _h
        : getEnvironmentVariable2("OPENAI_ORGANIZATION");
    this.modelName =
      (_i =
        fieldsWithDefaults == null ? void 0 : fieldsWithDefaults.modelName) !=
      null
        ? _i
        : this.modelName;
    this.batchSize =
      (_j =
        fieldsWithDefaults == null ? void 0 : fieldsWithDefaults.batchSize) !=
      null
        ? _j
        : azureApiKey
        ? 1
        : this.batchSize;
    this.stripNewLines =
      (_k =
        fieldsWithDefaults == null
          ? void 0
          : fieldsWithDefaults.stripNewLines) != null
        ? _k
        : this.stripNewLines;
    this.timeout =
      fieldsWithDefaults == null ? void 0 : fieldsWithDefaults.timeout;
    this.azureOpenAIApiVersion = azureApiVersion;
    this.azureOpenAIApiKey = azureApiKey;
    this.azureOpenAIApiInstanceName = azureApiInstanceName;
    this.azureOpenAIApiDeploymentName = azureApiDeploymentName;
    if (this.azureOpenAIApiKey) {
      if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath) {
        throw new Error("Azure OpenAI API instance name not found");
      }
      if (!this.azureOpenAIApiDeploymentName) {
        throw new Error("Azure OpenAI API deployment name not found");
      }
      if (!this.azureOpenAIApiVersion) {
        throw new Error("Azure OpenAI API version not found");
      }
      apiKey = apiKey != null ? apiKey : "";
    }
    this.clientConfig = {
      apiKey,
      organization: this.organization,
      baseURL: configuration == null ? void 0 : configuration.basePath,
      dangerouslyAllowBrowser: true,
      defaultHeaders:
        (_l = configuration == null ? void 0 : configuration.baseOptions) ==
        null
          ? void 0
          : _l.headers,
      defaultQuery:
        (_m = configuration == null ? void 0 : configuration.baseOptions) ==
        null
          ? void 0
          : _m.params,
      ...configuration,
      ...(fields == null ? void 0 : fields.configuration),
    };
  }
  async embedDocuments(texts) {
    const batches = chunkArray(
      this.stripNewLines ? texts.map((t) => t.replace(/\n/g, " ")) : texts,
      this.batchSize
    );
    const batchRequests = batches.map((batch) =>
      this.embeddingWithRetry({
        model: this.modelName,
        input: batch,
      })
    );
    const batchResponses = await Promise.all(batchRequests);
    const embeddings = [];
    for (let i = 0; i < batchResponses.length; i += 1) {
      const batch = batches[i];
      const { data: batchResponse } = batchResponses[i];
      for (let j = 0; j < batch.length; j += 1) {
        embeddings.push(batchResponse[j].embedding);
      }
    }
    return embeddings;
  }
  async embedQuery(text) {
    const { data } = await this.embeddingWithRetry({
      model: this.modelName,
      input: this.stripNewLines ? text.replace(/\n/g, " ") : text,
    });
    return data[0].embedding;
  }
  async embeddingWithRetry(request4) {
    if (!this.client) {
      const openAIEndpointConfig = {
        azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,
        azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,
        azureOpenAIApiKey: this.azureOpenAIApiKey,
        azureOpenAIBasePath: this.azureOpenAIBasePath,
        baseURL: this.clientConfig.baseURL,
      };
      const endpoint = getEndpoint(openAIEndpointConfig);
      const params = {
        ...this.clientConfig,
        baseURL: endpoint,
        timeout: this.timeout,
        maxRetries: 0,
      };
      if (!params.baseURL) {
        delete params.baseURL;
      }
      this.client = new OpenAI(params);
    }
    const requestOptions = {};
    if (this.azureOpenAIApiKey) {
      requestOptions.headers = {
        "api-key": this.azureOpenAIApiKey,
        ...requestOptions.headers,
      };
      requestOptions.query = {
        "api-version": this.azureOpenAIApiVersion,
        ...requestOptions.query,
      };
    }
    return this.caller.call(async () => {
      try {
        const res = await this.client.embeddings.create(
          request4,
          requestOptions
        );
        return res;
      } catch (e) {
        const error = wrapOpenAIClientError(e);
        throw error;
      }
    });
  }
};

// src/utils.ts
var import_obsidian = require("obsidian");

// node_modules/openai/version.mjs
var VERSION2 = "4.20.0";

// node_modules/openai/_shims/registry.mjs
var auto2 = false;
var kind2 = void 0;
var fetch3 = void 0;
var Request3 = void 0;
var Response3 = void 0;
var Headers3 = void 0;
var FormData3 = void 0;
var Blob3 = void 0;
var File3 = void 0;
var ReadableStream3 = void 0;
var getMultipartRequestOptions2 = void 0;
var getDefaultAgent2 = void 0;
var fileFromPath2 = void 0;
var isFsReadStream2 = void 0;
function setShims2(shims, options = { auto: false }) {
  if (auto2) {
    throw new Error(
      `you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`
    );
  }
  if (kind2) {
    throw new Error(
      `can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind2}'\``
    );
  }
  auto2 = options.auto;
  kind2 = shims.kind;
  fetch3 = shims.fetch;
  Request3 = shims.Request;
  Response3 = shims.Response;
  Headers3 = shims.Headers;
  FormData3 = shims.FormData;
  Blob3 = shims.Blob;
  File3 = shims.File;
  ReadableStream3 = shims.ReadableStream;
  getMultipartRequestOptions2 = shims.getMultipartRequestOptions;
  getDefaultAgent2 = shims.getDefaultAgent;
  fileFromPath2 = shims.fileFromPath;
  isFsReadStream2 = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody2 = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime2({ manuallyImported } = {}) {
  const recommendation = manuallyImported
    ? `You may need to use polyfills`
    : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(
      `this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`
    );
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData:
      typeof FormData !== "undefined"
        ? FormData
        : class FormData {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`
              );
            }
          },
    Blob:
      typeof Blob !== "undefined"
        ? Blob
        : class Blob {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`
              );
            }
          },
    File:
      typeof File !== "undefined"
        ? File
        : class File {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`
              );
            }
          },
    ReadableStream:
      typeof ReadableStream !== "undefined"
        ? ReadableStream
        : class ReadableStream {
            constructor() {
              throw new Error(
                `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`
              );
            }
          },
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody2(form),
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error(
        "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads"
      );
    },
    isFsReadStream: (value) => false,
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind2) setShims2(getRuntime2(), { auto: true });

// node_modules/openai/error.mjs
var error_exports2 = {};
__export(error_exports2, {
  APIConnectionError: () => APIConnectionError3,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError3,
  APIError: () => APIError3,
  APIUserAbortError: () => APIUserAbortError3,
  AuthenticationError: () => AuthenticationError3,
  BadRequestError: () => BadRequestError3,
  ConflictError: () => ConflictError3,
  InternalServerError: () => InternalServerError3,
  NotFoundError: () => NotFoundError3,
  OpenAIError: () => OpenAIError3,
  PermissionDeniedError: () => PermissionDeniedError3,
  RateLimitError: () => RateLimitError3,
  UnprocessableEntityError: () => UnprocessableEntityError3,
});
var OpenAIError3 = class extends Error {};
var APIError3 = class extends OpenAIError3 {
  constructor(status, error, message, headers) {
    super(`${APIError3.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message)
      ? typeof error.message === "string"
        ? error.message
        : JSON.stringify(error.message)
      : error
      ? JSON.stringify(error)
      : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError3({ cause: castToError2(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError3(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError3(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError3(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError3(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError3(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError3(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError3(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError3(status, error, message, headers);
    }
    return new APIError3(status, error, message, headers);
  }
};
var APIUserAbortError3 = class extends APIError3 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError3 = class extends APIError3 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause) this.cause = cause;
  }
};
var APIConnectionTimeoutError3 = class extends APIConnectionError3 {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError3 = class extends APIError3 {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError3 = class extends APIError3 {};

// node_modules/openai/streaming.mjs
var Stream2 = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder2();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new OpenAIError3(
          `Attempted to iterate over a response with no body`
        );
      }
      const lineDecoder = new LineDecoder2();
      const iter = readableStreamAsyncIterable2(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse) yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse) yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
        );
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done) continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError3(void 0, data.error, void 0, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") return;
        throw e;
      } finally {
        if (!done) controller.abort();
      }
    }
    return new Stream2(iterator, controller);
  }
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder2();
      const iter = readableStreamAsyncIterable2(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
        );
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done) continue;
          if (line) yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") return;
        throw e;
      } finally {
        if (!done) controller.abort();
      }
    }
    return new Stream2(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue2) => {
      return {
        next: () => {
          if (queue2.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        },
      };
    };
    return [
      new Stream2(() => teeIterator(left), this.controller),
      new Stream2(() => teeIterator(right), this.controller),
    ];
  }
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream3({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done) return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a4;
        await ((_a4 = iter.return) == null ? void 0 : _a4.call(iter));
      },
    });
  }
};
var SSEDecoder2 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length) return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks,
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition2(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder2 = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder2.NEWLINE_CHARS.has(
      text[text.length - 1] || ""
    );
    let lines = text.split(LineDecoder2.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a4;
    if (bytes == null) return "";
    if (typeof bytes === "string") return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError3(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
      );
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a4 = this.textDecoder) != null
          ? _a4
          : (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError3(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
      );
    }
    throw new OpenAIError3(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
    );
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder2.NEWLINE_CHARS = /* @__PURE__ */ new Set([
  "\n",
  "\r",
  "\v",
  "\f",
  "",
  "",
  "",
  "\x85",
  "\u2028",
  "\u2029",
]);
LineDecoder2.NEWLINE_REGEXP =
  /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition2(str3, delimiter) {
  const index = str3.indexOf(delimiter);
  if (index !== -1) {
    return [
      str3.substring(0, index),
      delimiter,
      str3.substring(index + delimiter.length),
    ];
  }
  return [str3, "", ""];
}
function readableStreamAsyncIterable2(stream) {
  if (stream[Symbol.asyncIterator]) return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done) reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}

// node_modules/openai/uploads.mjs
var isResponseLike2 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.url === "string" &&
  typeof value.blob === "function";
var isFileLike2 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.name === "string" &&
  typeof value.lastModified === "number" &&
  isBlobLike2(value);
var isBlobLike2 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.size === "number" &&
  typeof value.type === "string" &&
  typeof value.text === "function" &&
  typeof value.slice === "function" &&
  typeof value.arrayBuffer === "function";
var isUploadable2 = (value) => {
  return isFileLike2(value) || isResponseLike2(value) || isFsReadStream2(value);
};
async function toFile2(value, name, options = {}) {
  var _a4, _b, _c;
  value = await value;
  if (isResponseLike2(value)) {
    const blob = await value.blob();
    name ||
      (name =
        (_a4 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null
          ? _a4
          : "unknown_file");
    return new File3([blob], name, options);
  }
  const bits = await getBytes2(value);
  name || (name = (_b = getName2(value)) != null ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File3(bits, name, options);
}
async function getBytes2(value) {
  var _a4;
  let parts = [];
  if (
    typeof value === "string" ||
    ArrayBuffer.isView(value) ||
    value instanceof ArrayBuffer
  ) {
    parts.push(value);
  } else if (isBlobLike2(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator2(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${
        (_a4 = value == null ? void 0 : value.constructor) == null
          ? void 0
          : _a4.name
      }; props: ${propsForError2(value)}`
    );
  }
  return parts;
}
function propsForError2(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName2(value) {
  var _a4;
  return (
    getStringFromMaybeBuffer2(value.name) ||
    getStringFromMaybeBuffer2(value.filename) ||
    ((_a4 = getStringFromMaybeBuffer2(value.path)) == null
      ? void 0
      : _a4.split(/[\\/]/).pop())
  );
}
var getStringFromMaybeBuffer2 = (x) => {
  if (typeof x === "string") return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer) return String(x);
  return void 0;
};
var isAsyncIterableIterator2 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody2 = (body) =>
  body &&
  typeof body === "object" &&
  body.body &&
  body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions2 = async (opts) => {
  const form = await createForm2(opts.body);
  return getMultipartRequestOptions2(form, opts);
};
var createForm2 = async (body) => {
  const form = new FormData3();
  await Promise.all(
    Object.entries(body || {}).map(([key, value]) =>
      addFormValue2(form, key, value)
    )
  );
  return form;
};
var addFormValue2 = async (form, key, value) => {
  if (value === void 0) return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`
    );
  }
  if (
    typeof value === "string" ||
    typeof value === "number" ||
    typeof value === "boolean"
  ) {
    form.append(key, String(value));
  } else if (isUploadable2(value)) {
    const file = await toFile2(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(
      value.map((entry) => addFormValue2(form, key + "[]", entry))
    );
  } else if (typeof value === "object") {
    await Promise.all(
      Object.entries(value).map(([name, prop]) =>
        addFormValue2(form, `${key}[${name}]`, prop)
      )
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
    );
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet4 = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var __classPrivateFieldGet4 = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var _AbstractPage_client2;
async function defaultParseResponse2(props) {
  const { response } = props;
  if (props.options.stream) {
    debug2(
      "response",
      response.status,
      response.url,
      response.headers,
      response.body
    );
    return Stream2.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  if (contentType == null ? void 0 : contentType.includes("application/json")) {
    const json = await response.json();
    debug2("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug2("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise2 = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse2) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise2(this.responsePromise, async (props) =>
      transform(await this.parseResponse(props))
    );
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([
      this.parse(),
      this.asResponse(),
    ]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient2 = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    httpAgent,
    fetch: overridenFetch,
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger2("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger2("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch != null ? overridenFetch : fetch3;
  }
  authHeaders(opts) {
    return {};
  }
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders2(),
      ...this.authHeaders(opts),
    };
  }
  validateHeaders(headers, customHeaders) {}
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid42()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(
      Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 }))
    );
  }
  getAPIList(path, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a4, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody2(options.body)
      ? options.body.body
      : options.body
      ? JSON.stringify(options.body, null, 2)
      : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger2("timeout", options.timeout);
    const timeout = (_a4 = options.timeout) != null ? _a4 : this.timeout;
    const httpAgent =
      (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null
        ? _c
        : getDefaultAgent2(url);
    const minAgentTimeout = timeout + 1e3;
    if (
      typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null
        ? void 0
        : _d.timeout) === "number" &&
      minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)
    ) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...(contentLength && { "Content-Length": contentLength }),
      ...this.defaultHeaders(options),
      ...headers,
    };
    if (isMultipartBody2(options.body) && kind2 !== "node") {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach(
      (key) => reqHeaders[key] === null && delete reqHeaders[key]
    );
    const req = {
      method,
      ...(body && { body }),
      headers: reqHeaders,
      ...(httpAgent && { agent: httpAgent }),
      signal: (_f = options.signal) != null ? _f : null,
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  async prepareRequest(request4, { url, options }) {}
  parseHeaders(headers) {
    return !headers
      ? {}
      : Symbol.iterator in headers
      ? Object.fromEntries(Array.from(headers).map((header) => [...header]))
      : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError3.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise2(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a4, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining =
        (_a4 = options.maxRetries) != null ? _a4 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug2("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError3();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(
      url,
      req,
      timeout,
      controller
    ).catch(castToError2);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError3();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError3();
      }
      throw new APIConnectionError3({ cause: response });
    }
    const responseHeaders = createResponseHeaders2(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response
        .text()
        .catch((e) => castToError2(e).message);
      const errJSON = safeJSON2(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug2("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(
        response.status,
        errJSON,
        errMessage,
        responseHeaders
      );
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page3, options) {
    const request4 = this.makeRequest(options, null);
    return new PagePromise2(this, request4, Page3);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL2(path)
      ? new URL(path)
      : new URL(
          this.baseURL +
            (this.baseURL.endsWith("/") && path.startsWith("/")
              ? path.slice(1)
              : path)
        );
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj2(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query)
      .filter(([_, value]) => typeof value !== "undefined")
      .map(([key, value]) => {
        if (
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean"
        ) {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new OpenAIError3(
          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
        );
      })
      .join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal) signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient()
      .fetch.call(void 0, url, { signal: controller.signal, ...options })
      .finally(() => {
        clearTimeout(timeout);
      });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true") return true;
    if (shouldRetryHeader === "false") return false;
    if (response.status === 408) return true;
    if (response.status === 409) return true;
    if (response.status === 429) return true;
    if (response.status >= 500) return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a4;
    let timeoutMillis;
    const retryAfterHeader =
      responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader) {
      const timeoutSeconds = parseInt(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (
      !timeoutMillis ||
      !Number.isInteger(timeoutMillis) ||
      timeoutMillis <= 0 ||
      timeoutMillis > 60 * 1e3
    ) {
      const maxRetries =
        (_a4 = options.maxRetries) != null ? _a4 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(
        retriesRemaining,
        maxRetries
      );
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(
      initialRetryDelay * Math.pow(2, numRetries),
      maxRetryDelay
    );
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
};
var AbstractPage2 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client2.set(this, void 0);
    __classPrivateFieldSet4(this, _AbstractPage_client2, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length) return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError3(
        "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
      );
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [
        ...Object.entries(nextOptions.query || {}),
        ...nextInfo.url.searchParams.entries(),
      ];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet4(
      this,
      _AbstractPage_client2,
      "f"
    ).requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[((_AbstractPage_client2 = /* @__PURE__ */ new WeakMap()),
  Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise2 = class extends APIPromise2 {
  constructor(client, request4, Page3) {
    super(
      request4,
      async (props) =>
        new Page3(
          client,
          props.response,
          await defaultParseResponse2(props),
          props.options
        )
    );
  }
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders2 = (headers) => {
  return new Proxy(Object.fromEntries(headers.entries()), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    },
  });
};
var requestOptionsKeys2 = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryResponse: true,
};
var isRequestOptions2 = (obj) => {
  return (
    typeof obj === "object" &&
    obj !== null &&
    !isEmptyObj2(obj) &&
    Object.keys(obj).every((k) => hasOwn2(requestOptionsKeys2, k))
  );
};
var getPlatformProperties2 = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(Deno.build.os),
      "X-Stainless-Arch": normalizeArch2(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version,
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version,
    };
  }
  if (
    Object.prototype.toString.call(
      typeof process !== "undefined" ? process : 0
    ) === "[object process]"
  ) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(process.platform),
      "X-Stainless-Arch": normalizeArch2(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version,
    };
  }
  const browserInfo = getBrowserInfo2();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version,
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown",
  };
};
function getBrowserInfo2() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    {
      key: "safari",
      pattern:
        /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/,
    },
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch2 = (arch) => {
  if (arch === "x32") return "x32";
  if (arch === "x86_64" || arch === "x64") return "x64";
  if (arch === "arm") return "arm";
  if (arch === "aarch64" || arch === "arm64") return "arm64";
  if (arch) return `other:${arch}`;
  return "unknown";
};
var normalizePlatform2 = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios")) return "iOS";
  if (platform === "android") return "Android";
  if (platform === "darwin") return "MacOS";
  if (platform === "win32") return "Windows";
  if (platform === "freebsd") return "FreeBSD";
  if (platform === "openbsd") return "OpenBSD";
  if (platform === "linux") return "Linux";
  if (platform) return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders2;
var getPlatformHeaders2 = () => {
  return _platformHeaders2 != null
    ? _platformHeaders2
    : (_platformHeaders2 = getPlatformProperties2());
};
var safeJSON2 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp2 = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL2 = (url) => {
  return startsWithSchemeRegexp2.test(url);
};
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger2 = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError3(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError3(`${name} must be a positive integer`);
  }
  return n;
};
var castToError2 = (err) => {
  if (err instanceof Error) return err;
  return new Error(err);
};
var readEnv2 = (env) => {
  var _a4, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a4 = process.env) == null ? void 0 : _a4[env]) != null
      ? _b
      : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) == null ? void 0 : _c.get) == null
      ? void 0
      : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj2(obj) {
  if (!obj) return true;
  for (const _k in obj) return false;
  return true;
}
function hasOwn2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug2(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid42 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 3) | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser2 = () => {
  return (
    typeof window !== "undefined" &&
    typeof window.document !== "undefined" &&
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page2 = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data;
  }
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage2 = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info) return null;
    if ("params" in info) return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length) return null;
    return params;
  }
  nextPageInfo() {
    var _a4, _b;
    if (!((_a4 = this.data) == null ? void 0 : _a4.length)) {
      return null;
    }
    const next =
      (_b = this.data[this.data.length - 1]) == null ? void 0 : _b.id;
    if (!next) return null;
    return { params: { after: next } };
  }
};

// node_modules/openai/resource.mjs
var APIResource2 = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions.mjs
var Completions4 = class extends APIResource2 {
  create(body, options) {
    var _a4;
    return this._client.post("/chat/completions", {
      body,
      ...options,
      stream: (_a4 = body.stream) != null ? _a4 : false,
    });
  }
};
(function (Completions8) {})(Completions4 || (Completions4 = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat3 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.completions = new Completions4(this._client);
  }
};
(function (Chat6) {
  Chat6.Completions = Completions4;
})(Chat3 || (Chat3 = {}));

// node_modules/openai/resources/audio/speech.mjs
var Speech2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      __binaryResponse: true,
    });
  }
};
(function (Speech3) {})(Speech2 || (Speech2 = {}));

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post(
      "/audio/transcriptions",
      multipartFormRequestOptions2({ body, ...options })
    );
  }
};
(function (Transcriptions4) {})(Transcriptions2 || (Transcriptions2 = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post(
      "/audio/translations",
      multipartFormRequestOptions2({ body, ...options })
    );
  }
};
(function (Translations4) {})(Translations2 || (Translations2 = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions2(this._client);
    this.translations = new Translations2(this._client);
    this.speech = new Speech2(this._client);
  }
};
(function (Audio4) {
  Audio4.Transcriptions = Transcriptions2;
  Audio4.Translations = Translations2;
  Audio4.Speech = Speech2;
})(Audio2 || (Audio2 = {}));

// node_modules/openai/resources/beta/assistants/files.mjs
var Files4 = class extends APIResource2 {
  create(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}/files`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(assistantId, fileId, options) {
    return this._client.get(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(assistantId, query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list(assistantId, {}, query);
    }
    return this._client.getAPIList(
      `/assistants/${assistantId}/files`,
      AssistantFilesPage2,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
  del(assistantId, fileId, options) {
    return this._client.delete(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
var AssistantFilesPage2 = class extends CursorPage2 {};
(function (Files7) {
  Files7.AssistantFilesPage = AssistantFilesPage2;
})(Files4 || (Files4 = {}));

// node_modules/openai/resources/beta/assistants/assistants.mjs
var Assistants2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.files = new Files4(this._client);
  }
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage2, {
      query,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
var AssistantsPage2 = class extends CursorPage2 {};
(function (Assistants3) {
  Assistants3.AssistantsPage = AssistantsPage2;
  Assistants3.Files = Files4;
  Assistants3.AssistantFilesPage = AssistantFilesPage2;
})(Assistants2 || (Assistants2 = {}));

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse2(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage2 = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage2 = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage2 = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldSet5 = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var __classPrivateFieldGet5 = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances2;
var _AbstractChatCompletionRunner_connectedPromise2;
var _AbstractChatCompletionRunner_resolveConnectedPromise2;
var _AbstractChatCompletionRunner_rejectConnectedPromise2;
var _AbstractChatCompletionRunner_endPromise2;
var _AbstractChatCompletionRunner_resolveEndPromise2;
var _AbstractChatCompletionRunner_rejectEndPromise2;
var _AbstractChatCompletionRunner_listeners2;
var _AbstractChatCompletionRunner_ended2;
var _AbstractChatCompletionRunner_errored2;
var _AbstractChatCompletionRunner_aborted2;
var _AbstractChatCompletionRunner_catchingPromiseCreated2;
var _AbstractChatCompletionRunner_getFinalContent3;
var _AbstractChatCompletionRunner_getFinalMessage3;
var _AbstractChatCompletionRunner_getFinalFunctionCall3;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult3;
var _AbstractChatCompletionRunner_calculateTotalUsage3;
var _AbstractChatCompletionRunner_handleError2;
var _AbstractChatCompletionRunner_validateParams3;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult3;
var DEFAULT_MAX_CHAT_COMPLETIONS2 = 10;
var AbstractChatCompletionRunner2 = class {
  constructor() {
    _AbstractChatCompletionRunner_instances2.add(this);
    this.controller = new AbortController();
    _AbstractChatCompletionRunner_connectedPromise2.set(this, void 0);
    _AbstractChatCompletionRunner_resolveConnectedPromise2.set(this, () => {});
    _AbstractChatCompletionRunner_rejectConnectedPromise2.set(this, () => {});
    _AbstractChatCompletionRunner_endPromise2.set(this, void 0);
    _AbstractChatCompletionRunner_resolveEndPromise2.set(this, () => {});
    _AbstractChatCompletionRunner_rejectEndPromise2.set(this, () => {});
    _AbstractChatCompletionRunner_listeners2.set(this, {});
    this._chatCompletions = [];
    this.messages = [];
    _AbstractChatCompletionRunner_ended2.set(this, false);
    _AbstractChatCompletionRunner_errored2.set(this, false);
    _AbstractChatCompletionRunner_aborted2.set(this, false);
    _AbstractChatCompletionRunner_catchingPromiseCreated2.set(this, false);
    _AbstractChatCompletionRunner_handleError2.set(this, (error) => {
      __classPrivateFieldSet5(
        this,
        _AbstractChatCompletionRunner_errored2,
        true,
        "f"
      );
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError3();
      }
      if (error instanceof APIUserAbortError3) {
        __classPrivateFieldSet5(
          this,
          _AbstractChatCompletionRunner_aborted2,
          true,
          "f"
        );
        return this._emit("abort", error);
      }
      if (error instanceof OpenAIError3) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const openAIError = new OpenAIError3(error.message);
        openAIError.cause = error;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new OpenAIError3(String(error)));
    });
    __classPrivateFieldSet5(
      this,
      _AbstractChatCompletionRunner_connectedPromise2,
      new Promise((resolve, reject) => {
        __classPrivateFieldSet5(
          this,
          _AbstractChatCompletionRunner_resolveConnectedPromise2,
          resolve,
          "f"
        );
        __classPrivateFieldSet5(
          this,
          _AbstractChatCompletionRunner_rejectConnectedPromise2,
          reject,
          "f"
        );
      }),
      "f"
    );
    __classPrivateFieldSet5(
      this,
      _AbstractChatCompletionRunner_endPromise2,
      new Promise((resolve, reject) => {
        __classPrivateFieldSet5(
          this,
          _AbstractChatCompletionRunner_resolveEndPromise2,
          resolve,
          "f"
        );
        __classPrivateFieldSet5(
          this,
          _AbstractChatCompletionRunner_rejectEndPromise2,
          reject,
          "f"
        );
      }),
      "f"
    );
    __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_connectedPromise2,
      "f"
    ).catch(() => {});
    __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_endPromise2,
      "f"
    ).catch(() => {});
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_handleError2, "f"));
    }, 0);
  }
  _addChatCompletion(chatCompletion) {
    var _a4;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message =
      (_a4 = chatCompletion.choices[0]) == null ? void 0 : _a4.message;
    if (message) this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (
        (isFunctionMessage2(message) || isToolMessage2(message)) &&
        message.content
      ) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage2(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage2(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  _connected() {
    if (this.ended) return;
    __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_resolveConnectedPromise2,
      "f"
    ).call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_ended2,
      "f"
    );
  }
  get errored() {
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_errored2,
      "f"
    );
  }
  get aborted() {
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_aborted2,
      "f"
    );
  }
  abort() {
    this.controller.abort();
  }
  on(event, listener) {
    const listeners =
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_listeners2,
        "f"
      )[event] ||
      (__classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_listeners2,
        "f"
      )[event] = []);
    listeners.push({ listener });
    return this;
  }
  off(event, listener) {
    const listeners = __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_listeners2,
      "f"
    )[event];
    if (!listeners) return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0) listeners.splice(index, 1);
    return this;
  }
  once(event, listener) {
    const listeners =
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_listeners2,
        "f"
      )[event] ||
      (__classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_listeners2,
        "f"
      )[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet5(
        this,
        _AbstractChatCompletionRunner_catchingPromiseCreated2,
        true,
        "f"
      );
      if (event !== "error") this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet5(
      this,
      _AbstractChatCompletionRunner_catchingPromiseCreated2,
      true,
      "f"
    );
    await __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_endPromise2,
      "f"
    );
  }
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError3("stream ended without producing a ChatCompletion");
    return completion;
  }
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalContent3
    ).call(this);
  }
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalMessage3
    ).call(this);
  }
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCall3
    ).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCallResult3
    ).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_calculateTotalUsage3
    ).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(event, ...args) {
    if (
      __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_ended2, "f")
    )
      return;
    if (event === "end") {
      __classPrivateFieldSet5(
        this,
        _AbstractChatCompletionRunner_ended2,
        true,
        "f"
      );
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_resolveEndPromise2,
        "f"
      ).call(this);
    }
    const listeners = __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_listeners2,
      "f"
    )[event];
    if (listeners) {
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_listeners2,
        "f"
      )[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (
        !__classPrivateFieldGet5(
          this,
          _AbstractChatCompletionRunner_catchingPromiseCreated2,
          "f"
        ) &&
        !(listeners == null ? void 0 : listeners.length)
      ) {
        Promise.reject(error);
      }
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_rejectConnectedPromise2,
        "f"
      ).call(this, error);
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_rejectEndPromise2,
        "f"
      ).call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (
        !__classPrivateFieldGet5(
          this,
          _AbstractChatCompletionRunner_catchingPromiseCreated2,
          "f"
        ) &&
        !(listeners == null ? void 0 : listeners.length)
      ) {
        Promise.reject(error);
      }
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_rejectConnectedPromise2,
        "f"
      ).call(this, error);
      __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_rejectEndPromise2,
        "f"
      ).call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion) this._emit("finalChatCompletion", completion);
    const finalMessage = this.messages[this.messages.length - 1];
    if (finalMessage) this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalContent3
    ).call(this);
    if (finalContent) this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCall3
    ).call(this);
    if (finalFunctionCall) this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_getFinalFunctionCallResult3
    ).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit(
        "totalUsage",
        __classPrivateFieldGet5(
          this,
          _AbstractChatCompletionRunner_instances2,
          "m",
          _AbstractChatCompletionRunner_calculateTotalUsage3
        ).call(this)
      );
    }
  }
  async _createChatCompletion(completions, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted) this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet5(
      this,
      _AbstractChatCompletionRunner_instances2,
      "m",
      _AbstractChatCompletionRunner_validateParams3
    ).call(this, params);
    const chatCompletion = await completions.create(
      { ...params, stream: false },
      { ...options, signal: this.controller.signal }
    );
    this._connected();
    return this._addChatCompletion(chatCompletion);
  }
  async _runChatCompletion(completions, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(completions, params, options);
  }
  async _runFunctions(completions, params, options) {
    var _a4;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall =
      typeof function_call !== "string" &&
      (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS2 } =
      options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description,
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(
        completions,
        {
          ...restParams,
          function_call,
          functions,
          messages: [...this.messages],
        },
        options
      );
      const message =
        (_a4 = chatCompletion.choices[0]) == null ? void 0 : _a4.message;
      if (!message) {
        throw new OpenAIError3(`missing message in ChatCompletion response`);
      }
      if (!message.function_call) return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(
          name
        )}. Available options are: ${functions
          .map((f) => JSON.stringify(f.name))
          .join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(
          name
        )}. ${JSON.stringify(
          singleFunctionToCall
        )} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse2(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error),
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_instances2,
        "m",
        _AbstractChatCompletionRunner_stringifyFunctionCallResult3
      ).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall) return;
    }
  }
  async _runTools(completions, params, options) {
    var _a4, _b;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall =
      typeof tool_choice !== "string" &&
      ((_a4 = tool_choice == null ? void 0 : tool_choice.function) == null
        ? void 0
        : _a4.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS2 } =
      options || {};
    const functionsByName = {};
    for (const f of params.tools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] =
          f.function;
      }
    }
    const tools =
      "tools" in params
        ? params.tools.map((t) =>
            t.type === "function"
              ? {
                  type: "function",
                  function: {
                    name: t.function.name || t.function.function.name,
                    parameters: t.function.parameters,
                    description: t.function.description,
                  },
                }
              : t
          )
        : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(
        completions,
        {
          ...restParams,
          tool_choice,
          tools,
          messages: [...this.messages],
        },
        options
      );
      const message =
        (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError3(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls) return;
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function") continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(
            name
          )}. Available options are: ${tools
            .map((f) => JSON.stringify(f.function.name))
            .join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(
            name
          )}. ${JSON.stringify(
            singleFunctionToCall
          )} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse2(fn)
            ? await fn.parse(args)
            : args;
        } catch (error) {
          const content2 =
            error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet5(
          this,
          _AbstractChatCompletionRunner_instances2,
          "m",
          _AbstractChatCompletionRunner_stringifyFunctionCallResult3
        ).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) return;
      }
    }
  }
};
(_AbstractChatCompletionRunner_connectedPromise2 =
  /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_resolveConnectedPromise2 =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_rejectConnectedPromise2 =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_endPromise2 = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_resolveEndPromise2 =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_rejectEndPromise2 =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_listeners2 = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_ended2 = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_errored2 = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_aborted2 = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_catchingPromiseCreated2 =
    /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_handleError2 = /* @__PURE__ */ new WeakMap()),
  (_AbstractChatCompletionRunner_instances2 = /* @__PURE__ */ new WeakSet()),
  (_AbstractChatCompletionRunner_getFinalContent3 =
    function _AbstractChatCompletionRunner_getFinalContent4() {
      return __classPrivateFieldGet5(
        this,
        _AbstractChatCompletionRunner_instances2,
        "m",
        _AbstractChatCompletionRunner_getFinalMessage3
      ).call(this).content;
    }),
  (_AbstractChatCompletionRunner_getFinalMessage3 =
    function _AbstractChatCompletionRunner_getFinalMessage4() {
      let i = this.messages.length;
      while (i-- > 0) {
        const message = this.messages[i];
        if (isAssistantMessage2(message)) {
          return message;
        }
      }
      throw new OpenAIError3(
        "stream ended without producing a ChatCompletionMessage with role=assistant"
      );
    }),
  (_AbstractChatCompletionRunner_getFinalFunctionCall3 =
    function _AbstractChatCompletionRunner_getFinalFunctionCall4() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if (
          isAssistantMessage2(message) &&
          (message == null ? void 0 : message.function_call)
        ) {
          return message.function_call;
        }
      }
      return;
    }),
  (_AbstractChatCompletionRunner_getFinalFunctionCallResult3 =
    function _AbstractChatCompletionRunner_getFinalFunctionCallResult4() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if (isFunctionMessage2(message) && message.content != null) {
          return message.content;
        }
      }
      return;
    }),
  (_AbstractChatCompletionRunner_calculateTotalUsage3 =
    function _AbstractChatCompletionRunner_calculateTotalUsage4() {
      const total = {
        completion_tokens: 0,
        prompt_tokens: 0,
        total_tokens: 0,
      };
      for (const { usage } of this._chatCompletions) {
        if (usage) {
          total.completion_tokens += usage.completion_tokens;
          total.prompt_tokens += usage.prompt_tokens;
          total.total_tokens += usage.total_tokens;
        }
      }
      return total;
    }),
  (_AbstractChatCompletionRunner_validateParams3 =
    function _AbstractChatCompletionRunner_validateParams4(params) {
      if (params.n != null && params.n > 1) {
        throw new OpenAIError3(
          "ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly."
        );
      }
    }),
  (_AbstractChatCompletionRunner_stringifyFunctionCallResult3 =
    function _AbstractChatCompletionRunner_stringifyFunctionCallResult4(
      rawContent
    ) {
      return typeof rawContent === "string"
        ? rawContent
        : rawContent === void 0
        ? "undefined"
        : JSON.stringify(rawContent);
    });

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner2 = class extends AbstractChatCompletionRunner2 {
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionRunner2();
    runner._run(() => runner._runFunctions(completions, params, options));
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionRunner2();
    runner._run(() => runner._runTools(completions, params, options));
    return runner;
  }
  _addMessage(message) {
    super._addMessage(message);
    if (isAssistantMessage2(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldGet6 = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var __classPrivateFieldSet6 = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var _ChatCompletionStream_instances2;
var _ChatCompletionStream_currentChatCompletionSnapshot2;
var _ChatCompletionStream_beginRequest2;
var _ChatCompletionStream_addChunk2;
var _ChatCompletionStream_endRequest2;
var _ChatCompletionStream_accumulateChatCompletion2;
var ChatCompletionStream2 = class extends AbstractChatCompletionRunner2 {
  constructor() {
    super(...arguments);
    _ChatCompletionStream_instances2.add(this);
    _ChatCompletionStream_currentChatCompletionSnapshot2.set(this, void 0);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet6(
      this,
      _ChatCompletionStream_currentChatCompletionSnapshot2,
      "f"
    );
  }
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream2();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(completions, params, options) {
    const runner = new ChatCompletionStream2();
    runner._run(() =>
      runner._runChatCompletion(
        completions,
        { ...params, stream: true },
        {
          ...options,
          headers: {
            ...(options == null ? void 0 : options.headers),
            "X-Stainless-Helper-Method": "stream",
          },
        }
      )
    );
    return runner;
  }
  async _createChatCompletion(completions, params, options) {
    var _a4;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted) this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet6(
      this,
      _ChatCompletionStream_instances2,
      "m",
      _ChatCompletionStream_beginRequest2
    ).call(this);
    const stream = await completions.create(
      { ...params, stream: true },
      { ...options, signal: this.controller.signal }
    );
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet6(
        this,
        _ChatCompletionStream_instances2,
        "m",
        _ChatCompletionStream_addChunk2
      ).call(this, chunk);
    }
    if ((_a4 = stream.controller.signal) == null ? void 0 : _a4.aborted) {
      throw new APIUserAbortError3();
    }
    return this._addChatCompletion(
      __classPrivateFieldGet6(
        this,
        _ChatCompletionStream_instances2,
        "m",
        _ChatCompletionStream_endRequest2
      ).call(this)
    );
  }
  async _fromReadableStream(readableStream, options) {
    var _a4;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted) this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet6(
      this,
      _ChatCompletionStream_instances2,
      "m",
      _ChatCompletionStream_beginRequest2
    ).call(this);
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(
          __classPrivateFieldGet6(
            this,
            _ChatCompletionStream_instances2,
            "m",
            _ChatCompletionStream_endRequest2
          ).call(this)
        );
      }
      __classPrivateFieldGet6(
        this,
        _ChatCompletionStream_instances2,
        "m",
        _ChatCompletionStream_addChunk2
      ).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a4 = stream.controller.signal) == null ? void 0 : _a4.aborted) {
      throw new APIUserAbortError3();
    }
    return this._addChatCompletion(
      __classPrivateFieldGet6(
        this,
        _ChatCompletionStream_instances2,
        "m",
        _ChatCompletionStream_endRequest2
      ).call(this)
    );
  }
  [((_ChatCompletionStream_currentChatCompletionSnapshot2 =
    /* @__PURE__ */ new WeakMap()),
  (_ChatCompletionStream_instances2 = /* @__PURE__ */ new WeakSet()),
  (_ChatCompletionStream_beginRequest2 =
    function _ChatCompletionStream_beginRequest3() {
      if (this.ended) return;
      __classPrivateFieldSet6(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot2,
        void 0,
        "f"
      );
    }),
  (_ChatCompletionStream_addChunk2 = function _ChatCompletionStream_addChunk3(
    chunk
  ) {
    var _a4, _b, _c;
    if (this.ended) return;
    const completion = __classPrivateFieldGet6(
      this,
      _ChatCompletionStream_instances2,
      "m",
      _ChatCompletionStream_accumulateChatCompletion2
    ).call(this, chunk);
    this._emit("chunk", chunk, completion);
    const delta =
      (_b = (_a4 = chunk.choices[0]) == null ? void 0 : _a4.delta) == null
        ? void 0
        : _b.content;
    const snapshot = (_c = completion.choices[0]) == null ? void 0 : _c.message;
    if (
      delta != null &&
      (snapshot == null ? void 0 : snapshot.role) === "assistant" &&
      (snapshot == null ? void 0 : snapshot.content)
    ) {
      this._emit("content", delta, snapshot.content);
    }
  }),
  (_ChatCompletionStream_endRequest2 =
    function _ChatCompletionStream_endRequest3() {
      if (this.ended) {
        throw new OpenAIError3(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet6(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot2,
        "f"
      );
      if (!snapshot) {
        throw new OpenAIError3(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet6(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot2,
        void 0,
        "f"
      );
      return finalizeChatCompletion2(snapshot);
    }),
  (_ChatCompletionStream_accumulateChatCompletion2 =
    function _ChatCompletionStream_accumulateChatCompletion3(chunk) {
      var _a5, _b2, _c;
      var _a4, _b;
      let snapshot = __classPrivateFieldGet6(
        this,
        _ChatCompletionStream_currentChatCompletionSnapshot2,
        "f"
      );
      const { choices, ...rest } = chunk;
      if (!snapshot) {
        snapshot = __classPrivateFieldSet6(
          this,
          _ChatCompletionStream_currentChatCompletionSnapshot2,
          {
            ...rest,
            choices: [],
          },
          "f"
        );
      } else {
        Object.assign(snapshot, rest);
      }
      for (const { delta, finish_reason, index, ...other } of chunk.choices) {
        let choice = snapshot.choices[index];
        if (!choice) {
          snapshot.choices[index] = {
            finish_reason,
            index,
            message: delta,
            ...other,
          };
          continue;
        }
        if (finish_reason) choice.finish_reason = finish_reason;
        Object.assign(choice, other);
        if (!delta) continue;
        const { content, function_call, role, tool_calls } = delta;
        if (content)
          choice.message.content = (choice.message.content || "") + content;
        if (role) choice.message.role = role;
        if (function_call) {
          if (!choice.message.function_call) {
            choice.message.function_call = function_call;
          } else {
            if (function_call.name)
              choice.message.function_call.name = function_call.name;
            if (function_call.arguments) {
              (_a5 = (_a4 = choice.message.function_call).arguments) != null
                ? _a5
                : (_a4.arguments = "");
              choice.message.function_call.arguments += function_call.arguments;
            }
          }
        }
        if (tool_calls) {
          if (!choice.message.tool_calls) choice.message.tool_calls = [];
          for (const { index: index2, id, type, function: fn } of tool_calls) {
            const tool_call =
              (_b2 = (_b = choice.message.tool_calls)[index2]) != null
                ? _b2
                : (_b[index2] = {});
            if (id) tool_call.id = id;
            if (type) tool_call.type = type;
            if (fn)
              (_c = tool_call.function) != null
                ? _c
                : (tool_call.function = { arguments: "" });
            if (fn == null ? void 0 : fn.name)
              tool_call.function.name = fn.name;
            if (fn == null ? void 0 : fn.arguments)
              tool_call.function.arguments += fn.arguments;
          }
        }
      }
      return snapshot;
    }),
  Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader(void 0);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve) => readQueue.push(resolve)).then(
            (chunk2) =>
              chunk2
                ? { value: chunk2, done: false }
                : { value: void 0, done: true }
          );
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
    };
  }
  toReadableStream() {
    const stream = new Stream2(
      this[Symbol.asyncIterator].bind(this),
      this.controller
    );
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion2(snapshot) {
  const { id, choices, created, model } = snapshot;
  return {
    id,
    choices: choices.map(({ message, finish_reason, index }) => {
      if (!finish_reason)
        throw new OpenAIError3(`missing finish_reason for choice ${index}`);
      const { content = null, function_call, tool_calls } = message;
      const role = message.role;
      if (!role) throw new OpenAIError3(`missing role for choice ${index}`);
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null)
          throw new OpenAIError3(
            `missing function_call.arguments for choice ${index}`
          );
        if (!name)
          throw new OpenAIError3(
            `missing function_call.name for choice ${index}`
          );
        return {
          message: { content, function_call: { arguments: args, name }, role },
          finish_reason,
          index,
        };
      }
      if (tool_calls) {
        return {
          index,
          finish_reason,
          message: {
            role,
            content,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2 } = tool_call;
              const { arguments: args, name } = fn || {};
              if (id2 == null)
                throw new OpenAIError3(`missing choices[${index}].tool_calls[${i}].id
${str2(snapshot)}`);
              if (type == null)
                throw new OpenAIError3(`missing choices[${index}].tool_calls[${i}].type
${str2(snapshot)}`);
              if (name == null)
                throw new OpenAIError3(`missing choices[${index}].tool_calls[${i}].function.name
${str2(snapshot)}`);
              if (args == null)
                throw new OpenAIError3(`missing choices[${index}].tool_calls[${i}].function.arguments
${str2(snapshot)}`);
              return { id: id2, type, function: { name, arguments: args } };
            }),
          },
        };
      }
      return { message: { content, role }, finish_reason, index };
    }),
    created,
    model,
    object: "chat.completion",
  };
}
function str2(x) {
  return JSON.stringify(x);
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner2 = class extends ChatCompletionStream2 {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner2();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner2();
    runner._run(() =>
      runner._runFunctions(completions, params, {
        ...options,
        headers: {
          ...(options == null ? void 0 : options.headers),
          "X-Stainless-Helper-Method": "runFunctions",
        },
      })
    );
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner2();
    runner._run(() =>
      runner._runTools(completions, params, {
        ...options,
        headers: {
          ...(options == null ? void 0 : options.headers),
          "X-Stainless-Helper-Method": "runTools",
        },
      })
    );
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions5 = class extends APIResource2 {
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner2.runFunctions(
        this._client.chat.completions,
        body,
        options
      );
    }
    return ChatCompletionRunner2.runFunctions(
      this._client.chat.completions,
      body,
      options
    );
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner2.runTools(
        this._client.chat.completions,
        body,
        options
      );
    }
    return ChatCompletionRunner2.runTools(
      this._client.chat.completions,
      body,
      options
    );
  }
  stream(body, options) {
    return ChatCompletionStream2.createChatCompletion(
      this._client.chat.completions,
      body,
      options
    );
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat4 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.completions = new Completions5(this._client);
  }
};
(function (Chat6) {
  Chat6.Completions = Completions5;
})(Chat4 || (Chat4 = {}));

// node_modules/openai/resources/beta/threads/messages/files.mjs
var Files5 = class extends APIResource2 {
  retrieve(threadId, messageId, fileId, options) {
    return this._client.get(
      `/threads/${threadId}/messages/${messageId}/files/${fileId}`,
      {
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
  list(threadId, messageId, query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list(threadId, messageId, {}, query);
    }
    return this._client.getAPIList(
      `/threads/${threadId}/messages/${messageId}/files`,
      MessageFilesPage2,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var MessageFilesPage2 = class extends CursorPage2 {};
(function (Files7) {
  Files7.MessageFilesPage = MessageFilesPage2;
})(Files5 || (Files5 = {}));

// node_modules/openai/resources/beta/threads/messages/messages.mjs
var Messages2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.files = new Files5(this._client);
  }
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(
      `/threads/${threadId}/messages`,
      ThreadMessagesPage2,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var ThreadMessagesPage2 = class extends CursorPage2 {};
(function (Messages3) {
  Messages3.ThreadMessagesPage = ThreadMessagesPage2;
  Messages3.Files = Files5;
  Messages3.MessageFilesPage = MessageFilesPage2;
})(Messages2 || (Messages2 = {}));

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps2 = class extends APIResource2 {
  retrieve(threadId, runId, stepId, options) {
    return this._client.get(
      `/threads/${threadId}/runs/${runId}/steps/${stepId}`,
      {
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(
      `/threads/${threadId}/runs/${runId}/steps`,
      RunStepsPage2,
      {
        query,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var RunStepsPage2 = class extends CursorPage2 {};
(function (Steps3) {
  Steps3.RunStepsPage = RunStepsPage2;
})(Steps2 || (Steps2 = {}));

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.steps = new Steps2(this._client);
  }
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/runs`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage2, {
      query,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(
      `/threads/${threadId}/runs/${runId}/submit_tool_outputs`,
      {
        body,
        ...options,
        headers: {
          "OpenAI-Beta": "assistants=v1",
          ...(options == null ? void 0 : options.headers),
        },
      }
    );
  }
};
var RunsPage2 = class extends CursorPage2 {};
(function (Runs3) {
  Runs3.RunsPage = RunsPage2;
  Runs3.Steps = Steps2;
  Runs3.RunStepsPage = RunStepsPage2;
})(Runs2 || (Runs2 = {}));

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
    this.messages = new Messages2(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions2(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: {
        "OpenAI-Beta": "assistants=v1",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
(function (Threads3) {
  Threads3.Runs = Runs2;
  Threads3.RunsPage = RunsPage2;
  Threads3.Messages = Messages2;
  Threads3.ThreadMessagesPage = ThreadMessagesPage2;
})(Threads2 || (Threads2 = {}));

// node_modules/openai/resources/beta/beta.mjs
var Beta2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.chat = new Chat4(this._client);
    this.assistants = new Assistants2(this._client);
    this.threads = new Threads2(this._client);
  }
};
(function (Beta3) {
  Beta3.Chat = Chat4;
  Beta3.Assistants = Assistants2;
  Beta3.AssistantsPage = AssistantsPage2;
  Beta3.Threads = Threads2;
})(Beta2 || (Beta2 = {}));

// node_modules/openai/resources/completions.mjs
var Completions6 = class extends APIResource2 {
  create(body, options) {
    var _a4;
    return this._client.post("/completions", {
      body,
      ...options,
      stream: (_a4 = body.stream) != null ? _a4 : false,
    });
  }
};
(function (Completions8) {})(Completions6 || (Completions6 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings3 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};
(function (Embeddings4) {})(Embeddings3 || (Embeddings3 = {}));

// node_modules/openai/resources/edits.mjs
var Edits2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/edits", { body, ...options });
  }
};
(function (Edits3) {})(Edits2 || (Edits2 = {}));

// node_modules/openai/resources/files.mjs
var Files6 = class extends APIResource2 {
  create(body, options) {
    return this._client.post(
      "/files",
      multipartFormRequestOptions2({ body, ...options })
    );
  }
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage2, {
      query,
      ...options,
    });
  }
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      __binaryResponse: true,
    });
  }
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: {
        Accept: "application/json",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
  async waitForProcessing(
    id,
    { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}
  ) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set([
      "processed",
      "error",
      "deleted",
    ]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError3({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,
        });
      }
    }
    return file;
  }
};
var FileObjectsPage2 = class extends Page2 {};
(function (Files7) {
  Files7.FileObjectsPage = FileObjectsPage2;
})(Files6 || (Files6 = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/fine-tunes", { body, ...options });
  }
  retrieve(fineTuneId, options) {
    return this._client.get(`/fine-tunes/${fineTuneId}`, options);
  }
  list(options) {
    return this._client.getAPIList("/fine-tunes", FineTunesPage2, options);
  }
  cancel(fineTuneId, options) {
    return this._client.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a4;
    return this._client.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream:
        (_a4 = query == null ? void 0 : query.stream) != null ? _a4 : false,
    });
  }
};
var FineTunesPage2 = class extends Page2 {};
(function (FineTunes3) {
  FineTunes3.FineTunesPage = FineTunesPage2;
})(FineTunes2 || (FineTunes2 = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage2, {
      query,
      ...options,
    });
  }
  cancel(fineTuningJobId, options) {
    return this._client.post(
      `/fine_tuning/jobs/${fineTuningJobId}/cancel`,
      options
    );
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions2(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(
      `/fine_tuning/jobs/${fineTuningJobId}/events`,
      FineTuningJobEventsPage2,
      {
        query,
        ...options,
      }
    );
  }
};
var FineTuningJobsPage2 = class extends CursorPage2 {};
var FineTuningJobEventsPage2 = class extends CursorPage2 {};
(function (Jobs3) {
  Jobs3.FineTuningJobsPage = FineTuningJobsPage2;
  Jobs3.FineTuningJobEventsPage = FineTuningJobEventsPage2;
})(Jobs2 || (Jobs2 = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs2(this._client);
  }
};
(function (FineTuning3) {
  FineTuning3.Jobs = Jobs2;
  FineTuning3.FineTuningJobsPage = FineTuningJobsPage2;
  FineTuning3.FineTuningJobEventsPage = FineTuningJobEventsPage2;
})(FineTuning2 || (FineTuning2 = {}));

// node_modules/openai/resources/images.mjs
var Images2 = class extends APIResource2 {
  createVariation(body, options) {
    return this._client.post(
      "/images/variations",
      multipartFormRequestOptions2({ body, ...options })
    );
  }
  edit(body, options) {
    return this._client.post(
      "/images/edits",
      multipartFormRequestOptions2({ body, ...options })
    );
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};
(function (Images3) {})(Images2 || (Images2 = {}));

// node_modules/openai/resources/models.mjs
var Models2 = class extends APIResource2 {
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  list(options) {
    return this._client.getAPIList("/models", ModelsPage2, options);
  }
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage2 = class extends Page2 {};
(function (Models4) {
  Models4.ModelsPage = ModelsPage2;
})(Models2 || (Models2 = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};
(function (Moderations3) {})(Moderations2 || (Moderations2 = {}));

// node_modules/openai/index.mjs
var _a2;
var OpenAI2 = class extends APIClient2 {
  constructor({
    apiKey = readEnv2("OPENAI_API_KEY"),
    organization = ((_a4) =>
      (_a4 = readEnv2("OPENAI_ORG_ID")) != null ? _a4 : null)(),
    ...opts
  } = {}) {
    var _a5, _b;
    if (apiKey === void 0) {
      throw new OpenAIError3(
        "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' })."
      );
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: (_a5 = opts.baseURL) != null ? _a5 : `https://api.openai.com/v1`,
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser2()) {
      throw new OpenAIError3(
        "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
      );
    }
    super({
      baseURL: options.baseURL,
      timeout: (_b = options.timeout) != null ? _b : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch,
    });
    this.completions = new Completions6(this);
    this.chat = new Chat3(this);
    this.edits = new Edits2(this);
    this.embeddings = new Embeddings3(this);
    this.files = new Files6(this);
    this.images = new Images2(this);
    this.audio = new Audio2(this);
    this.moderations = new Moderations2(this);
    this.models = new Models2(this);
    this.fineTuning = new FineTuning2(this);
    this.fineTunes = new FineTunes2(this);
    this.beta = new Beta2(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders,
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a2 = OpenAI2;
OpenAI2.OpenAI = _a2;
OpenAI2.OpenAIError = OpenAIError3;
OpenAI2.APIError = APIError3;
OpenAI2.APIConnectionError = APIConnectionError3;
OpenAI2.APIConnectionTimeoutError = APIConnectionTimeoutError3;
OpenAI2.APIUserAbortError = APIUserAbortError3;
OpenAI2.NotFoundError = NotFoundError3;
OpenAI2.ConflictError = ConflictError3;
OpenAI2.RateLimitError = RateLimitError3;
OpenAI2.BadRequestError = BadRequestError3;
OpenAI2.AuthenticationError = AuthenticationError3;
OpenAI2.InternalServerError = InternalServerError3;
OpenAI2.PermissionDeniedError = PermissionDeniedError3;
OpenAI2.UnprocessableEntityError = UnprocessableEntityError3;
var {
  OpenAIError: OpenAIError4,
  APIError: APIError4,
  APIConnectionError: APIConnectionError4,
  APIConnectionTimeoutError: APIConnectionTimeoutError4,
  APIUserAbortError: APIUserAbortError4,
  NotFoundError: NotFoundError4,
  ConflictError: ConflictError4,
  RateLimitError: RateLimitError4,
  BadRequestError: BadRequestError4,
  AuthenticationError: AuthenticationError4,
  InternalServerError: InternalServerError4,
  PermissionDeniedError: PermissionDeniedError4,
  UnprocessableEntityError: UnprocessableEntityError4,
} = error_exports2;
var toFile3 = toFile2;
(function (OpenAI3) {
  OpenAI3.toFile = toFile2;
  OpenAI3.fileFromPath = fileFromPath2;
  OpenAI3.Page = Page2;
  OpenAI3.CursorPage = CursorPage2;
  OpenAI3.Completions = Completions6;
  OpenAI3.Chat = Chat3;
  OpenAI3.Edits = Edits2;
  OpenAI3.Embeddings = Embeddings3;
  OpenAI3.Files = Files6;
  OpenAI3.FileObjectsPage = FileObjectsPage2;
  OpenAI3.Images = Images2;
  OpenAI3.Audio = Audio2;
  OpenAI3.Moderations = Moderations2;
  OpenAI3.Models = Models2;
  OpenAI3.ModelsPage = ModelsPage2;
  OpenAI3.FineTuning = FineTuning2;
  OpenAI3.FineTunes = FineTunes2;
  OpenAI3.FineTunesPage = FineTunesPage2;
  OpenAI3.Beta = Beta2;
})(OpenAI2 || (OpenAI2 = {}));
var openai_default = OpenAI2;

// src/utils.ts
var url_affinity_organizations = "https://api.affinity.co/organizations";
var url_affinity_note = "https://api.affinity.co/notes";
var url_affinity_persons = "https://api.affinity.co/persons";
var url_affinity_field_values = "https://api.affinity.co/field-values";
var url_affinity_list = "https://api.affinity.co/lists";
function affinity_authorization(affinityAPIKey2) {
  let username = "";
  let pwd = affinityAPIKey2;
  let auth = "Basic " + Buffer.from(username + ":" + pwd).toString("base64");
  let headers = { Authorization: auth, "Content-Type": "application/json" };
  return headers;
}
async function add_notes_to_company(startup, note, affinityAPIKey2) {
  let headers = affinity_authorization(affinityAPIKey2);
  let organization_ids = [startup["id"]];
  console.log(organization_ids);
  console.log(note);
  let note_data = { organization_ids: [startup["id"]], content: note };
  let r = await (0, import_obsidian.request)({
    url: url_affinity_note,
    method: "POST",
    headers,
    body: JSON.stringify(note_data),
  })
    .then((data) => console.log(data))
    .catch((error) => {
      console.error(error);
      if (error) {
        return null;
      }
    });
  return "Success";
}
async function get_startup_by_name(
  affinityAPIKey2,
  owner_value2,
  startup_name
) {
  let subnames = startup_name.split(" ");
  let search_term = subnames[0];
  if (subnames.length > 1) {
    for (let name of subnames.slice(1)) {
      search_term = search_term + "+" + name;
    }
  }
  console.log(search_term);
  let next_page_token = null;
  let headers = affinity_authorization(affinityAPIKey2);
  while (true) {
    let full_url =
      url_affinity_organizations +
      "?term=" +
      search_term +
      "&with_interaction_dates=true&with_interaction_persons=true";
    if (next_page_token != null) {
      full_url += "&page_token=" + next_page_token;
    }
    let r = await (0, import_obsidian.request)({
      url: full_url,
      method: "GET",
      headers,
    });
    let response = JSON.parse(r);
    let organizations = response["organizations"];
    next_page_token = response["next_page_token"];
    for (let organization of organizations) {
      if (organization["interactions"]) {
        for (let [interaction_name, interaction_data] of Object.entries(
          organization["interactions"]
        )) {
          if (interaction_data) {
            let people_involved = interaction_data["person_ids"].toString();
            if (people_involved.includes(owner_value2)) {
              return organization;
            }
          } else {
            break;
          }
        }
      }
    }
    if (next_page_token == null) {
      return null;
    }
  }
}
async function get_person_by_name(affinityAPIKey2, person_name) {
  let names = person_name.split(" ");
  if (names.length > 1) {
    let next_page_token = null;
    let headers = affinity_authorization(affinityAPIKey2);
    let first_name = names[0];
    let last_name = names[1];
    while (true) {
      let full_url = url_affinity_persons + "?term=" + last_name;
      if (next_page_token != null) {
        full_url += "&page_token=" + next_page_token;
      }
      let r = await (0, import_obsidian.request)({
        url: full_url,
        method: "GET",
        headers,
      });
      let response = JSON.parse(r);
      let people = response["persons"];
      next_page_token = response["next_page_token"];
      for (let person of people) {
        if (
          person["first_name"] == first_name &&
          person["last_name"] == last_name
        ) {
          return person;
        }
      }
      if (next_page_token == null) {
        break;
      }
    }
    return null;
  } else {
    return null;
  }
  return null;
}
async function get_person_details(affinityAPIKey2, person_id) {
  let full_url = url_affinity_persons + "/" + person_id.toString();
  let headers = affinity_authorization(affinityAPIKey2);
  let r = await (0, import_obsidian.request)({
    url: full_url,
    method: "GET",
    headers,
  });
  let response = JSON.parse(r);
  return response;
}
async function is_person_in_venture_network(
  affinityAPIKey2,
  person_details,
  venture_network_list_id
) {
  let list_entries = person_details["list_entries"];
  for (let entry of list_entries) {
    if (entry["list_id"].toString() == venture_network_list_id.toString()) {
      return entry["id"];
    }
  }
  return null;
}
async function add_entry_to_list(affinityAPIKey2, list_id, entity_id) {
  let headers = affinity_authorization(affinityAPIKey2);
  let full_url = url_affinity_list + "/" + list_id + "/list-entries";
  let data = { entity_id };
  let r = await (0, import_obsidian.request)({
    url: full_url,
    method: "POST",
    headers,
    body: JSON.stringify(data),
  })
    .then((data2) => console.log(data2))
    .catch((error) => {
      console.error(error);
      if (error) {
        return null;
      }
    });
  return "Success";
}
async function add_field_value(
  affinityAPIKey2,
  field_id,
  entity_id,
  value,
  list_entry_id
) {
  let headers = affinity_authorization(affinityAPIKey2);
  let full_url = url_affinity_field_values;
  let data = {
    field_id,
    entity_id,
    value,
    list_entry_id,
  };
  let r = await (0, import_obsidian.request)({
    url: full_url,
    method: "POST",
    headers,
    body: JSON.stringify(data),
  })
    .then((data2) => console.log(data2))
    .catch((error) => {
      console.error(error);
      if (error) {
        return null;
      }
    });
  return "Success";
}
async function add_notes_to_person(affinityAPIKey2, person_id, notes) {
  let full_url = url_affinity_note;
  let headers = affinity_authorization(affinityAPIKey2);
  let data = { person_ids: [person_id], content: notes };
  let r = await (0, import_obsidian.request)({
    url: full_url,
    method: "POST",
    headers,
    body: JSON.stringify(data),
  })
    .then((data2) => console.log(data2))
    .catch((error) => {
      console.error(error);
      if (error) {
        return null;
      }
    });
  return "Success";
}
function startup_ready_for_affinity(file_content) {
  return (
    file_content.includes("#startups/screened") &&
    file_content.includes("#Affinity")
  );
}
function extract_title_and_note(text) {
  let pattern = /^# .*\n/gm;
  let matches = text.match(pattern);
  let title = "";
  if (matches) {
    title = matches[0];
  }
  let substrings = text.split(pattern);
  console.log(`Title: ${title}`);
  console.log(substrings);
  return [title, substrings];
}
function clean_text(startup_name) {
  startup_name = startup_name.replace(/[^A-Za-z0-9\s.]/g, "");
  startup_name = startup_name.trim();
  return startup_name;
}
function is_summarizable(file_content) {
  return (
    file_content.includes("#network/connected") &&
    (file_content.includes("#Entity/VC") ||
      file_content.includes("#Person/VC")) &&
    file_content.includes("#gpt_summarized") != true &&
    file_content.includes("dataview") != true
  );
}
function vc_ready_for_affinity(file_content) {
  return (
    file_content.includes("#gpt_summarized") &&
    file_content.includes("#Affinity")
  );
}
function countWords(str3) {
  let words = str3.match(/\b[a-z\d]+\b/gi);
  return words ? words.length : 0;
}
function extract_startup_details(startup) {
  let startup_details = {};
  startup_details["name"] = startup["name"];
  startup_details["domain"] = startup["domain"];
  try {
    startup_details["description"] = startup["description"]["long"];
  } catch (e) {
    startup_details["description"] = startup["description"]["short"];
  }
  startup_details["totalMoneyRaised"] = startup["totalMoneyRaised"];
  startup_details["foundedYear"] = startup["foundedYear"];
  startup_details["location"] = startup["location"];
  startup_details["stage"] = startup["stage"];
  startup_details["investorList"] = startup["investorList"];
  startup_details["profileLinks"] = startup["profileLinks"];
  startup_details["newsInfo"] = startup["newsInfo"];
  startup_details["metrics"] = startup["metrics"];
  startup_details["tracxnTeamScore"] = startup["tracxnTeamScore"];
  startup_details["tracxnScore"] = startup["tracxnScore"];
  return startup_details;
}
function get_acquisition_details(startup) {
  let acquirersString = "";
  let acquirers = startup["acquirerInfo"]["acquirerList"][0]["acquirers"];
  let acquisitionYear =
    startup["acquirerInfo"]["acquirerList"][0]["date"]["year"];
  let counter = 0;
  for (let acquirer of acquirers) {
    if (counter == 0) {
      acquirersString += `[${acquirer["name"]}](${acquirer["domain"]})`;
    } else {
      acquirersString += `, [${acquirer["name"]}](${acquirer["domain"]})`;
    }
    counter += 1;
  }
  return { Acquirers: acquirersString, AcquisitionYear: acquisitionYear };
}
function get_ipo_details(startup) {
  let result = {};
  let ipoList = startup["ipoInfo"]["ipoList"];
  for (let ipo of ipoList) {
    if (ipo["marketCap"]) {
      result["marketCap"] = ipo["marketCap"];
      result["ipoYear"] = ipo["date"]["year"];
      result["stockExchange"] = ipo["stockExchange"];
      result["stockSymbol"] = ipo["stockSymbol"];
    }
  }
  return result;
}
function get_keys_for_table(allKeys) {
  const excludedKeys = ["newsInfo", "metrics", "domain"];
  let finalKeys = [];
  for (let key of allKeys) {
    if (!excludedKeys.includes(key)) {
      finalKeys.push(key);
    }
  }
  return finalKeys;
}
function formatNumber(number) {
  const abbreviations = {
    T: 1e12,
    B: 1e9,
    M: 1e6,
    K: 1e3,
  };
  for (const abbreviation in abbreviations) {
    if (number >= abbreviations[abbreviation]) {
      const roundedNumber = Math.ceil(number / abbreviations[abbreviation]);
      return roundedNumber + abbreviation;
    }
  }
  return number.toString();
}
function formattedCountryName(countryName) {
  const formattedCountryName2 =
    countryName.charAt(0).toUpperCase() + countryName.slice(1).toLowerCase();
  return formattedCountryName2;
}
function isCountryInEurope(countryName) {
  const europeanCountries = [
    "Albania",
    "Andorra",
    "Austria",
    "Belarus",
    "Belgium",
    "Bosnia and Herzegovina",
    "Bulgaria",
    "Croatia",
    "Cyprus",
    "Czech Republic",
    "Denmark",
    "Estonia",
    "Finland",
    "France",
    "Germany",
    "Greece",
    "Hungary",
    "Iceland",
    "Ireland",
    "Italy",
    "Kosovo",
    "Latvia",
    "Liechtenstein",
    "Lithuania",
    "Luxembourg",
    "Malta",
    "Moldova",
    "Monaco",
    "Montenegro",
    "Netherlands",
    "North Macedonia",
    "Norway",
    "Poland",
    "Portugal",
    "Romania",
    "Russia",
    "San Marino",
    "Serbia",
    "Slovakia",
    "Slovenia",
    "Spain",
    "Sweden",
    "Switzerland",
    "Ukraine",
    "United Kingdom",
    "UK",
    "Vatican City",
  ];
  return europeanCountries.includes(formattedCountryName(countryName));
}
function isCountryInEasternEurope(countryName) {
  const easternEuropeanCountries = [
    "Albania",
    "Belarus",
    "Bosnia and Herzegovina",
    "Bulgaria",
    "Croatia",
    "Cyprus",
    "Czech Republic",
    "Estonia",
    "Hungary",
    "Kosovo",
    "Latvia",
    "Lithuania",
    "Moldova",
    "Montenegro",
    "North Macedonia",
    "Poland",
    "Romania",
    "Russia",
    "Serbia",
    "Slovakia",
    "Slovenia",
    "Ukraine",
  ];
  return easternEuropeanCountries.includes(formattedCountryName(countryName));
}
function isCountryInNordics(countryName) {
  const nordicCountries = ["Denmark", "Finland", "Iceland", "Norway", "Sweden"];
  return nordicCountries.includes(formattedCountryName(countryName));
}
function geo_check(input_country, investor_geo) {
  input_country = input_country.toLowerCase();
  let usa_abbreviations = [
    "usa",
    "us",
    "united states",
    "america",
    "united states of america",
  ];
  if (
    investor_geo.some((geo) => geo.includes("globally")) ||
    investor_geo.some((geo) => geo.includes("agnostic")) ||
    investor_geo.some((geo) => geo.includes("world-wide"))
  ) {
    return true;
  }
  if (investor_geo.some((geo) => geo.includes(input_country))) {
    return true;
  }
  if (
    isCountryInEurope(input_country) &&
    (investor_geo.some((geo) => geo.includes("europe")) ||
      investor_geo.some((geo) => geo.includes("eu")))
  ) {
    return true;
  }
  if (
    isCountryInEasternEurope(input_country) &&
    investor_geo.some((geo) => geo.includes("eastern europe"))
  ) {
    return true;
  }
  if (
    isCountryInNordics(input_country) &&
    investor_geo.some((geo) => geo.includes("nordics"))
  ) {
    return true;
  }
  if (usa_abbreviations.includes(input_country)) {
    for (let geo of investor_geo) {
      if (usa_abbreviations.some((abbrev) => geo.includes(abbrev))) {
        return true;
      }
    }
  }
  return false;
}
function stage_check(input_stage, investor_stage) {
  input_stage = input_stage.toLowerCase();
  if (
    investor_stage.some((stage) => stage.includes("pre-seed")) ||
    investor_stage.some((stage) => stage.includes("preseed"))
  ) {
    investor_stage.push("pre-seed");
    investor_stage.push("preseed");
  }
  return investor_stage.some((stage) => stage.includes(input_stage));
}
function formatObjectsToMarkdownTable(objects, specialFormat) {
  if (objects.length === 0) {
    return "";
  }
  let keys = [];
  if (specialFormat) {
    keys = get_keys_for_table(Object.keys(objects[0]));
  } else {
    keys = Object.keys(objects[0]);
  }
  let table = "|";
  for (let i = 0; i < keys.length; i++) {
    table += ` ${keys[i]} |`;
  }
  table += "\n|";
  for (let i = 0; i < keys.length; i++) {
    table += " --- |";
  }
  for (let i = 0; i < objects.length; i++) {
    table += "\n|";
    for (let j = 0; j < keys.length; j++) {
      let displayedResult = "";
      try {
        if (keys[j] == "totalMoneyRaised") {
          displayedResult =
            formatNumber(objects[i][keys[j]]["totalAmount"]["amount"]) +
            " " +
            objects[i][keys[j]]["totalAmount"]["currency"];
        } else if (keys[j] == "investorList") {
          let investorListDisplay = "";
          let counter = 0;
          for (let investor of objects[i]["investorList"]) {
            let investorDisplay = `[${investor["name"]}](https://${investor["domain"]})`;
            if (counter == 0) {
              investorListDisplay += investorDisplay;
            } else {
              investorListDisplay += ", " + investorDisplay;
            }
            counter += 1;
          }
          displayedResult = investorListDisplay;
        } else if (keys[j] == "location") {
          displayedResult = objects[i]["location"]["country"];
        } else if (keys[j] == "tracxnTeamScore" || keys[j] == "tracxnScore") {
          displayedResult = Math.ceil(objects[i][keys[j]]).toFixed(0);
        } else if (keys[j] == "profileLinks") {
          let counter = 0;
          for (let [type, link] of Object.entries(objects[i]["profileLinks"])) {
            if (counter == 0) {
              displayedResult += `[${type}](${link})`;
            } else {
              displayedResult += `, [${type}](${link})`;
            }
            counter += 1;
          }
        } else if (keys[j] == "name") {
          let domain = objects[i]["domain"];
          displayedResult = `[${objects[i]["name"]}](https://${domain})`;
        } else if (keys[j] == "marketCap") {
          displayedResult =
            formatNumber(objects[i]["marketCap"]["amount"]) +
            " " +
            objects[i]["marketCap"]["currency"];
        } else {
          displayedResult = objects[i][keys[j]];
        }
      } catch (e) {
        console.error(
          `${objects[i]["name"]} had an error with the key ${keys[j]}`
        );
      }
      table += ` ${displayedResult} |`;
    }
  }
  return table;
}
function get_relevant_feeds(startupsList) {
  let relevant_feeds = {};
  for (let startup of startupsList) {
    let businessModels = startup["businessModelList"];
    for (let businessModel of businessModels) {
      relevant_feeds[businessModel["fullPathString"]] =
        businessModel["companiesInEntireTreeUrl"];
    }
  }
  return relevant_feeds;
}
function find_eligible_investors(investors, input_country, input_stage) {
  let fit_investors = [];
  for (let investor of investors) {
    if (
      geo_check(input_country, investor["geo"]) &&
      stage_check(input_stage, investor["stage"])
    ) {
      fit_investors.push(investor);
    }
  }
  return fit_investors;
}
function extractStage(str3) {
  str3 = str3.toLowerCase();
  const keywords = [
    "pre-seed",
    "preseed",
    "seed",
    "series a",
    "series b",
    "series c",
    "series d",
  ];
  const regex = new RegExp(keywords.join("|"), "gi");
  const mentions = str3.match(regex) || [""];
  return mentions;
}
function extractGeography(str3) {
  const regex = /Geography::(.*)/i;
  const match = str3.match(regex);
  if (match) {
    let line = match[1].trim();
    let geos = line.split(",");
    let counter = 0;
    for (let geo of geos) {
      geos[counter] = geo.trim().toLowerCase();
      counter += 1;
    }
    return geos;
  }
  return [""];
}
function extractIndustry(str3) {
  const regex = /Industry::(.*)/i;
  const match = str3.match(regex);
  if (match) {
    let industry = match[1].trim();
    return industry;
  }
  return [""];
}
function extractSpeciality(str3) {
  const regex = /Special::?(.*)/i;
  const match = str3.match(regex);
  if (match) {
    let industry = match[1].trim();
    return industry;
  }
  return "";
}
async function togetherai_js(
  togetheraiAPIKey2,
  model_name,
  user_prompt,
  system_prompt,
  max_tokens = 256,
  temperature = 0.3,
  messages = []
) {
  let togetherai = new openai_default({
    apiKey: togetheraiAPIKey2,
    dangerouslyAllowBrowser: true,
    baseURL: "https://api.together.xyz/v1",
  });
  var response;
  if (messages.length == 0) {
    response = await togetherai.chat.completions.create({
      model: model_name,
      temperature: 0,
      top_p: 0,
      max_tokens,
      messages: [
        { role: "system", content: system_prompt },
        { role: "user", content: user_prompt },
      ],
    });
  } else {
    response = await togetherai.chat.completions.create({
      model: model_name,
      temperature: 0,
      top_p: 0,
      max_tokens,
      messages,
    });
  }
  let summary = response.choices[0].message.content;
  if (summary == null) {
    summary = "";
  }
  return summary;
}
function createInvestorObject(name, geographies, stages, industry, speciality) {
  const investorObject = {
    name,
    geo: geographies,
    stage: stages,
    industry,
    speciality,
  };
  return investorObject;
}
function generate_investor_json(investor_name, investor_text) {
  let name = investor_name;
  let geographies = extractGeography(investor_text);
  let stages = extractStage(investor_text);
  let industry = extractIndustry(investor_text);
  let speciality = extractSpeciality(investor_text);
  return createInvestorObject(name, geographies, stages, industry, speciality);
}

// src/modal.ts
var import_obsidian2 = require("obsidian");
var TextInputModal = class extends import_obsidian2.Modal {
  constructor(app2, type, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
    this.type = type;
  }
  onOpen() {
    const { contentEl } = this;
    let title = "";
    if (this.type == "market-research") {
      title = "What industry do you want to research?";
    }
    if (this.type == "defensibility") {
      title = "Describe the startup whose defensibility is to be evaluated";
    }
    if (this.type == "evaluate") {
      title = "Describe the startup to be evaluated";
    }
    if (this.type == "url-research") {
      title = "Enter url to investigate";
    }
    if (this.type == "fireflies-summary") {
      title =
        "Insert the name of the fireflies recording/meeting you would like to summarize";
    }
    if (this.type == "competition") {
      title = "Describe the startup or industry for competition research";
    }
    contentEl.createEl("h2", { text: title });
    const inputEl = contentEl.createEl("textarea");
    inputEl.addEventListener("input", (event) => {
      event.stopPropagation();
    });
    const submitButton = contentEl.createEl("button", { text: "Submit" });
    submitButton.style.position = "absolute";
    submitButton.style.bottom = "0";
    submitButton.style.right = "0";
    submitButton.addEventListener("click", () => {
      this.onsubmit(inputEl.value);
      this.close();
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var MultipleTextInputModal = class extends import_obsidian2.Modal {
  constructor(app2, type, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
    this.type = type;
  }
  onOpen() {
    const { contentEl } = this;
    let title = "What topic would you like to research today?";
    contentEl.createEl("h2", { text: title });
    let query = new import_obsidian2.Setting(contentEl)
      .setName("Search Query")
      .addText((text) =>
        text.onChange((value) => {
          this.query = value;
        })
      );
    let web = new import_obsidian2.Setting(contentEl)
      .setName("Website to Search")
      .addText((text) =>
        text.onChange((value) => {
          this.website = value;
        })
      );
    new import_obsidian2.Setting(contentEl)
      .setName("Task to do")
      .addDropdown((menu) => {
        menu.addOption("competition", "Find & Analyze competitors");
        menu.addOption("market-research", "Investor Summary");
        menu.setValue("....");
        menu.onChange((value) => {
          this.task = value;
        });
      });
    let button = new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn
        .setButtonText("Submit")
        .setCta()
        .onClick(() => {
          this.close();
          this.onsubmit(this.website + ", " + this.query + ", " + this.task);
        });
    });
  }
};
var FireFliesTemp = class extends import_obsidian2.Modal {
  constructor(app2, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
  }
  onOpen() {
    const { contentEl } = this;
    let title = "Give me the json string of transcript";
    contentEl.createEl("h2", { text: title });
    let query = new import_obsidian2.Setting(contentEl)
      .setName("Json String")
      .addTextArea((text) =>
        text.onChange((value) => {
          this.json_string = value;
        })
      );
    let web = new import_obsidian2.Setting(contentEl)
      .setName("Meeting name")
      .addText((text) =>
        text.onChange((value) => {
          this.meeting_name = value;
        })
      );
    let button = new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn
        .setButtonText("Submit")
        .setCta()
        .onClick(() => {
          this.close();
          this.onsubmit(this.json_string + "&&& " + this.meeting_name);
        });
    });
  }
};
var SpokeModal = class extends import_obsidian2.Modal {
  constructor(app2, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
    this.isDetailed = false;
  }
  onOpen() {
    const { contentEl } = this;
    let title = "Summarise the call recorded by Spoke.app";
    contentEl.createEl("h2", { text: title });
    new import_obsidian2.Setting(contentEl)
      .setName("Meeting name")
      .addText((text) =>
        text.onChange((value) => {
          this.meeting_name = value;
        })
      );
    new import_obsidian2.Setting(contentEl)
      .setName("Detailed Meeting")
      .addToggle((component) => {
        component.onChange((value) => {
          this.isDetailed = value;
        });
      });
    new import_obsidian2.Setting(contentEl)
      .setName("Model to use")
      .addDropdown((menu) => {
        menu.addOption("openai", "GPT-4-Turbo");
        menu.addOption("meta-llama/Llama-3-8b-chat-hf", "Llama-3-70B");
        menu.setValue("....");
        menu.onChange((value) => {
          this.model = value;
        });
      });
    let button = new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn
        .setButtonText("Submit")
        .setCta()
        .onClick(() => {
          this.close();
          this.onsubmit(
            this.meeting_name + ", " + this.isDetailed + ", " + this.model
          );
        });
    });
  }
};
var WorkflowModal = class extends import_obsidian2.Modal {
  constructor(app2, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
    this.model_name = "";
  }
  onOpen() {
    const { contentEl } = this;
    let title =
      "Describe the startup you want to analyze and if you want to use Groq";
    contentEl.createEl("h2", { text: title });
    new import_obsidian2.Setting(contentEl)
      .setName("Startup Description")
      .addTextArea((text) =>
        text.onChange((value) => {
          this.desc = value;
        })
      );
    new import_obsidian2.Setting(contentEl)
      .setName("Model to use")
      .addDropdown((menu) => {
        menu.addOption("openai", "GPT-4-Turbo");
        menu.addOption("meta-llama/Llama-3-8b-chat-hf", "Llama-3-70B");
        menu.addOption("groq", "Groq");
        menu.setValue("....");
        menu.onChange((value) => {
          this.model_name = value;
        });
      });
    let button = new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn
        .setButtonText("Submit")
        .setCta()
        .onClick(() => {
          this.close();
          this.onsubmit(this.desc + "//-- " + this.model_name);
        });
    });
  }
};
var FindInvestorModal = class extends import_obsidian2.Modal {
  constructor(app2, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
    this.isFocused = false;
  }
  onOpen() {
    const { contentEl } = this;
    let title = "Describe the startup you want to find investors for";
    contentEl.createEl("h2", { text: title });
    let query = new import_obsidian2.Setting(contentEl)
      .setName("Startup Description")
      .addTextArea((text) =>
        text.onChange((value) => {
          this.company = value;
        })
      );
    let web = new import_obsidian2.Setting(contentEl)
      .setName("Stage")
      .setDesc("e.g, Preseed, Seed, etc")
      .addText((text) =>
        text.onChange((value) => {
          this.stage = value;
        })
      );
    new import_obsidian2.Setting(contentEl)
      .setName("Location")
      .setDesc("insert the country where the startup is located")
      .addText((text) =>
        text.onChange((value) => {
          this.location = value;
        })
      );
    new import_obsidian2.Setting(contentEl)
      .setName("Do you want to focus the search on strong connections?")
      .addToggle((component) => {
        component.onChange((value) => {
          this.isFocused = value;
        });
      });
    let button = new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn
        .setButtonText("Submit")
        .setCta()
        .onClick(() => {
          this.close();
          this.onsubmit(
            this.company +
              ", " +
              this.stage +
              ", " +
              this.location +
              ", " +
              this.isFocused
          );
        });
    });
  }
};
var PDFModal = class extends import_obsidian2.FuzzySuggestModal {
  constructor(app2, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
  }
  getItems() {
    return this.app.vault
      .getFiles()
      .filter((file) => file.extension.includes("pdf"));
  }
  getItemText(file) {
    return file.name;
  }
  onChooseItem(file, evt) {
    this.onsubmit(file.path);
  }
};
var TracxnModal = class extends import_obsidian2.Modal {
  constructor(app2, onsubmit) {
    super(app2);
    this.onsubmit = onsubmit;
    this.isIPO = false;
    this.isAcquired = false;
    this.companies_per_request = "3";
  }
  onOpen() {
    const { contentEl } = this;
    let title = "Competitor Overview through Tracxn";
    contentEl.createEl("h2", { text: title });
    contentEl.createEl("h5", {
      text: "IPO and Acquisition are mutually exclusive",
    });
    let query = new import_obsidian2.Setting(contentEl)
      .setName("Company Domain")
      .setDesc("e.g: tracxn.com. Do not add http://")
      .addText((text) =>
        text.onChange((value) => {
          this.company = value;
        })
      );
    let ipo = new import_obsidian2.Setting(contentEl)
      .setName("IPOed competitors?")
      .addToggle((component) => {
        component.onChange((value) => {
          this.isIPO = value;
        });
      });
    let acquired = new import_obsidian2.Setting(contentEl)
      .setName("Acquired competitors?")
      .addToggle((component) => {
        component.onChange((value) => {
          this.isAcquired = value;
        });
      });
    new import_obsidian2.Setting(contentEl)
      .setName("Number of companies per request")
      .addText((text) =>
        text.onChange((value) => (this.companies_per_request = value))
      );
    let button = new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn
        .setButtonText("Submit")
        .setCta()
        .onClick(() => {
          this.close();
          this.onsubmit(
            this.company +
              ", " +
              this.isIPO +
              ", " +
              this.isAcquired +
              ", " +
              this.companies_per_request
          );
        });
    });
  }
};

// src/main.ts
var fs = __toESM(require("fs"));

// src/formatter.js
function format_url_text(final_text, url) {
  final_text =
    `## ${url} Research
` + final_text;
  final_text = final_text.replace(
    "Problem to be solved:",
    "#### Problem to be solved"
  );
  final_text = final_text.replace("Product:", "#### Product");
  final_text = final_text.replace("Features:", "#### Features");
  final_text = final_text.replace("Business Model:", "#### Business Model");
  final_text = final_text.replace("Competition:", "#### Competition");
  final_text = final_text.replace("Vision:", "#### Vision");
  final_text = final_text.replace("Extras:", "#### Extras");
  return final_text;
}

// src/search.ts
var import_obsidian3 = require("obsidian");
async function specific_web_research(
  task,
  website,
  search_query,
  openai2,
  editor
) {
  let presentation_prompt = "Summarize the following paragraphs.";
  let title = "New Section";
  if (task.toLowerCase() == "competition") {
    title = "Competition Research";
    presentation_prompt = `Highlight the most important facts for an investor from the following paragraphs. If there are none, say "Nothing". Otherwise always respond in the following format: 
            - Problems to be solved
            - Product and Technology
            - Money raised
            - Team
            - Other important points`;
  } else if (task.toLowerCase() == "market-research") {
    title = "Market Research";
    let industry = search_query.split("industry market")[0];
    presentation_prompt = `What facts about the ${industry} market can an investor learn from the following paragraphs? If there are no facts to learn simply output "Nothing"`;
  }
  let message = await execute_search_task(
    title,
    website,
    search_query,
    presentation_prompt,
    openai2,
    editor
  );
  return message;
}
async function execute_search_task(
  task,
  website,
  search_query,
  presentation_prompt,
  openai2,
  editor
) {
  try {
    let website_name = "";
    if (website == "") {
      website_name = "general research";
    } else {
      website_name = website.split(".")[0];
    }
    let message = `#### ${task} through ${website_name}
`;
    let summaries = [];
    let sources = [];
    let query = `site:${website} ${search_query}`;
    let result = await you_research(query);
    let counter = 0;
    let user_prompt = presentation_prompt;
    for (let element of result) {
      let snippets = element["snippets"];
      let title = element["title"];
      let url = element["url"];
      let summary = "";
      let paragraphs = snippets;
      paragraphs[0] = "- " + paragraphs[0];
      let string_paragraphs = paragraphs.join("\n\n- ");
      if (string_paragraphs && string_paragraphs.length > 1) {
        const response = await openai2.chat.completions.create({
          model: gpt_3_latest,
          messages: [
            {
              role: "system",
              content:
                "Act as an investigative journalist who is obsessed with the truth and accuracy. You always give answers in bullet points.",
            },
            {
              role: "user",
              content:
                `${user_prompt}
Paragraphs:
` + string_paragraphs,
            },
          ],
          temperature: 0,
          max_tokens: 1024,
          top_p: 1,
          frequency_penalty: 0,
          presence_penalty: 0,
        });
        summary += response.choices[0].message.content + "\n";
      }
      summaries.push(summary);
      let source = `[${title}](${url})`;
      sources.push(source);
      counter++;
      if (counter == 5) {
        break;
      }
    }
    for (let i = 0; i < summaries.length; i++) {
      message += `##### ${sources[i]}
`;
      message += summaries[i] + "\n\n";
    }
    return message;
  } catch (error) {
    console.log(`Error while doing research: ${error}`);
    new import_obsidian3.Notice(`Error while doing research`);
  }
  return "";
}
async function you_research(query) {
  let results = await (0, import_obsidian3.request)({
    url: `https://you-researcher-container-xm5lmdnsxq-uc.a.run.app/search?query=${query}`,
    method: "GET",
  });
  return await JSON.parse(results)["hits"];
}

// src/prompts.js
var DEFENSIBILITY_ANALYSIS_SYSTEM_PROMPT =
  "Use the following guidelines to determine what kinds of defensibility a startup can build with time:\n- **Network effect**: When every user creates more value for other users, forming a positive feedback loop. This can be local or global, and is one of the few forms of defensibility that can arise immediately upon launch of a company.\n- **Platform effect**: When a company becomes a sticky product because so many other companies have integrated against it. This usually comes after a company has enough users that others want to build against its platform to reach them.\n- **Integrations**: When a company integrates against many other APIs, code bases, etc. that are hard to reproduce, or when a company's services do integrations for the company against other vendors. This makes it hard to displace the company as each implementation is a unique and complex process.\n- **Building a ton of stuff**: When a company bundles and cross sells products that prevent other companies from finding a wedge to compete with them, or when a company has a big product footprint that makes it hard for new entrants to reach feature parity.\n- **Deals**: When a company secures early access, exclusive provider or distribution, or backend deals that give it scale, brand, or access advantages over competitors. This may include deals with APIs, data sources, regulators, or customers.\n- **Sales as moat**: When a company locks in customers with long term contracts, or has a sales process that makes it easier for enterprises to buy from them than from new suppliers. This may include security reviews, procurement processes, or pricing strategies.\n- **Regulatory**: When a company receives regulatory approvals that provide a moat. This may include licenses, permits, or exemptions that are hard to obtain or replicate by competitors.\n- **Data or system of record effect**: When a company has unique or proprietary data, or owns a customer's data or has a long historical record of it. This can create defensibility by making the data more valuable and harder to switch away from. Similarly, being a system of record for a user, entity, etc. can be a powerful position to be in.\n- **Scale effects**: When a company has access to large sums of money or business volume that allows it to do things that will make it difficult for competitors to upend them. This may include capital scale, business scale and negotiation, or pricing advantages.\n- **Open source**: When a company benefits from being the creator or contributor of an open source software project that is widely used or adopted by developers. This can create defensibility by giving the company brand recognition, community influence, and talent access.\n- **Brand**: When a company becomes synonymous with the thing they do, often by creating a new product category, or doing something vastly better than competitors. This can create defensibility by making the company the default choice for customers and creating loyalty and trust.\n- **IP moat**: When a company has intellectual property that protects its product or technology from being copied or infringed by competitors. This tends to be more effective in hard tech or biotech companies than most consumer or SaaS products.\n- **Speed**: When a company can execute faster and better than competitors, especially incumbents. This can create defensibility by allowing the company to iterate quickly, respond to customer feedback, and hire and close candidates faster.\n- **Pricing**: When a company can offer a lower price than competitors due to a lower cost structure, a lack of an existing product to cannibalize, or a different business model. This can create defensibility by attracting more customers and creating higher margins.\n- **New business models**: When a company can innovate on business model to create a higher leverage business or different incentive structure. This can create defensibility by disrupting incumbents who are used to traditional ways of doing things.\nAlways think step by step!";
var GUIDANCE_WORKFLOW_SYSTEM_PROMPT =
  "You are a helpful assistant to a venture capital investor. Your main job is guiding the investor to always focus on the bigger picture and find the core arguments they should focus us. Your arguments are always concise and to the point. When needed, you can guide the investor by asking questions that help them focus on the essentials.\nIn your analysis, you should always be customer-centric and focused on the target customer of the startup.\nThe following aspects are extremely crucial to the investor:\n- Who is the target customer for the startup?\n- What is the hardest part about the job of the target customer?\n- What is the startup's unique value proposition for the target customer?";

// src/fireflies.ts
async function get_meeting_id(meeting_name, fireflies_api_key2) {
  let meetings = await fetch("https://api.fireflies.ai/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${fireflies_api_key2}`,
    },
    body: JSON.stringify({
      query: `
            query {
                transcripts {
                    id
                    title
                    fireflies_users
                    participants
                    date
                    transcript_url
                    duration
                }
            }
        `,
    }),
  })
    .then((result) => {
      return result.json();
    })
    .then((result) => {
      return result.data;
    });
  let meetings_list = meetings["transcripts"];
  let meeting_id = "";
  for (let meeting of meetings_list) {
    if (meeting["title"] == meeting_name) {
      meeting_id = meeting["id"];
      break;
    }
  }
  return meeting_id;
}
async function get_meeting_transcript_by_id(id, investor_names2, api_key) {
  let transcript = await fetch("https://api.fireflies.ai/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${api_key}`,
    },
    body: JSON.stringify({
      query: `
              query {
                transcript(id: "${id}"){ title date sentences {text speaker_name} }
              }
          `,
    }),
  })
    .then((result) => {
      return result.json();
    })
    .then((result) => {
      return result.data;
    });
  let current_sentence = "";
  let useful_paragraphs = [];
  let current_speaker =
    transcript["transcript"]["sentences"][0]["speaker_name"];
  for (let sentence of transcript["transcript"]["sentences"]) {
    if (sentence["speaker_name"] == current_speaker) {
      current_sentence += sentence["text"];
    } else {
      if (current_sentence.length != 0) {
        if (investor_names2.includes(current_speaker)) {
          current_speaker += " (Investor)";
          console.log(current_speaker);
        } else {
          current_speaker += " (Founder)";
        }
        current_sentence = current_speaker + ": " + current_sentence + "\n";
        useful_paragraphs.push(current_sentence);
        current_sentence = sentence["text"];
        current_speaker = sentence["speaker_name"];
      }
    }
  }
  if (current_sentence.length != 0) {
    useful_paragraphs.push(current_sentence);
  }
  return useful_paragraphs;
}
async function transcript_json_to_array_string(
  transcript_json_string,
  investor_names2
) {
  let json = JSON.parse(transcript_json_string);
  let transcript = json["data"];
  let current_sentence = "";
  let useful_paragraphs = [];
  let current_speaker =
    transcript["transcript"]["sentences"][0]["speaker_name"];
  for (let sentence of transcript["transcript"]["sentences"]) {
    if (sentence["speaker_name"] == current_speaker) {
      current_sentence += sentence["text"];
    } else {
      if (current_sentence.length != 0) {
        if (investor_names2.includes(current_speaker)) {
          current_speaker += " (Investor)";
          console.log(current_speaker);
        } else {
          current_speaker += " (Founder)";
        }
        current_sentence = current_speaker + ": " + current_sentence + "\n";
        useful_paragraphs.push(current_sentence);
        current_sentence = sentence["text"];
        current_speaker = sentence["speaker_name"];
      }
    }
  }
  if (current_sentence.length != 0) {
    useful_paragraphs.push(current_sentence);
  }
  return useful_paragraphs;
}

// node_modules/groq-sdk/version.mjs
var VERSION3 = "0.3.3";

// node_modules/groq-sdk/_shims/registry.mjs
var auto3 = false;
var kind3 = void 0;
var fetch4 = void 0;
var Request4 = void 0;
var Response4 = void 0;
var Headers4 = void 0;
var FormData4 = void 0;
var Blob4 = void 0;
var File4 = void 0;
var ReadableStream4 = void 0;
var getMultipartRequestOptions3 = void 0;
var getDefaultAgent3 = void 0;
var fileFromPath3 = void 0;
var isFsReadStream3 = void 0;
function setShims3(shims, options = { auto: false }) {
  if (auto3) {
    throw new Error(
      `you must \`import 'groq-sdk/shims/${shims.kind}'\` before importing anything else from groq-sdk`
    );
  }
  if (kind3) {
    throw new Error(
      `can't \`import 'groq-sdk/shims/${shims.kind}'\` after \`import 'groq-sdk/shims/${kind3}'\``
    );
  }
  auto3 = options.auto;
  kind3 = shims.kind;
  fetch4 = shims.fetch;
  Request4 = shims.Request;
  Response4 = shims.Response;
  Headers4 = shims.Headers;
  FormData4 = shims.FormData;
  Blob4 = shims.Blob;
  File4 = shims.File;
  ReadableStream4 = shims.ReadableStream;
  getMultipartRequestOptions3 = shims.getMultipartRequestOptions;
  getDefaultAgent3 = shims.getDefaultAgent;
  fileFromPath3 = shims.fileFromPath;
  isFsReadStream3 = shims.isFsReadStream;
}

// node_modules/groq-sdk/_shims/MultipartBody.mjs
var MultipartBody3 = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/groq-sdk/_shims/web-runtime.mjs
function getRuntime3({ manuallyImported } = {}) {
  const recommendation = manuallyImported
    ? `You may need to use polyfills`
    : `Add one of these imports before your first \`import \u2026 from 'groq-sdk'\`:
- \`import 'groq-sdk/shims/node'\` (if you're running on Node)
- \`import 'groq-sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(
      `this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`
    );
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData:
      typeof FormData !== "undefined"
        ? FormData
        : class FormData {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`
              );
            }
          },
    Blob:
      typeof Blob !== "undefined"
        ? Blob
        : class Blob {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`
              );
            }
          },
    File:
      typeof File !== "undefined"
        ? File
        : class File {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`
              );
            }
          },
    ReadableStream:
      typeof ReadableStream !== "undefined"
        ? ReadableStream
        : class ReadableStream {
            constructor() {
              throw new Error(
                `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`
              );
            }
          },
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody3(form),
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error(
        "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads"
      );
    },
    isFsReadStream: (value) => false,
  };
}

// node_modules/groq-sdk/_shims/index.mjs
if (!kind3) setShims3(getRuntime3(), { auto: true });

// node_modules/groq-sdk/error.mjs
var error_exports3 = {};
__export(error_exports3, {
  APIConnectionError: () => APIConnectionError5,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError5,
  APIError: () => APIError5,
  APIUserAbortError: () => APIUserAbortError5,
  AuthenticationError: () => AuthenticationError5,
  BadRequestError: () => BadRequestError5,
  ConflictError: () => ConflictError5,
  GroqError: () => GroqError,
  InternalServerError: () => InternalServerError5,
  NotFoundError: () => NotFoundError5,
  PermissionDeniedError: () => PermissionDeniedError5,
  RateLimitError: () => RateLimitError5,
  UnprocessableEntityError: () => UnprocessableEntityError5,
});
var GroqError = class extends Error {};
var APIError5 = class extends GroqError {
  constructor(status, error, message, headers) {
    super(`${APIError5.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message)
      ? typeof error.message === "string"
        ? error.message
        : JSON.stringify(error.message)
      : error
      ? JSON.stringify(error)
      : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError5({ cause: castToError3(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError5(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError5(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError5(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError5(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError5(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError5(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError5(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError5(status, error, message, headers);
    }
    return new APIError5(status, error, message, headers);
  }
};
var APIUserAbortError5 = class extends APIError5 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError5 = class extends APIError5 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause) this.cause = cause;
  }
};
var APIConnectionTimeoutError5 = class extends APIConnectionError5 {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError5 = class extends APIError5 {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError5 = class extends APIError5 {};

// node_modules/groq-sdk/lib/streaming.mjs
var Stream3 = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder3();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new GroqError(
          `Attempted to iterate over a response with no body`
        );
      }
      const lineDecoder = new LineDecoder3();
      const iter = readableStreamAsyncIterable3(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse) yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse) yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
        );
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done) continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError5(void 0, data.error, void 0, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") return;
        throw e;
      } finally {
        if (!done) controller.abort();
      }
    }
    return new Stream3(iterator, controller);
  }
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder3();
      const iter = readableStreamAsyncIterable3(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
        );
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done) continue;
          if (line) yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") return;
        throw e;
      } finally {
        if (!done) controller.abort();
      }
    }
    return new Stream3(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue2) => {
      return {
        next: () => {
          if (queue2.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        },
      };
    };
    return [
      new Stream3(() => teeIterator(left), this.controller),
      new Stream3(() => teeIterator(right), this.controller),
    ];
  }
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream4({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done) return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a4;
        await ((_a4 = iter.return) == null ? void 0 : _a4.call(iter));
      },
    });
  }
};
var SSEDecoder3 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length) return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks,
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition3(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder3 = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder3.NEWLINE_CHARS.has(
      text[text.length - 1] || ""
    );
    let lines = text.split(LineDecoder3.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a4;
    if (bytes == null) return "";
    if (typeof bytes === "string") return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new GroqError(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
      );
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a4 = this.textDecoder) != null
          ? _a4
          : (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new GroqError(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
      );
    }
    throw new GroqError(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
    );
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder3.NEWLINE_CHARS = /* @__PURE__ */ new Set([
  "\n",
  "\r",
  "\v",
  "\f",
  "",
  "",
  "",
  "\x85",
  "\u2028",
  "\u2029",
]);
LineDecoder3.NEWLINE_REGEXP =
  /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition3(str3, delimiter) {
  const index = str3.indexOf(delimiter);
  if (index !== -1) {
    return [
      str3.substring(0, index),
      delimiter,
      str3.substring(index + delimiter.length),
    ];
  }
  return [str3, "", ""];
}
function readableStreamAsyncIterable3(stream) {
  if (stream[Symbol.asyncIterator]) return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done) reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}

// node_modules/groq-sdk/uploads.mjs
var isResponseLike3 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.url === "string" &&
  typeof value.blob === "function";
var isFileLike3 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.name === "string" &&
  typeof value.lastModified === "number" &&
  isBlobLike3(value);
var isBlobLike3 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value.size === "number" &&
  typeof value.type === "string" &&
  typeof value.text === "function" &&
  typeof value.slice === "function" &&
  typeof value.arrayBuffer === "function";
var isUploadable3 = (value) => {
  return isFileLike3(value) || isResponseLike3(value) || isFsReadStream3(value);
};
async function toFile4(value, name, options = {}) {
  var _a4, _b, _c;
  value = await value;
  if (isResponseLike3(value)) {
    const blob = await value.blob();
    name ||
      (name =
        (_a4 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null
          ? _a4
          : "unknown_file");
    return new File4([blob], name, options);
  }
  const bits = await getBytes3(value);
  name || (name = (_b = getName3(value)) != null ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File4(bits, name, options);
}
async function getBytes3(value) {
  var _a4;
  let parts = [];
  if (
    typeof value === "string" ||
    ArrayBuffer.isView(value) ||
    value instanceof ArrayBuffer
  ) {
    parts.push(value);
  } else if (isBlobLike3(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator3(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${
        (_a4 = value == null ? void 0 : value.constructor) == null
          ? void 0
          : _a4.name
      }; props: ${propsForError3(value)}`
    );
  }
  return parts;
}
function propsForError3(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName3(value) {
  var _a4;
  return (
    getStringFromMaybeBuffer3(value.name) ||
    getStringFromMaybeBuffer3(value.filename) ||
    ((_a4 = getStringFromMaybeBuffer3(value.path)) == null
      ? void 0
      : _a4.split(/[\\/]/).pop())
  );
}
var getStringFromMaybeBuffer3 = (x) => {
  if (typeof x === "string") return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer) return String(x);
  return void 0;
};
var isAsyncIterableIterator3 = (value) =>
  value != null &&
  typeof value === "object" &&
  typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody3 = (body) =>
  body &&
  typeof body === "object" &&
  body.body &&
  body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions3 = async (opts) => {
  const form = await createForm3(opts.body);
  return getMultipartRequestOptions3(form, opts);
};
var createForm3 = async (body) => {
  const form = new FormData4();
  await Promise.all(
    Object.entries(body || {}).map(([key, value]) =>
      addFormValue3(form, key, value)
    )
  );
  return form;
};
var addFormValue3 = async (form, key, value) => {
  if (value === void 0) return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`
    );
  }
  if (
    typeof value === "string" ||
    typeof value === "number" ||
    typeof value === "boolean"
  ) {
    form.append(key, String(value));
  } else if (isUploadable3(value)) {
    const file = await toFile4(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(
      value.map((entry) => addFormValue3(form, key + "[]", entry))
    );
  } else if (typeof value === "object") {
    await Promise.all(
      Object.entries(value).map(([name, prop]) =>
        addFormValue3(form, `${key}[${name}]`, prop)
      )
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
    );
  }
};

// node_modules/groq-sdk/core.mjs
var __classPrivateFieldSet7 = function (receiver, state, value, kind4, f) {
  if (kind4 === "m") throw new TypeError("Private method is not writable");
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind4 === "a"
      ? f.call(receiver, value)
      : f
      ? (f.value = value)
      : state.set(receiver, value),
    value
  );
};
var __classPrivateFieldGet7 = function (receiver, state, kind4, f) {
  if (kind4 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind4 === "m"
    ? f
    : kind4 === "a"
    ? f.call(receiver)
    : f
    ? f.value
    : state.get(receiver);
};
var _AbstractPage_client3;
async function defaultParseResponse3(props) {
  const { response } = props;
  if (props.options.stream) {
    debug3(
      "response",
      response.status,
      response.url,
      response.headers,
      response.body
    );
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(
        response,
        props.controller
      );
    }
    return Stream3.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON =
    (contentType == null ? void 0 : contentType.includes("application/json")) ||
    (contentType == null
      ? void 0
      : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug3("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug3("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise3 = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse3) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise3(this.responsePromise, async (props) =>
      transform(await this.parseResponse(props))
    );
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([
      this.parse(),
      this.asResponse(),
    ]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient3 = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e4,
    httpAgent,
    fetch: overridenFetch,
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger3("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger3("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch != null ? overridenFetch : fetch4;
  }
  authHeaders(opts) {
    return {};
  }
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders3(),
      ...this.authHeaders(opts),
    };
  }
  validateHeaders(headers, customHeaders) {}
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid43()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(
      Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 }))
    );
  }
  getAPIList(path, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a4, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody3(options.body)
      ? options.body.body
      : options.body
      ? JSON.stringify(options.body, null, 2)
      : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger3("timeout", options.timeout);
    const timeout = (_a4 = options.timeout) != null ? _a4 : this.timeout;
    const httpAgent =
      (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null
        ? _c
        : getDefaultAgent3(url);
    const minAgentTimeout = timeout + 1e3;
    if (
      typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null
        ? void 0
        : _d.timeout) === "number" &&
      minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)
    ) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength });
    const req = {
      method,
      ...(body && { body }),
      headers: reqHeaders,
      ...(httpAgent && { agent: httpAgent }),
      signal: (_f = options.signal) != null ? _f : null,
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody3(options.body) && kind3 !== "node") {
      delete reqHeaders["content-type"];
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  async prepareOptions(options) {}
  async prepareRequest(request4, { url, options }) {}
  parseHeaders(headers) {
    return !headers
      ? {}
      : Symbol.iterator in headers
      ? Object.fromEntries(Array.from(headers).map((header) => [...header]))
      : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError5.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise3(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a4, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining =
        (_a4 = options.maxRetries) != null ? _a4 : this.maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug3("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError5();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(
      url,
      req,
      timeout,
      controller
    ).catch(castToError3);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError5();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError5();
      }
      throw new APIConnectionError5({ cause: response });
    }
    const responseHeaders = createResponseHeaders3(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug3(
          `response (error; ${retryMessage2})`,
          response.status,
          url,
          responseHeaders
        );
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response
        .text()
        .catch((e) => castToError3(e).message);
      const errJSON = safeJSON3(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining
        ? `(error; no more retries left)`
        : `(error; not retryable)`;
      debug3(
        `response (error; ${retryMessage})`,
        response.status,
        url,
        responseHeaders,
        errMessage
      );
      const err = this.makeStatusError(
        response.status,
        errJSON,
        errMessage,
        responseHeaders
      );
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page3, options) {
    const request4 = this.makeRequest(options, null);
    return new PagePromise3(this, request4, Page3);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL3(path)
      ? new URL(path)
      : new URL(
          this.baseURL +
            (this.baseURL.endsWith("/") && path.startsWith("/")
              ? path.slice(1)
              : path)
        );
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj3(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query)
      .filter(([_, value]) => typeof value !== "undefined")
      .map(([key, value]) => {
        if (
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean"
        ) {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new GroqError(
          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
        );
      })
      .join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal) signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient()
      .fetch.call(void 0, url, { signal: controller.signal, ...options })
      .finally(() => {
        clearTimeout(timeout);
      });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true") return true;
    if (shouldRetryHeader === "false") return false;
    if (response.status === 408) return true;
    if (response.status === 409) return true;
    if (response.status === 429) return true;
    if (response.status >= 500) return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a4;
    let timeoutMillis;
    const retryAfterMillisHeader =
      responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader =
      responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries =
        (_a4 = options.maxRetries) != null ? _a4 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(
        retriesRemaining,
        maxRetries
      );
    }
    await sleep3(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(
      initialRetryDelay * Math.pow(2, numRetries),
      maxRetryDelay
    );
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION3}`;
  }
};
var AbstractPage3 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client3.set(this, void 0);
    __classPrivateFieldSet7(this, _AbstractPage_client3, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length) return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new GroqError(
        "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
      );
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [
        ...Object.entries(nextOptions.query || {}),
        ...nextInfo.url.searchParams.entries(),
      ];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet7(
      this,
      _AbstractPage_client3,
      "f"
    ).requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[((_AbstractPage_client3 = /* @__PURE__ */ new WeakMap()),
  Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise3 = class extends APIPromise3 {
  constructor(client, request4, Page3) {
    super(
      request4,
      async (props) =>
        new Page3(
          client,
          props.response,
          await defaultParseResponse3(props),
          props.options
        )
    );
  }
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders3 = (headers) => {
  return new Proxy(Object.fromEntries(headers.entries()), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    },
  });
};
var getPlatformProperties3 = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": normalizePlatform3(Deno.build.os),
      "X-Stainless-Arch": normalizeArch3(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version,
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version,
    };
  }
  if (
    Object.prototype.toString.call(
      typeof process !== "undefined" ? process : 0
    ) === "[object process]"
  ) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": normalizePlatform3(process.platform),
      "X-Stainless-Arch": normalizeArch3(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version,
    };
  }
  const browserInfo = getBrowserInfo3();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version,
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION3,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown",
  };
};
function getBrowserInfo3() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    {
      key: "safari",
      pattern:
        /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/,
    },
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch3 = (arch) => {
  if (arch === "x32") return "x32";
  if (arch === "x86_64" || arch === "x64") return "x64";
  if (arch === "arm") return "arm";
  if (arch === "aarch64" || arch === "arm64") return "arm64";
  if (arch) return `other:${arch}`;
  return "unknown";
};
var normalizePlatform3 = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios")) return "iOS";
  if (platform === "android") return "Android";
  if (platform === "darwin") return "MacOS";
  if (platform === "win32") return "Windows";
  if (platform === "freebsd") return "FreeBSD";
  if (platform === "openbsd") return "OpenBSD";
  if (platform === "linux") return "Linux";
  if (platform) return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders3;
var getPlatformHeaders3 = () => {
  return _platformHeaders3 != null
    ? _platformHeaders3
    : (_platformHeaders3 = getPlatformProperties3());
};
var safeJSON3 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp3 = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL3 = (url) => {
  return startsWithSchemeRegexp3.test(url);
};
var sleep3 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger3 = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new GroqError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new GroqError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError3 = (err) => {
  if (err instanceof Error) return err;
  return new Error(err);
};
var readEnv3 = (env) => {
  var _a4, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c =
      (_b = (_a4 = process.env) == null ? void 0 : _a4[env]) == null
        ? void 0
        : _b.trim()) != null
      ? _c
      : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f =
      (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null
        ? void 0
        : _e.call(_d, env)) == null
      ? void 0
      : _f.trim();
  }
  return void 0;
};
function isEmptyObj3(obj) {
  if (!obj) return true;
  for (const _k in obj) return false;
  return true;
}
function hasOwn3(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn3(newHeaders, k)) continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey) continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug3(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`Groq:DEBUG:${action}`, ...args);
  }
}
var uuid43 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 3) | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser3 = () => {
  return (
    typeof window !== "undefined" &&
    typeof window.document !== "undefined" &&
    typeof navigator !== "undefined"
  );
};

// node_modules/groq-sdk/resource.mjs
var APIResource3 = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/groq-sdk/resources/chat/completions.mjs
var Completions7 = class extends APIResource3 {
  create(body, options) {
    var _a4;
    return this._client.post("/openai/v1/chat/completions", {
      body,
      ...options,
      stream: (_a4 = body.stream) != null ? _a4 : false,
    });
  }
};
(function (Completions8) {})(Completions7 || (Completions7 = {}));

// node_modules/groq-sdk/resources/chat/chat.mjs
var Chat5 = class extends APIResource3 {
  constructor() {
    super(...arguments);
    this.completions = new Completions7(this._client);
  }
};
(function (Chat6) {
  Chat6.Completions = Completions7;
})(Chat5 || (Chat5 = {}));

// node_modules/groq-sdk/resources/models.mjs
var Models3 = class extends APIResource3 {
  retrieve(model, options) {
    return this._client.get(`/openai/v1/models/${model}`, options);
  }
  list(options) {
    return this._client.get("/openai/v1/models", options);
  }
  delete(model, options) {
    return this._client.delete(`/openai/v1/models/${model}`, {
      ...options,
      headers: {
        Accept: "*/*",
        ...(options == null ? void 0 : options.headers),
      },
    });
  }
};
(function (Models4) {})(Models3 || (Models3 = {}));

// node_modules/groq-sdk/resources/audio/transcriptions.mjs
var Transcriptions3 = class extends APIResource3 {
  create(body, options) {
    return this._client.post(
      "/openai/v1/audio/transcriptions",
      multipartFormRequestOptions3({ body, ...options })
    );
  }
};
(function (Transcriptions4) {})(Transcriptions3 || (Transcriptions3 = {}));

// node_modules/groq-sdk/resources/audio/translations.mjs
var Translations3 = class extends APIResource3 {
  create(body, options) {
    return this._client.post(
      "/openai/v1/audio/translations",
      multipartFormRequestOptions3({ body, ...options })
    );
  }
};
(function (Translations4) {})(Translations3 || (Translations3 = {}));

// node_modules/groq-sdk/resources/audio/audio.mjs
var Audio3 = class extends APIResource3 {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions3(this._client);
    this.translations = new Translations3(this._client);
  }
};
(function (Audio4) {
  Audio4.Transcriptions = Transcriptions3;
  Audio4.Translations = Translations3;
})(Audio3 || (Audio3 = {}));

// node_modules/groq-sdk/index.mjs
var _a3;
var Groq = class extends APIClient3 {
  constructor({
    baseURL = readEnv3("GROQ_BASE_URL"),
    apiKey = readEnv3("GROQ_API_KEY"),
    ...opts
  } = {}) {
    var _a4;
    if (apiKey === void 0) {
      throw new GroqError(
        "The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' })."
      );
    }
    const options = {
      apiKey,
      ...opts,
      baseURL: baseURL || `https://api.groq.com`,
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser3()) {
      throw new GroqError(
        "This is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Groq({ dangerouslyAllowBrowser: true })"
      );
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a4 = options.timeout) != null ? _a4 : 6e4,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch,
    });
    this.chat = new Chat5(this);
    this.audio = new Audio3(this);
    this.models = new Models3(this);
    this._options = options;
    this.apiKey = apiKey;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.defaultHeaders,
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a3 = Groq;
Groq.Groq = _a3;
Groq.GroqError = GroqError;
Groq.APIError = APIError5;
Groq.APIConnectionError = APIConnectionError5;
Groq.APIConnectionTimeoutError = APIConnectionTimeoutError5;
Groq.APIUserAbortError = APIUserAbortError5;
Groq.NotFoundError = NotFoundError5;
Groq.ConflictError = ConflictError5;
Groq.RateLimitError = RateLimitError5;
Groq.BadRequestError = BadRequestError5;
Groq.AuthenticationError = AuthenticationError5;
Groq.InternalServerError = InternalServerError5;
Groq.PermissionDeniedError = PermissionDeniedError5;
Groq.UnprocessableEntityError = UnprocessableEntityError5;
var {
  GroqError: GroqError2,
  APIError: APIError6,
  APIConnectionError: APIConnectionError6,
  APIConnectionTimeoutError: APIConnectionTimeoutError6,
  APIUserAbortError: APIUserAbortError6,
  NotFoundError: NotFoundError6,
  ConflictError: ConflictError6,
  RateLimitError: RateLimitError6,
  BadRequestError: BadRequestError6,
  AuthenticationError: AuthenticationError6,
  InternalServerError: InternalServerError6,
  PermissionDeniedError: PermissionDeniedError6,
  UnprocessableEntityError: UnprocessableEntityError6,
} = error_exports3;
(function (Groq2) {
  Groq2.toFile = toFile4;
  Groq2.fileFromPath = fileFromPath3;
  Groq2.Chat = Chat5;
  Groq2.Audio = Audio3;
  Groq2.Models = Models3;
})(Groq || (Groq = {}));

// src/main.ts
var affinityAPIKey = "";
var openaiAPIKey = "";
var togetheraiAPIKey = "";
var groqAPIKey = "";
var owner_value = "10";
var connection_owner_field = "10";
var venture_network_list = "500";
var investor_names = [];
var fireflies_api_key = "";
var tracxn_api_key = "";
var intervalId;
var openai;
var groq;
var gpt_3_latest = "gpt-3.5-turbo";
var gpt_4_latest2 = "gpt-4-turbo";
var DEFAULT_SETTINGS = {
  affinityKey: "default",
  openAIKey: "default",
  togetherAIKey: "default",
  groqAIKey: "default",
  owner_person_value: "10",
  connection_owner_field_id: "100",
  venture_network_list_id: "500",
  team_names: "Ben Horrowitz, Vinod Khosla",
  fireflies_api: "default",
  tracxn_api: "default",
};
async function openai_js(
  model_name,
  user_prompt,
  system_prompt,
  max_tokens = 256,
  temperature = 0.3,
  isStreaming = false
) {
  const response = await openai.chat.completions.create({
    model: model_name,
    temperature,
    max_tokens,
    stream: isStreaming,
    messages: [
      { role: "system", content: system_prompt },
      { role: "user", content: user_prompt },
    ],
  });
  if (!isStreaming) {
    let summary = response.choices[0].message.content;
    if (summary == null) {
      summary = "";
    }
    return summary;
  } else {
    return response;
  }
}
async function openai_js_multiturn(
  queries,
  system_prompt,
  model_name,
  max_tokens = 256,
  temperature = 0.3
) {
  const system_message = system_prompt;
  let messages = [{ role: "system", content: system_message }];
  let replies = [];
  for (let query of queries) {
    messages.push({ role: "user", content: query });
    var response;
    let assistant_reply = "";
    if (model_name == "groq") {
      response = await groq.chat.completions.create({
        messages,
        model: "llama3-70b-8192",
      });
      assistant_reply = response.choices[0].message.content;
    } else {
      if (model_name == "openai") {
        response = await openai.chat.completions.create({
          model: gpt_4_latest2,
          temperature,
          max_tokens,
          messages,
        });
        assistant_reply = response.choices[0].message.content;
      } else {
        response = await togetherai_js(
          togetheraiAPIKey,
          model_name,
          "",
          "",
          1024,
          0,
          messages
        );
        assistant_reply = response;
      }
    }
    if (assistant_reply == null) {
      assistant_reply = "";
    }
    messages.push({ role: "assistant", content: assistant_reply });
    replies.push(assistant_reply);
  }
  return replies;
}
async function summarize_vc_text(text) {
  let [title, substrings] = extract_title_and_note(text);
  let hashtags;
  try {
    hashtags = substrings[0].split("Tags:")[1];
  } catch (e) {
    hashtags = substrings[0];
    new import_obsidian4.Notice(
      `${title}: Does not have any guiding hashtags, this could help the summarizer understand the VC better`,
      3600
    );
  }
  let text_to_summarize = hashtags + "\n" + substrings[1];
  console.log(`Summarizing: ${title}`);
  const system_prompt =
    "You are a summarizer for my notes about VC Funds. Your job is to read through my notes and create a summary in the following schema:\n- Fund Size::<How big is the fund?>\n- Ticket Size::<How much does the fund invest per startup?>\n- Geography::<Where can the fund invest?>\n- Stage:: <Pre-seed, Seed, Series A, etc>\n- Industry::<In which industries does the fund invest?>\n- Special::<Any special information about the fund or the investor that I should remember>";
  const summary = await openai_js(
    gpt_4_latest2,
    "Notes:\n" + text_to_summarize,
    system_prompt
  );
  let new_summary = String(summary);
  title = title.toString();
  let leading_text = "";
  let replacement = "";
  let tailing_text = "";
  if (substrings) {
    leading_text = substrings[0] + "\n" + title + "\n";
    for (let substring of substrings.slice(1)) {
      tailing_text = tailing_text + "\n" + substring;
    }
    replacement =
      leading_text +
      "#gpt_summarized, #review \n" +
      new_summary +
      "\n# Stop Indexing \n## Notes\n" +
      tailing_text;
    return [replacement, new_summary, title];
  } else {
    return [text, text, ""];
  }
}
async function summarize_paragraph(paragraph, model_name) {
  let reply = "";
  if (model_name == "openai") {
    var response;
    response = await openai.chat.completions.create({
      model: gpt_4_latest2,
      messages: [
        {
          role: "system",
          content:
            'You are a helpful note-taking assistant for a venture capital investor. You will be given a part of a transcript for the call between the investor and the startup founders. Your task is to extract information covering the following aspects:\n- **Team**:<Who is the team behind the startup. Answer in bullet points!>\n- **Problem**:<What is the problem the startup is solving and for whom. Answer in bullet points!>\n- **Product**:<How does their product solve this problem. Answer in bullet points!>\n- **Traction**:<How does their customer traction look like. Answer in bullet points!>\n- **Competition**:<How does the competitive landscape look like. Answer in bullet points!>\n- **Round Info**:<How much money are they raising from investors currently? How much have they raised before? Answer in bullet points!>\n- **Other**: <Other important points about the founders OR the startup that do not fit in the above sections. Answer in bullet points!>\n\nFor every section, always give your answers in bullet points! Otherwise, say "No Relevant Information"',
        },
        {
          role: "user",
          content: `${paragraph}`,
        },
      ],
      temperature: 0,
      max_tokens: 1024,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });
    reply = response.choices[0].message.content;
  } else {
    reply = await togetherai_js(
      togetheraiAPIKey,
      model_name,
      paragraph,
      'You are a helpful note-taking assistant for a venture capital investor. You will be given a part of a transcript for the call between the investor and the startup founders. Your task is to extract information covering the following aspects:\n- **Team**:<Who is the team behind the startup. Answer in bullet points!>\n- **Problem**:<What is the problem the startup is solving and for whom. Answer in bullet points!>\n- **Product**:<How does their product solve this problem. Answer in bullet points!>\n- **Traction**:<How does their customer traction look like. Answer in bullet points!>\n- **Competition**:<How does the competitive landscape look like. Answer in bullet points!>\n- **Round Info**:<How much money are they raising from investors currently? How much have they raised before? Answer in bullet points!>\n- **Other**: <Other important points about the founders OR the startup that do not fit in the above sections. Answer in bullet points!>\n\nFor every section, always give your answers in bullet points! Otherwise, say "No Relevant Information"',
      1024,
      0
    );
  }
  console.log(reply);
  if (reply == null) {
    reply = "";
  }
  return reply;
}
async function summarize_all_paragraphs_together(paragraphs, model_name) {
  let input_text = "";
  for (let i = 0; i < paragraphs.length; i++) {
    input_text += `Summary #${i + 1}:
`;
    input_text += paragraphs[i] + "\n\n";
  }
  console.log("All Summaries:");
  console.log(input_text);
  let system_prompt = `You are a helpful assistant. Your task is to expand the first summary you are given by the information in all the subsequent summaries. The final summary you provide should cover ALL following sections:
- **Team**: <Who is the team behind the startup>
- **Problem**: <What is the problem the startup is solving and for whom>
- **Product**: <How does their product solve this problem>
- **Traction**: <How does their customer traction look like>
- **Competition**: <How does the competitive landscape look like>
- **Round Info**: <How much money are they raising from investors currently? How much have they raised before?>
- **Other**: <Other important points about the founders OR the startup that do not fit in the above sections>

Do not leave any empty sections. For every section always give your answers in bullet points! Otherwise say "No Relevant Information" infront of the section's name.`;
  let reply = "";
  if (model_name == "openai") {
    var response;
    response = await openai.chat.completions.create({
      model: gpt_4_latest2,
      messages: [
        {
          role: "system",
          content: system_prompt,
        },
        {
          role: "user",
          content: `${input_text}`,
        },
      ],
      temperature: 0,
      max_tokens: 2048,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });
    reply = response.choices[0].message.content;
  } else {
    reply = await togetherai_js(
      togetheraiAPIKey,
      model_name,
      input_text,
      system_prompt,
      1024,
      0
    );
  }
  if (reply == null) {
    reply = "";
  }
  return reply;
}
function extractHeadersFromNotes(notes) {
  const headerRegex = /^#+\s+.+$/gm;
  const headers = [];
  let match;
  while ((match = headerRegex.exec(notes)) !== null) {
    headers.push(match[0]);
  }
  return headers;
}
function findLineNumber(fileText, searchString, startLine) {
  const fileContent = fileText;
  const lines = fileContent.split("\n");
  for (let i = startLine; i < lines.length; i++) {
    if (lines[i].includes(searchString)) {
      return [i, lines[i]];
    }
  }
  return [null, null];
}
function getStartHeader(update_type) {
  let startHeader = "";
  if (update_type.toLowerCase() == "team") {
    startHeader = "#### Team";
  } else if (update_type.toLowerCase() == "ideal customer profile") {
    startHeader = "#### Problem";
  } else if (update_type.toLowerCase() == "product") {
    startHeader = "#### Product";
  } else if (update_type.toLowerCase() == "competition") {
    startHeader = "#### Competition";
  } else if (
    update_type.toLowerCase() == "commercial traction" ||
    update_type.toLowerCase() == "market size"
  ) {
    startHeader = "#### Traction";
  } else if (update_type.toLowerCase() == "funding") {
    startHeader = "#### Round Info";
  }
  return startHeader;
}
function getCursorRange(fileText, startHeader, editor, allHeaders) {
  let startLineNumber;
  let matchedHeader;
  [startLineNumber, matchedHeader] = findLineNumber(fileText, startHeader, 0);
  console.log(`Matched Header: ${matchedHeader}`);
  console.log(`Found in line: ${startLineNumber}`);
  let startCursorPosition = null;
  let endCursorPosition = null;
  if (startLineNumber) {
    editor.setCursor(startLineNumber);
    startCursorPosition = editor.getCursor();
    let endLineNumber;
    let endMatchedHeader;
    endLineNumber = editor.lastLine();
    if (allHeaders.indexOf(matchedHeader) < allHeaders.length - 1) {
      let nextHeader = allHeaders[allHeaders.indexOf(matchedHeader) + 1];
      [endLineNumber, endMatchedHeader] = findLineNumber(
        fileText,
        nextHeader,
        startLineNumber
      );
      console.log(`Matched Next Header: ${nextHeader}`);
      console.log(`Found in line: ${endLineNumber}`);
    }
    if (endLineNumber) {
      endLineNumber -= 1;
      editor.setCursor(endLineNumber);
      endCursorPosition = editor.getCursor();
    }
  }
  return [startCursorPosition, endCursorPosition, matchedHeader];
}
async function update_affinity_startup(startup_name, note) {
  let startup;
  try {
    startup = await get_startup_by_name(
      affinityAPIKey,
      owner_value,
      startup_name
    );
  } catch (e) {
    new import_obsidian4.Notice(`Can not establish connection with Affinity`);
    return;
  }
  if (startup) {
    let response = await add_notes_to_company(startup, note, affinityAPIKey);
    if (response == null) {
      new import_obsidian4.Notice(
        `Startup: ${startup_name} was NOT updated on Affinity`
      );
      return false;
    } else {
      new import_obsidian4.Notice(
        `Startup: ${startup_name} was updated on Affinity`
      );
      return true;
    }
  } else {
    new import_obsidian4.Notice(
      `Startup: ${startup_name} was NOT found on Affinity`
    );
    return false;
  }
}
function find_the_nearest_header(searchString, fileText) {
  let lineOfString, fullSearchString;
  [lineOfString, fullSearchString] = findLineNumber(fileText, searchString, 0);
  const headerRegex = /^#+\s+.+$/gm;
  const lines = fileText.split("\n");
  for (let i = lineOfString; i >= 0; i--) {
    let match;
    if ((match = headerRegex.exec(lines[i])) != null) {
      console.log(`Nearest header to: ${searchString} is ${match[0]}`);
      return match[0];
    }
  }
  console.log(`Can not find nearest string for: ${searchString}`);
  return "";
}
async function find_competitors_through_tracxn(
  domain,
  isPublic,
  isAcquired,
  companies_per_request
) {
  const requestUrl = "https://tracxn.com/api/2.2/companies";
  const accessToken = tracxn_api_key;
  let results;
  try {
    let requestBody = {
      filter: {
        competitorOf: [domain],
        isFunded: true,
      },
      size: companies_per_request,
    };
    if (isAcquired) {
      requestBody["filter"]["companyStage"] = "Acquired";
    } else if (isPublic) {
      requestBody["filter"]["companyStage"] = "Public";
    }
    const response = await (0, import_obsidian4.request)({
      url: requestUrl,
      method: "POST",
      headers: { "Content-Type": "application/json", accessToken },
      body: JSON.stringify(requestBody),
    });
    const result = await JSON.parse(response);
    console.log(result);
    results = result["result"];
  } catch (error) {
    console.error(error);
    return [];
  }
  return results;
}
var VCCopilotPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new VCCopilotSettingsTab(this.app, this));
    this.status = this.addStatusBarItem();
    this.addCommand({
      id: "summarize-startup-command",
      name: "Summarize This Startup",
      editorCallback: (editor, view) =>
        this.summarize_selected_startup_text(editor, view, this.status),
    });
    this.addCommand({
      id: "reformat-and-update-master-note",
      name: "Reformat & Update Master Note",
      editorCallback: (editor, view) =>
        this.reformat_and_update_master_note(editor),
    });
    this.addCommand({
      id: "reformat-notes",
      name: "Reformat Notes",
      editorCallback: (editor, view) => this.reformat_notes(editor),
    });
    this.addCommand({
      id: "update-master-note",
      name: "Update Master Note",
      editorCallback: (editor, view) =>
        this.update_master_note_with_selected_text(editor),
    });
    this.addCommand({
      id: "affinity-startup",
      name: "Push Startups to Affinity",
      callback: () => this.push_startups_to_affinity(this.status),
    });
    this.addCommand({
      id: "summarize-all-vc-command",
      name: "Summarize All VC Notes",
      callback: () => this.summarize_all_vc(this.status),
    });
    this.addCommand({
      id: "affinity-vc",
      name: "Push VCs to Affinity",
      callback: () => this.push_vcs_to_affinity(this.status),
    });
    this.addCommand({
      id: "startup-defensibility",
      name: "Evaluate Startup Defensibility",
      editorCallback: (editor) => {
        const inputModal = new WorkflowModal(this.app, (input) => {
          console.log("Submitted text:", input);
          let result = input.split("//-- ");
          let desc = result[0];
          let model_name = result[1].trim();
          this.defensibility_analysis(input, model_name, editor);
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "startup-workflow",
      name: "Startup Guidance Workflow",
      editorCallback: (editor) => {
        const inputModal = new WorkflowModal(this.app, (input) => {
          console.log("Submitted text:", input);
          let result = input.split("//-- ");
          let desc = result[0];
          let model_name = result[1].trim();
          this.guidance_workflow(desc, model_name, editor);
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "market-research-command",
      name: "Market Research",
      editorCallback: (editor) => {
        const inputModal = new TextInputModal(
          this.app,
          "market-research",
          (input) => {
            console.log("Submitted text:", input);
            this.market_research(input, editor);
          }
        );
        inputModal.open();
      },
    });
    this.addCommand({
      id: "url-research-command",
      name: "Url Research",
      editorCallback: (editor) => {
        const inputModal = new TextInputModal(
          this.app,
          "url-research",
          (input) => {
            console.log("Submitted text:", input);
            this.url_research(input, editor);
          }
        );
        inputModal.open();
      },
    });
    this.addCommand({
      id: "competition-research-command",
      name: "Competition Research",
      editorCallback: (editor) => {
        const inputModal = new TextInputModal(
          this.app,
          "competition",
          (input) => {
            console.log("Submitted text:", input);
            this.competition_research(input, editor);
          }
        );
        inputModal.open();
      },
    });
    this.addCommand({
      id: "deck-analysis",
      name: "Summarize Pitch Deck",
      editorCallback: (editor) => {
        const inputModal = new PDFModal(this.app, (selected_file) => {
          new import_obsidian4.Notice(`Selected: '${selected_file}`);
          this.analyze_pitch_deck(selected_file, editor);
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "custom-research",
      name: "Custom Research",
      editorCallback: (editor) => {
        const inputModal = new MultipleTextInputModal(this.app, "", (input) => {
          let result = input.split(", ");
          let website = result[0];
          let query = result[1];
          let task = result[2];
          console.log("Submitted text:", input);
          this.custom_search(task, website, query, editor);
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "find-investors",
      name: "Find Investors For A Startup",
      editorCallback: (editor) => {
        const inputModal = new FindInvestorModal(this.app, (input) => {
          let result = input.split(", ");
          let company = result[0];
          let stage = result[1];
          let location = result[2];
          let isFocused = result[3].trim() == "true" ? true : false;
          console.log("Submitted text:", input);
          this.find_investors_for_startup(
            company,
            stage,
            location,
            isFocused,
            editor
          );
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "tracxn-competitor-overview",
      name: "Competitor Overview Through Tracxn",
      editorCallback: (editor) => {
        const inputModal = new TracxnModal(this.app, (input) => {
          let result = input.split(", ");
          let company = result[0];
          let isIPO = result[1].trim() == "true" ? true : false;
          let isAcquired = result[2].trim() == "true" ? true : false;
          let companies_per_request = parseInt(result[3].trim());
          console.log("Submitted text:");
          console.log(company);
          console.log(isIPO);
          console.log(isAcquired);
          console.log(companies_per_request);
          this.tracxn(
            company,
            isIPO,
            isAcquired,
            companies_per_request,
            editor
          );
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "fireflies-summary",
      name: "Fireflies Call Summary",
      editorCallback: (editor) => {
        const inputModal = new TextInputModal(
          this.app,
          "fireflies-summary",
          (input) => {
            console.log("Submitted text:", input);
            this.fireflies_summary(input, editor);
          }
        );
        inputModal.open();
      },
    });
    this.addCommand({
      id: "fireflies-summary-temp",
      name: "Fireflies Text Summary (Temp)",
      editorCallback: (editor) => {
        const inputModal = new FireFliesTemp(this.app, (input) => {
          console.log("Submitted text:", input);
          let result = input.split("&&& ");
          let json_string = result[0];
          let meeting_name = result[1];
          this.fireflies_summary_temp(json_string, meeting_name, editor);
        });
        inputModal.open();
      },
    });
    this.addCommand({
      id: "summarise-spoke-meeting",
      name: "Spoke Call Summary",
      editorCallback: (editor) => {
        const inputModal = new SpokeModal(this.app, (input) => {
          console.log("Submitted text:", input);
          let result = input.split(", ");
          let meeting_name = result[0];
          let isDetailed = result[1].trim() == "true" ? true : false;
          let model_name = result[2].trim();
          this.summarize_spoke_meeting(
            editor,
            meeting_name,
            isDetailed,
            model_name
          );
        });
        inputModal.open();
      },
    });
    openai = new openai_default({
      apiKey: openaiAPIKey,
      dangerouslyAllowBrowser: true,
    });
    groq = new Groq({
      apiKey: groqAPIKey,
      dangerouslyAllowBrowser: true,
    });
    console.log(`Groq API: ${groqAPIKey}`);
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot loading....");
    this.status.setAttr("title", "VC Copilot is loading...");
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    this.status.setAttr("title", "VC Copilot is ready");
  }
  onunload() {
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot left");
    this.status.setAttr("title", "VC Copilot says \u{1F44B}");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    openaiAPIKey = this.settings.openAIKey;
    togetheraiAPIKey = this.settings.togetherAIKey;
    groqAPIKey = this.settings.groqAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    fireflies_api_key = this.settings.fireflies_api;
    tracxn_api_key = this.settings.tracxn_api;
    this.settings.team_names.split(",").forEach((element) => {
      investor_names.push(element.trim());
    });
  }
  async saveSettings() {
    await this.saveData(this.settings);
    openaiAPIKey = this.settings.openAIKey;
    togetheraiAPIKey = this.settings.togetherAIKey;
    groqAPIKey = this.settings.groqAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    fireflies_api_key = this.settings.fireflies_api;
    tracxn_api_key = this.settings.tracxn_api;
    this.settings.team_names.split(",").forEach((element) => {
      investor_names.push(element.trim());
    });
  }
  async tracxn(company, isIPO, isAcquired, companies_per_request, editor) {
    let all_startups = await find_competitors_through_tracxn(
      company,
      isIPO,
      isAcquired,
      companies_per_request
    );
    const specialFormat = true;
    let all_startups_details = [];
    for (let startup of all_startups) {
      let startup_details = extract_startup_details(startup);
      let acquisition_details = {};
      if (isIPO) {
        acquisition_details = get_ipo_details(startup);
      } else if (isAcquired) {
        acquisition_details = get_acquisition_details(startup);
      }
      let mergedDetails = { ...startup_details, ...acquisition_details };
      all_startups_details.push(mergedDetails);
    }
    let table = formatObjectsToMarkdownTable(
      all_startups_details,
      specialFormat
    );
    let relevant_feeds = get_relevant_feeds(all_startups);
    let feed_text =
      '##### Tracxn Feed of Competitors for Deeper dive\n> Notice that the "feed" is the first part in the path\n\n';
    for (let [fullpath, link] of Object.entries(relevant_feeds)) {
      feed_text += `- [${fullpath}](${link})
`;
    }
    let header = `#### Tracxn Competitive Overview for ${company}
`;
    if (isIPO) {
      header = `#### IPOed Competition for ${company}
`;
    } else if (isAcquired) {
      header = `#### Acquired Competition for ${company}
`;
    }
    let final_text = header + table + "\n\n" + feed_text;
    let position = editor.getCursor();
    this.displaymessage(final_text, editor, position);
  }
  async get_all_investors(isFocused) {
    let all_files = this.app.vault.getMarkdownFiles();
    let connected_investors_files = [];
    for (let file of all_files) {
      let text = await this.app.vault.read(file);
      if (isFocused) {
        if (
          (text.includes("#network/strong") ||
            text.includes("#testRelation") ||
            text.includes("#network/favourite")) &&
          text.includes("#network/connected") &&
          text.includes("#Person/VC")
        ) {
          connected_investors_files.push({ text, name: file.basename });
        }
      } else {
        if (
          text.includes("#network/connected") &&
          text.includes("#Person/VC")
        ) {
          connected_investors_files.push({ text, name: file.basename });
        }
      }
    }
    return connected_investors_files;
  }
  async localDB(text_to_embed, metadata) {
    process.env.OPENAI_API_KEY = openaiAPIKey;
    const vectorStore = await MemoryVectorStore.fromTexts(
      text_to_embed,
      metadata,
      new OpenAIEmbeddings()
    );
    return vectorStore;
  }
  async get_most_relevant_investor_from_memory(invDB, cleaned_chunk) {
    const closestInvestors = await invDB.similaritySearch(cleaned_chunk, 20);
    let fit_investors_list = [];
    closestInvestors.forEach((doc) => {
      const investmentFocusStart = "Investment Focus:";
      const specialEnd = "Special Info:";
      const investor_desc = doc["pageContent"];
      const startIndex =
        investor_desc.indexOf(investmentFocusStart) +
        investmentFocusStart.length;
      const endIndex = investor_desc.indexOf(specialEnd);
      const investmentFocus = investor_desc.substring(startIndex, endIndex);
      const specialInfo = investor_desc.substring(endIndex + specialEnd.length);
      fit_investors_list.push(
        createInvestorObject(
          doc["metadata"],
          "",
          "",
          investmentFocus.trim(),
          specialInfo.trim()
        )
      );
    });
    return fit_investors_list;
  }
  async find_investors_for_startup(
    company,
    stage,
    location,
    isFocused,
    editor
  ) {
    new import_obsidian4.Notice("Finding best investors...");
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680}: VC Copilot searching for best investors..."
    );
    this.status.setAttr("title", "Copilot is searching for best investors...");
    let position = editor.getCursor();
    let connected_investors = await this.get_all_investors(isFocused);
    let connected_investors_json = [];
    for (let [i, connected_investor] of Object.entries(connected_investors)) {
      let name = connected_investor["name"];
      let text = connected_investor["text"];
      connected_investors_json.push(generate_investor_json(name, text));
    }
    let fit_investors = find_eligible_investors(
      connected_investors_json,
      location,
      stage
    );
    console.log(`We found ${fit_investors.length} suitable investors`);
    let investors_index = [];
    let investor_names2 = [];
    for (let [i, investor] of Object.entries(fit_investors)) {
      let investor_name = investor["name"];
      let industry = investor["industry"];
      let speciality = investor["speciality"];
      investors_index.push(`Investment Focus: ${industry}
Special Info: ${speciality}`);
      investor_names2.push(`${investor["name"]}`);
    }
    let invest_description_index = await this.localDB(
      investors_index,
      investor_names2
    );
    let best_fit_investor = await this.get_most_relevant_investor_from_memory(
      invest_description_index,
      company
    );
    console.log(best_fit_investor);
    let loadingInterval = this.create_loading_interval(
      "Finding best investors"
    );
    let message = "#### Most suitable investors\n";
    let investors_message = "";
    for (let investor of best_fit_investor) {
      investors_message += "- [[" + investor["name"] + "]]\n";
      investors_message += `	- Industry: ${investor["industry"]}
	- Special: ${investor["speciality"]}

`;
    }
    message += investors_message;
    let extra_text = "";
    try {
      message +=
        "\n\n##### Generally suitable investors based on geo and stage\n";
      for (let investor of fit_investors) {
        extra_text += "- [[" + investor["name"] + "]]\n";
      }
    } catch (e) {
      console.log("Error in extracting extra investors");
    }
    message += extra_text;
    console.log(message);
    this.displaymessage(message, editor, position);
    clearInterval(loadingInterval);
  }
  async summarize_selected_startup_text(editor, view, status) {
    const sel = editor.getSelection();
    new import_obsidian4.Notice("Summarizing...");
    status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot summarizing...");
    status.setAttr("title", "Copilot is summarizing...");
    const system_prompt =
      "You are a summarizer for my notes about startups. Your job is to read through my notes and create a summary in the following schema:\n- **Team**:<the founder team behind the startup>\n\n- **Product**:<the product and the problem it solves>\n\n- **Traction**:<how much revenue has the startup generated so far, how many customers do they have>\n\n- **Round**:<how much money have they raised so far at what terms. How much money are they raising now>";
    let new_summary = await openai_js(gpt_4_latest2, sel, system_prompt);
    const replacement =
      "#gpt_summarized, #AddHashtags, #review_startup \n" +
      new_summary +
      "\n# Stop Indexing \n## Notes\n" +
      sel;
    editor.replaceSelection(replacement);
    status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    status.setAttr("title", "Copilot is ready");
  }
  async push_startups_to_affinity(status) {
    const files = this.app.vault.getMarkdownFiles();
    status.setText(
      "\u{1F9D1}\u200D\u{1F680}: VC Copilot syncing with Affinity..."
    );
    status.setAttr("title", "Copilot is pushing startup info to Affinity...");
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (startup_ready_for_affinity(file_content)) {
        let [title, substrings] = extract_title_and_note(file_content);
        let startup_name = String(title);
        startup_name = clean_text(startup_name);
        let note = substrings[1];
        note = note.replace(/^(==|\*\*|#{2,})$/g, "");
        let startup_updated = await update_affinity_startup(startup_name, note);
        if (startup_updated) {
          file_content = file_content.replace(/#Affinity/g, "");
          this.app.vault.modify(item, file_content);
        }
      }
    }
    new import_obsidian4.Notice("Done!");
    status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    status.setAttr("title", "Copilot is ready");
  }
  async summarize_all_vc(status) {
    const files = this.app.vault.getMarkdownFiles();
    status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot summarizing...");
    status.setAttr(
      "title",
      "VC Copilot is summarizing all your VC connections..."
    );
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (is_summarizable(file_content)) {
        console.log(`We are changing file: ${item.name}`);
        let [new_text, summary, title] = await summarize_vc_text(file_content);
        if (title != "") {
          this.app.vault.modify(item, new_text);
          new import_obsidian4.Notice(`${title} has been summarized`);
        }
      }
    }
    status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    status.setAttr("title", "VC Copilot is ready");
  }
  async push_vcs_to_affinity(status) {
    const files = this.app.vault.getMarkdownFiles();
    status.setText(
      "\u{1F9D1}\u200D\u{1F680}: VC Copilot syncing with Affinity..."
    );
    status.setAttr("title", "Copilot is pushing VCs info to Affinity...");
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (vc_ready_for_affinity(file_content)) {
        let [title, substrings] = extract_title_and_note(file_content);
        let summary = substrings[1];
        let person_name = String(title);
        person_name = clean_text(person_name);
        let note = substrings[1];
        note = note.replace(/^(==|\*\*|#{2,})$/g, "");
        let person = await get_person_by_name(affinityAPIKey, person_name);
        if (person) {
          let person_id = person["id"];
          let person_details = await get_person_details(
            affinityAPIKey,
            person_id
          );
          let list_entry_id = await is_person_in_venture_network(
            affinityAPIKey,
            person_details,
            venture_network_list
          );
          if (list_entry_id != null) {
          } else {
            await add_entry_to_list(
              affinityAPIKey,
              venture_network_list,
              person_id
            );
            let person_details2 = await get_person_details(
              affinityAPIKey,
              person_id
            );
            list_entry_id = await is_person_in_venture_network(
              affinityAPIKey,
              person_details2,
              venture_network_list
            );
            await add_field_value(
              affinityAPIKey,
              connection_owner_field,
              person_id,
              owner_value,
              list_entry_id
            );
          }
          let result = await add_notes_to_person(
            affinityAPIKey,
            person_id,
            note
          );
          if (result) {
            new import_obsidian4.Notice(
              `VC: ${person_name} was updated on Affinity`
            );
            file_content = file_content.replace(/#Affinity/g, "");
            this.app.vault.modify(item, file_content);
          } else {
            new import_obsidian4.Notice(
              `VC: ${person_name} was FOUND but NOT updated on Affinity`
            );
          }
        } else {
          new import_obsidian4.Notice(
            `VC: ${person_name} was NOT FOUND on Affinity`
          );
        }
      }
    }
    status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    status.setAttr("title", "Copilot is ready");
  }
  async url_research(url, editor) {
    this.status.setText(
      `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot researching ${url}...`
    );
    this.status.setAttr("title", "Copilot is researching the url");
    let final_text = "";
    let position = editor.getCursor();
    try {
      const res = await fetch(
        "https://url-researcher-container-xm5lmdnsxq-ey.a.run.app",
        {
          method: "post",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            url,
            openai_key: openaiAPIKey,
          }),
        }
      );
      final_text = await res.text();
      final_text = format_url_text(final_text, url);
    } catch (error) {
      console.log(`Error when doing url research: ${error}`);
      new import_obsidian4.Notice(`Error when doing url research`);
    }
    this.displaymessage(final_text, editor, position);
  }
  async insert_header(headerNumber, headerMessage, editor) {
    let header = "";
    for (let i = 0; i < headerNumber; i++) {
      header += "#";
    }
    header += " ";
    header += headerMessage + "\n";
    editor.replaceRange(header, editor.getCursor());
    editor.setCursor(editor.getCursor()["line"] + 1, 0);
  }
  async insert_openai_streaming(response, editor) {
    var _a4, _b;
    for await (let completion of response) {
      let message =
        ((_b = (_a4 = completion.choices[0]) == null ? void 0 : _a4.delta) ==
        null
          ? void 0
          : _b.content) || "";
      editor.replaceRange(message, editor.getCursor());
      editor.setCursor(
        editor.getCursor()["line"],
        editor.getCursor()["ch"] + message.length
      );
    }
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    this.status.setAttr("title", "Copilot is ready");
  }
  async defensibility_analysis(startup_description, model_name, editor) {
    let position = editor.getCursor();
    let system_prompt = DEFENSIBILITY_ANALYSIS_SYSTEM_PROMPT;
    let query =
      "Startup Description:\n" +
      startup_description +
      "\nWhat types of defensibility does this startup have? Which types of defensibility does it lack or could improve upon? Let us think step by step";
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680}: VC Copilot analyzing defensibility..."
    );
    this.status.setAttr(
      "title",
      "VC Copilot is analyzing defensibility of the startup..."
    );
    this.insert_header(2, "Defensibility Analysis", editor);
    if (model_name == "openai") {
      let analysis = await openai_js(
        gpt_4_latest2,
        query,
        system_prompt,
        1024,
        1,
        true
      );
      await this.insert_openai_streaming(analysis, editor);
    } else {
      if (model_name == "groq") {
        new import_obsidian4.Notice(
          `Groq is not supported for this task yet. We defaulted to Llama-3`
        );
        model_name = "meta-llama/Llama-3-8b-chat-hf";
      }
      let message = await togetherai_js(
        togetheraiAPIKey,
        model_name,
        query,
        system_prompt,
        1024,
        1
      );
      this.displaymessage(message, editor, position);
    }
  }
  create_loading_interval(description) {
    let counter = 0;
    let loadingInterval = setInterval(() => {
      let emojis = [
        "\u{1F315}",
        "\u{1F316}",
        "\u{1F317}",
        "\u{1F318}",
        "\u{1F311}",
        "\u{1F312}",
        "\u{1F313}",
        "\u{1F314}",
      ];
      new import_obsidian4.Notice(
        `\u{1F9D1}\u200D\u{1F680} ${description} ${emojis[counter]}`,
        1e3
      );
      counter = (counter + 1) % emojis.length;
    }, 1500);
    return loadingInterval;
  }
  async guidance_workflow(startup_description, model_name, editor) {
    let position = editor.getCursor();
    let system_prompt = GUIDANCE_WORKFLOW_SYSTEM_PROMPT;
    let query =
      "Startup Description:\n" +
      startup_description +
      "\nWhat is the core problem this startup is solving? Give a concise answer.";
    let user_queries = [];
    user_queries.push(query);
    let hypothesis =
      "What are the core hypotheses the startup has to validate to prove that solving this core problem is important enough to allow them to build a unicorn?";
    user_queries.push(hypothesis);
    let classify =
      "Recommend some suitable product categories to classify the product";
    user_queries.push(classify);
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680}: VC Copilot analyzing startup..."
    );
    this.status.setAttr("title", "VC Copilot is analyzing the startup...");
    let loadingInterval = this.create_loading_interval("Analyzing the startup");
    let repliesPromise = openai_js_multiturn(
      user_queries,
      system_prompt,
      model_name,
      1024,
      1
    );
    repliesPromise
      .then((replies) => {
        clearInterval(loadingInterval);
        replies[0] =
          "## Analysis Workflow\n\n#### Core Problem\n\n" + replies[0] + "\n";
        replies[1] = "#### Hypotheses\n\n" + replies[1] + "\n";
        replies[2] = "#### Categories\n\n" + replies[2] + "\n";
        let final_text = replies[0] + replies[1] + replies[2];
        this.displaymessage(final_text, editor, position);
      })
      .catch((error) => {
        clearInterval(loadingInterval);
        new import_obsidian4.Notice(`An error occurred. Check Console`, 500);
        console.error(error);
      });
  }
  clean_final_summary(final_summary) {
    final_summary = final_summary.replace(/\*\*Team(:)?\*\*/g, "#### Team");
    final_summary = final_summary.replace(
      /\*\*Problem(:)?\*\*/g,
      "#### Problem"
    );
    final_summary = final_summary.replace(
      /\*\*Product(:)?\*\*/g,
      "#### Product"
    );
    final_summary = final_summary.replace(
      /\*\*Traction(:)?\*\*/g,
      "#### Traction"
    );
    final_summary = final_summary.replace(
      /\*\*Competition(:)?\*\*/g,
      "#### Competition"
    );
    final_summary = final_summary.replace(
      /\*\*Round Info(:)?\*\*/g,
      "#### Round Info"
    );
    final_summary = final_summary.replace(/\*\*Other(:)?\*\*/g, "#### Other");
    final_summary = final_summary.replace("- #### Team", "#### Team");
    final_summary = final_summary.replace("- #### Problem", "#### Problem");
    final_summary = final_summary.replace("- #### Product", "#### Product");
    final_summary = final_summary.replace("- #### Traction", "#### Traction");
    final_summary = final_summary.replace(
      "- #### Competition",
      "#### Competition"
    );
    final_summary = final_summary.replace(
      "- #### Round Info",
      "#### Round Info"
    );
    final_summary = final_summary.replace("- #### Other", "#### Other");
    return final_summary;
  }
  async summarize_transcript(paragraphs, meeting_name) {
    let summaries = [];
    let final_summary = "";
    let long_paragraph = "";
    let extended_paragraphs = [];
    let loadingInterval = this.create_loading_interval(
      "Summarizing sections of the transcript"
    );
    try {
      for (let paragraph of paragraphs) {
        let number_of_words = countWords(paragraph);
        if (number_of_words >= 12) {
          if (number_of_words + countWords(long_paragraph) <= 2500) {
            long_paragraph += paragraph;
          } else {
            extended_paragraphs.push(long_paragraph);
            long_paragraph = paragraph;
          }
        }
      }
      if (long_paragraph.length != 0) {
        extended_paragraphs.push(long_paragraph);
      }
      this.status.setText(
        `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot summarizing sections of the transcript of ${meeting_name}...`
      );
      this.status.setAttr(
        "title",
        "Copilot is summarizing sections of the transcript"
      );
      for (let paragraph of extended_paragraphs) {
        let summary = await summarize_paragraph(paragraph, "openai");
        summaries.push(summary);
      }
      clearInterval(loadingInterval);
      loadingInterval = this.create_loading_interval(
        "Summarizing full transcript"
      );
      this.status.setText(
        `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot summarizing the full transcript of ${meeting_name}...`
      );
      this.status.setAttr(
        "title",
        "Copilot is summarizing the full transcript"
      );
      final_summary = await summarize_all_paragraphs_together(
        summaries,
        "openai"
      );
      clearInterval(loadingInterval);
      final_summary = this.clean_final_summary(final_summary);
      final_summary =
        `## ${meeting_name} call summary
#review_startup
` + final_summary;
    } catch (error) {
      clearInterval(loadingInterval);
      console.log(`Error during fireflies summary: ${error}`);
      new import_obsidian4.Notice(`Error during fireflies summary`);
    }
    return final_summary;
  }
  async fireflies_summary(meeting_name, editor) {
    this.status.setText(
      `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot reading the transcript of ${meeting_name}...`
    );
    this.status.setAttr("title", "Copilot is reading the transcript");
    let final_summary = "";
    let cursor_position = editor.getCursor();
    let id = await get_meeting_id(meeting_name, fireflies_api_key);
    let paragraphs = await get_meeting_transcript_by_id(
      id,
      investor_names,
      fireflies_api_key
    );
    final_summary = await this.summarize_transcript(paragraphs, meeting_name);
    editor.replaceRange(final_summary, cursor_position);
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    this.status.setAttr("title", "Copilot is ready");
  }
  async fireflies_summary_temp(transcript_json_string, meeting_name, editor) {
    this.status.setText(
      `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot reading the transcript of ${meeting_name}...`
    );
    this.status.setAttr("title", "Copilot is reading the transcript");
    let cursor_position = editor.getCursor();
    let transcript = await transcript_json_to_array_string(
      transcript_json_string,
      investor_names
    );
    let final_summary = await this.summarize_transcript(
      transcript,
      meeting_name
    );
    editor.replaceRange(final_summary, cursor_position);
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    this.status.setAttr("title", "Copilot is ready");
  }
  async turn_paragraphs_into_chunks(paragraphs) {
    let long_paragraph = "";
    let extended_paragraphs = [];
    for (let paragraph of paragraphs) {
      let number_of_words = countWords(paragraph);
      if (number_of_words + countWords(long_paragraph) <= 2500) {
        long_paragraph += paragraph + "\n\n";
      } else {
        extended_paragraphs.push(long_paragraph);
        long_paragraph = paragraph;
      }
    }
    if (long_paragraph.length != 0) {
      extended_paragraphs.push(long_paragraph);
    }
    return extended_paragraphs;
  }
  async spoke_find_recording_id(meeting_name) {
    let response = await (0, import_obsidian4.request)({
      url: `https://api.spoke.app/projects/search?name=${meeting_name}&page=0&page_size=10&workspace_id=93424`,
      method: "GET",
      headers: {
        Authorization:
          "XnLd5LKbMbFm=sfmy7JZmpsTq0f-?cZIvq?3UOIhlkZIhi916vni2tkj1!Lapl/O/G2byTWHryxm4qRA54JLmwqwkjSn8p3szDtC/edurdW1=9iYecV!EwEpyb2=auPb!8Iw6?vHZxp?j!odL?=mJgybq9PGqwO5Y2rP?=0D?5T?7Wmn9u5/V1EKuzqTPsVFIxUEI!Jf-aAN3!SXdIDdpXFGbl2SaOUjb3EADoJWi5hQNI8I3frswrr=-6L-ozAluLINp0zH9?CrS20X?YZNKh6Hp=pvDCyesJL9CEXVTMJvAdrb5eP2-!mV7DyMS8YfMr5CBPtmDfgKJPDs5XWh!t5N-Zbf?oC5zoGusbwqfdSs36Ad!SlboJvbPEY2N94uVygMxybTmmdSdRO6qWO=!IO!n4aKLRcSOMhKeX8!lcWNxEgvtRPBnQFdQw3sJ-UKGsnuQ2K69tdQie4zNzMYrFcbUKkGrH5y3H/iqoeTsi5GHlxTBRTsECpxzSLCK5ij",
      },
    });
    let result = JSON.parse(response);
    console.log(`${result["hits"][0]["document"]["id"]}`);
    return result["hits"][0]["document"]["id"];
  }
  async spoke_details(meeting_id) {
    let response = await (0, import_obsidian4.request)({
      url: `https://api.spoke.app/projects/complete/${meeting_id}`,
      method: "GET",
      headers: {
        Authorization:
          "XnLd5LKbMbFm=sfmy7JZmpsTq0f-?cZIvq?3UOIhlkZIhi916vni2tkj1!Lapl/O/G2byTWHryxm4qRA54JLmwqwkjSn8p3szDtC/edurdW1=9iYecV!EwEpyb2=auPb!8Iw6?vHZxp?j!odL?=mJgybq9PGqwO5Y2rP?=0D?5T?7Wmn9u5/V1EKuzqTPsVFIxUEI!Jf-aAN3!SXdIDdpXFGbl2SaOUjb3EADoJWi5hQNI8I3frswrr=-6L-ozAluLINp0zH9?CrS20X?YZNKh6Hp=pvDCyesJL9CEXVTMJvAdrb5eP2-!mV7DyMS8YfMr5CBPtmDfgKJPDs5XWh!t5N-Zbf?oC5zoGusbwqfdSs36Ad!SlboJvbPEY2N94uVygMxybTmmdSdRO6qWO=!IO!n4aKLRcSOMhKeX8!lcWNxEgvtRPBnQFdQw3sJ-UKGsnuQ2K69tdQie4zNzMYrFcbUKkGrH5y3H/iqoeTsi5GHlxTBRTsECpxzSLCK5ij",
      },
    });
    let result = JSON.parse(response);
    let meeting_name = result["name"];
    let conversation = result["editors"];
    console.log(`Meeting name: ${meeting_name}`);
    console.log(result);
    let paragraphs = [];
    for (let turn_to_speak of conversation) {
      let transcripts = turn_to_speak["video"]["transcripts"];
      let transcript = transcripts[0];
      if (transcripts.length > 1) {
        console.log(transcripts);
      }
      let speaker_name = transcript["speaker"];
      if (investor_names.includes(speaker_name)) {
        speaker_name += ` (Investor)`;
      }
      let words = transcript["words"];
      if (words.length > 0) {
        let sentence = "";
        for (let word of words) {
          sentence += word["text"] + " ";
        }
        let paragraph = speaker_name + ":\n" + sentence;
        paragraphs.push(paragraph);
      }
    }
    return paragraphs;
  }
  async summarize_spoke_meeting(editor, meeting_name, isDetailed, model_name) {
    let cursor_position = editor.getCursor();
    let loadingInterval = this.create_loading_interval(
      "Summarizing sections of the transcript"
    );
    try {
      let meeting_id = await this.spoke_find_recording_id(meeting_name);
      let paragraphs = await this.spoke_details(meeting_id);
      let final_summary = "";
      this.status.setText(
        `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot summarizing sections of the transcript of ${meeting_name}...`
      );
      this.status.setAttr(
        "title",
        "Copilot is summarizing sections of the transcript"
      );
      if (isDetailed) {
        let summaries = [];
        let conversation_chunks = await this.turn_paragraphs_into_chunks(
          paragraphs
        );
        for (let conversation_chunk of conversation_chunks) {
          let summary = await summarize_paragraph(
            conversation_chunk,
            model_name
          );
          summaries.push(summary);
        }
        clearInterval(loadingInterval);
        loadingInterval = this.create_loading_interval(
          "Summarizing full transcript"
        );
        this.status.setText(
          `\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot summarizing the full transcript of ${meeting_name}...`
        );
        this.status.setAttr(
          "title",
          "Copilot is summarizing the full transcript"
        );
        final_summary = await summarize_all_paragraphs_together(
          summaries,
          model_name
        );
      } else {
        let full_transcript = paragraphs.join("\n\n");
        full_transcript = full_transcript.trim();
        final_summary = await summarize_paragraph(full_transcript);
      }
      clearInterval(loadingInterval);
      final_summary = this.clean_final_summary(final_summary);
      final_summary =
        `## ${meeting_name} call summary
#review_startup
` + final_summary;
      this.displaymessage(final_summary, editor, cursor_position);
      this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
      this.status.setAttr("title", "Copilot is ready");
    } catch (error) {
      clearInterval(loadingInterval);
      console.log(`Error during Spoke summary: ${error}`);
      new import_obsidian4.Notice(`Error during Spoke summary`);
    }
  }
  async market_research(industry, editor) {
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot researching the market..."
    );
    this.status.setAttr("title", "Copilot is researching the market...");
    let res;
    let position = editor.getCursor();
    let loadingInterval = this.create_loading_interval(
      `Researching the market`
    );
    try {
      let websites = ["", "globenewswire.com", "statista.com"];
      let query = `${industry} industry market report.`;
      let promises = websites.map((website) =>
        specific_web_research("market-research", website, query, openai, editor)
      );
      let results = await Promise.all(promises);
      let message = results.join("\n\n");
      message += "#### Further Material\n";
      message += "Here are some reading material for further information\n\n";
      query = `${industry} industry primer pdf`;
      let pdfs = await you_research(query);
      for (let element of pdfs) {
        let snippets = element["snippets"];
        let title = element["title"];
        let url = element["url"];
        message += `- [${title}](${url})
`;
      }
      message = "## Market Research\n" + message;
      clearInterval(loadingInterval);
      this.displaymessage(message, editor, position);
    } catch (error) {
      clearInterval(loadingInterval);
      console.log(`Error when doing market research: ${error}`);
      new import_obsidian4.Notice(`Error when doing market research`);
    }
  }
  async competition_research(query, editor) {
    let position = editor.getCursor();
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot researching competition..."
    );
    this.status.setAttr("title", "Copilot is researching competition...");
    let loadingInterval = this.create_loading_interval(
      `Researching competition`
    );
    try {
      let websites = ["techcrunch.com", "businessinsider.com"];
      let promises = websites.map((website) =>
        specific_web_research("competition", website, query, openai, editor)
      );
      let results = await Promise.all(promises);
      let message = results.join("\n\n");
      clearInterval(loadingInterval);
      message = "## Competition Research\n" + message;
      this.displaymessage(message, editor, position);
    } catch (error) {
      clearInterval(loadingInterval);
      console.log(`Error when doing market research: ${error}`);
      new import_obsidian4.Notice(`Error when doing market research`);
    }
  }
  async displaymessage(message, editor, position) {
    editor.replaceRange(message, position);
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    this.status.setAttr("title", "Copilot is ready");
  }
  async custom_search(task, website, search_query, editor) {
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680} \u{1F50E}: VC Copilot surfing the internet..."
    );
    this.status.setAttr("title", "Copilot is surfing...");
    let position = editor.getCursor();
    let loadingInterval = this.create_loading_interval("Searching");
    let message = await specific_web_research(
      task,
      website,
      search_query,
      openai,
      editor
    );
    clearInterval(loadingInterval);
    this.displaymessage(message, editor, position);
  }
  async getPathAndTextOfActiveFile() {
    let file = this.app.workspace.getActiveFile();
    let vault_path = file == null ? void 0 : file.vault.adapter.basePath;
    let filePath = vault_path + "/" + (file == null ? void 0 : file.path);
    let fileText = fs.readFileSync(filePath, "utf-8");
    return [filePath, fileText];
  }
  async reformat_notes(editor) {
    let notes = editor.getSelection();
    let message_without_headers = "";
    let activeFile = await this.app.workspace.getActiveFile();
    let fileText;
    const system_prompt = `Act as a veteran venture capital investor. You are very precise and concise. You are tasked with helping a junior venture capital investor in his due diligence about a startup. You always write full sentences in bullet points. Always mention hard facts like numbers and statistics.`;
    const user_prompt = `The notes of the junior venture capitalist will be delimited by triple quotes. Understand the context of these notes then summarize them more clearly and concisely in bullet points. Do not generate key takeaways or another summary after the initial bullet points.

"""${notes}"""`;
    this.status.setText(
      "\u{1F9D1}\u200D\u{1F680}: VC Copilot rewriting notes..."
    );
    this.status.setAttr("title", "VC Copilot is rewriting notes...");
    const headers = extractHeadersFromNotes(notes);
    let message = await openai_js(
      gpt_3_latest,
      user_prompt,
      system_prompt,
      256,
      0
    );
    message_without_headers = message;
    for (let i = headers.length - 1; i >= 0; i--) {
      message = headers[i] + "\n" + message;
    }
    if (activeFile) {
      fileText = await this.app.vault.process(activeFile, (data) => {
        return data.replace(notes, message);
      });
    } else {
      new import_obsidian4.Notice(
        `You must remain on the file where you want the command to work`
      );
      return "";
    }
    return message_without_headers;
  }
  async reformat_and_update_master_note(editor) {
    let activeFile = await this.app.workspace.getActiveFile();
    let message_without_headers = await this.reformat_notes(editor);
    if (activeFile) {
      await this.update_master_note_with_notes(
        message_without_headers,
        activeFile,
        editor
      );
    } else {
      new import_obsidian4.Notice(
        `You must remain on the file where you want the command to work`
      );
      return;
    }
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot ready");
    this.status.setAttr("title", "Copilot is ready");
  }
  async update_master_note_with_selected_text(editor) {
    let activeFile = this.app.workspace.getActiveFile();
    let notes = editor.getSelection();
    if (activeFile) {
      await this.update_master_note_with_notes(notes, activeFile, editor);
    } else {
      new import_obsidian4.Notice(
        `You must remain on the file where you want the command to work`
      );
      return;
    }
  }
  async update_master_note_with_notes(notes, activeFile, editor) {
    let fileText;
    let text_with_category = await this.categorize_notes(notes);
    console.log(`Text with Category: ${text_with_category}`);
    let updates = this.get_updates_from_categories(text_with_category);
    let update_messages = this.create_update_messages(updates);
    if (activeFile) {
      fileText = await this.app.vault.read(activeFile);
    } else {
      new import_obsidian4.Notice(
        `You must remain on the file where you want the command to work`
      );
      return;
    }
    const allHeaders = extractHeadersFromNotes(fileText);
    let startHeader = "#### Team";
    let affinity_updates = [];
    for (const update_type in update_messages) {
      fileText = await this.app.vault.read(activeFile);
      let update_text = update_messages[update_type];
      startHeader = getStartHeader(update_type);
      let note = notes.split("\n")[0];
      let nearestHeader = find_the_nearest_header(note, fileText);
      nearestHeader = nearestHeader.replace(/^[#\s]+/, "");
      let source = "-- [[#" + nearestHeader + "]]";
      if (startHeader == "") {
        new import_obsidian4.Notice(
          `The active file does not have the usual startup file format`
        );
        continue;
      }
      let startCursorPosition;
      let endCursorPosition;
      let matchedHeader;
      [startCursorPosition, endCursorPosition, matchedHeader] = getCursorRange(
        fileText,
        startHeader,
        editor,
        allHeaders
      );
      let originalText = editor.getRange(
        startCursorPosition,
        endCursorPosition
      );
      originalText = matchedHeader + originalText;
      update_text = update_text + source;
      if (activeFile) {
        await this.app.vault.process(activeFile, (data) => {
          return data.replace(
            originalText,
            originalText +
              `

${update_text}`
          );
        });
      }
      affinity_updates.push(update_text);
    }
    if (affinityAPIKey != "" && affinityAPIKey != "default") {
      let startup_name = activeFile.basename;
      for (let affinity_update of affinity_updates) {
        update_affinity_startup(startup_name, affinity_update);
      }
    }
  }
  get_updates_from_categories(text_with_category) {
    let updates = {};
    let lines = text_with_category.split("\n");
    for (let line of lines) {
      let chunks = line.split("::");
      let text = chunks[0];
      let category = chunks[1];
      if (!updates.hasOwnProperty(category)) {
        updates[category] = [text];
      } else {
        updates[category].push(text);
      }
    }
    return updates;
  }
  create_update_messages(updates) {
    let messages = [];
    let update_messages = {};
    const today = new Date();
    const currentDate = today.toISOString().split("T")[0];
    for (let [category, updates_array] of Object.entries(updates)) {
      let message = `###### ${category} updates on ${currentDate}
`;
      for (let update of updates_array) {
        message = message + "- " + update + "\n";
      }
      update_messages[category] = message;
    }
    return update_messages;
  }
  async categorize_notes(notes) {
    const response = await openai.chat.completions.create({
      model: gpt_4_latest2,
      messages: [
        {
          role: "system",
          content:
            "You are Frederick, an AI expert in classifying sentences. You are tasked with reading a sentence and deciding to which category it belongs. Remember you're the best AI sentence analyzer and will use your expertise to provide the best possible analysis.",
        },
        {
          role: "user",
          content: `I will give you some sentences about a startup, and you will analyze each sentence choose the right category. You have to choose from the following categories:
- Team: <describes the team behind the startup>
- Product: <describes the product the startup is developing>
- Competition: <describes the competition the startup is facing>
- Ideal Customer Profile: <describes the ideal customer for the startup>
- Funding: <describes the money raised by the startup and its investors>
- Market Size: <describes how big the market is>
- Commercial Traction: <describes the revenues of the startup>
- Other: <does not fit into any of the above categories>

For each sentence reply in the format of \`sentence::category\` Got it?`,
        },
        {
          role: "assistant",
          content:
            "Yes, I understand. I am ready to analyze your sentences and choose the correct category. I will reply in the format of `sentence::category`",
        },
        {
          role: "user",
          content: `Sentences:
"""${notes}"""`,
        },
      ],
      temperature: 0,
      max_tokens: 256,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });
    let reply = response.choices[0].message.content;
    if (reply == null) {
      reply = "";
    }
    return reply;
  }
  async analyze_pitch_deck(relative_path, editor) {
    let vault_path = "";
    let adapter = app.vault.adapter;
    if (adapter instanceof import_obsidian4.FileSystemAdapter) {
      vault_path = adapter.getBasePath();
    }
    console.log(vault_path);
    let absolute_path = vault_path + "/" + relative_path;
    this.status.setText("\u{1F9D1}\u200D\u{1F680}: VC Copilot analyzing deck");
    this.status.setAttr("title", "Copilot is analyzing");
    this.assistant_start_conv(absolute_path, editor);
  }
  async assistant_replace_citations(openai2, message) {
    let message_content = message.content[0].text;
    let annotations = message_content.annotations;
    let citations = [];
    for (let i = 0; i < annotations.length; i++) {
      let annotation = annotations[i];
      let annotation_text = annotation.text;
      message_content.value = await message_content.value.replace(
        annotation_text,
        `[${i + 1}]`
      );
      if (annotation.file_citation) {
        const cited_file = await openai2.files.retrieve(
          annotation.file_citation.file_id
        );
        citations.push(`##### [${i + 1}]
 ${annotation.file_citation.quote}
 **from ${cited_file.filename}**`);
      } else if (annotation.file_path) {
        const cited_file = await openai2.files.retrieve(
          annotation.file_path.file_id
        );
        citations.push(
          `##### [${i + 1}] Click <here> to download ${cited_file.filename}`
        );
      }
    }
    message_content.value += "\n\n#### Sources:\n" + citations.join("\n\n");
    return message;
  }
  async assistant_displaymessage(
    openai2,
    thread,
    run,
    messages,
    editor,
    editor_position
  ) {
    let message = messages.data[0];
    message = await this.assistant_replace_citations(openai2, message);
    let final_message = message.content[0].text.value;
    this.displaymessage(final_message, editor, editor_position);
  }
  async assistant_check_thread_status(
    openai2,
    thread,
    run,
    editor,
    editor_position
  ) {
    const run_status = await openai2.beta.threads.runs.retrieve(
      thread.id,
      run.id
    );
    console.log(run_status.status);
    if (run_status.status == "completed") {
      console.log("successful!");
      clearInterval(intervalId);
      const messages = await openai2.beta.threads.messages.list(thread.id);
      this.assistant_displaymessage(
        openai2,
        thread,
        run,
        messages,
        editor,
        editor_position
      );
    }
  }
  async assistant_start_conv(deck_path, editor) {
    let editor_position = editor.getCursor();
    let deck = await toFile3(fs.createReadStream(deck_path));
    const file = await openai.files.create({
      file: deck,
      purpose: "assistants",
    });
    const assistant = await openai.beta.assistants.create({
      name: "Deck Master",
      instructions:
        "You are a veteran venture capital investor. You are extremely analytical and detail-oriented. You always answer in nested bullet points. Always break down long bullet points into multiple short ones.",
      tools: [{ type: "retrieval" }],
      model: gpt_3_latest,
      file_ids: [file.id],
    });
    const thread = await openai.beta.threads.create();
    const message = await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content:
        "Read through this pitch deck. Extract the following information:\n- Team\n- Problem the startup is solving\n- Solution\n- Competition\n- Commercial Traction:\n- Market size",
      file_ids: [file.id],
    });
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: assistant.id,
    });
    intervalId = setInterval(
      () =>
        this.assistant_check_thread_status(
          openai,
          thread,
          run,
          editor,
          editor_position
        ),
      500
    );
  }
};
var VCCopilotSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for your copilot" });
    new import_obsidian4.Setting(containerEl)
      .setName("OpenAI API Key")
      .setDesc("Your OpenAI API Key")
      .addText((text) =>
        text
          .setPlaceholder("Enter key")
          .setValue(this.plugin.settings.openAIKey)
          .onChange(async (value) => {
            this.plugin.settings.openAIKey = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("TogetherAI API Key")
      .setDesc("Your TogetherAI API Key -- to use non-OpenAI Models")
      .addText((text) =>
        text
          .setPlaceholder("Enter key")
          .setValue(this.plugin.settings.togetherAIKey)
          .onChange(async (value) => {
            this.plugin.settings.togetherAIKey = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Groq API Key")
      .setDesc("Your Groq API Key")
      .addText((text) =>
        text
          .setPlaceholder("Enter key")
          .setValue(this.plugin.settings.groqAIKey)
          .onChange(async (value) => {
            this.plugin.settings.groqAIKey = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Affinity: API Key")
      .setDesc("Your Affinity API Key")
      .addText((text) =>
        text
          .setPlaceholder("Enter key")
          .setValue(this.plugin.settings.affinityKey)
          .onChange(async (value) => {
            this.plugin.settings.affinityKey = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Affinity: Owner Value")
      .setDesc(
        "Every person has a code on Affinity. Please give in the code for the person that should be added as owner of startups and VCs that gets pushed"
      )
      .addText((text) =>
        text
          .setPlaceholder("Enter value")
          .setValue(this.plugin.settings.owner_person_value)
          .onChange(async (value) => {
            this.plugin.settings.owner_person_value = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Affinity: Connection Owner Field ID")
      .setDesc(
        "Depending on the list you save fellow VCs in, there is a field that represent the 'connection owner with the fund', enter the field id here"
      )
      .addText((text) =>
        text
          .setPlaceholder("Enter value")
          .setValue(this.plugin.settings.connection_owner_field_id)
          .onChange(async (value) => {
            this.plugin.settings.connection_owner_field_id = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Affinity: Venture Network List ID")
      .setDesc(
        "Please enter the list id for the list you save your relationships with VCs in"
      )
      .addText((text) =>
        text
          .setPlaceholder("Enter value")
          .setValue(this.plugin.settings.venture_network_list_id)
          .onChange(async (value) => {
            this.plugin.settings.venture_network_list_id = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Investor Names")
      .setDesc(
        "Enter the names of your team members (investors) separated by a comma. This helps the Fireflies summarizer to focus more on the founder"
      )
      .addText((text) =>
        text
          .setValue(this.plugin.settings.team_names)
          .onChange(async (value) => {
            this.plugin.settings.team_names = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Fireflies API Key")
      .setDesc("Enter the Fireflies API Key")
      .addText((text) =>
        text
          .setValue(this.plugin.settings.fireflies_api)
          .onChange(async (value) => {
            this.plugin.settings.fireflies_api = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian4.Setting(containerEl)
      .setName("Tracxn API Key")
      .setDesc("Enter the Tracxn API Key")
      .addText((text) =>
        text
          .setValue(this.plugin.settings.tracxn_api)
          .onChange(async (value) => {
            this.plugin.settings.tracxn_api = value;
            await this.plugin.saveSettings();
          })
      );
  }
};
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
//! this will be weird if it happens
//!OpenAI does not support electron yet, this is a work around (https://github.com/openai/openai-node/issues/284)
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JpbmFyeS1zZWFyY2gvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL251bS1zb3J0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWNhbWVsaXplL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYW1lbGNhc2UvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnlfb3BlcmF0aW9uLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JldHJ5L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wLXJldHJ5L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wLWZpbmFsbHkvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtdGltZW91dC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L2xvd2VyLWJvdW5kLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wLXF1ZXVlL2Rpc3QvcHJpb3JpdHktcXVldWUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtcXVldWUvZGlzdC9pbmRleC5qcyIsICJzcmMvbWFpbi50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL3NpbWlsYXJpdGllcy9jemVrYW5vd3NraS50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL2Rpc3RhbmNlcy9kaWNlLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tbC1kaXN0YW5jZS9zcmMvZGlzdGFuY2VzL2ludGVyc2VjdGlvbi50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL3NpbWlsYXJpdGllcy9rdW1hckhhc3NlYnJvb2sudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlL3NyYy9kaXN0YW5jZXMva3VsY3p5bnNraS50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL2Rpc3RhbmNlcy9tb3R5a2EudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlL3NyYy9kaXN0YW5jZXMvc3F1YXJlZENob3JkLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tbC1kaXN0YW5jZS9zcmMvc2ltaWxhcml0aWVzL3Rhbmltb3RvLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tbC1kaXN0YW5jZS9zcmMvc2ltaWxhcml0aWVzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tbC10cmVlLXNpbWlsYXJpdHkvc3JjL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tbC10cmVlLXNpbWlsYXJpdHkvc3JjL2NyZWF0ZVRyZWUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLXRyZWUtc2ltaWxhcml0eS9zcmMvZ2V0U2ltaWxhcml0eS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL3NpbWlsYXJpdGllcy9jb3NpbmUudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlL3NyYy9zaW1pbGFyaXRpZXMvZGljZS50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL3NpbWlsYXJpdGllcy9pbnRlcnNlY3Rpb24udHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlL3NyYy9zaW1pbGFyaXRpZXMva3VsY3p5bnNraS50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL3NpbWlsYXJpdGllcy9tb3R5a2EudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWFueS1hcnJheS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLWFycmF5LXN1bS9saWItZXM2L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tbC1hcnJheS1tZWFuL2xpYi1lczYvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlL3NyYy9zaW1pbGFyaXRpZXMvcGVhcnNvbi50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWwtZGlzdGFuY2Uvc3JjL3NpbWlsYXJpdGllcy9zcXVhcmVkQ2hvcmQudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L2xvYWQvbWFwX2tleXMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L2xvYWQvc2VyaWFsaXphYmxlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC9jYWxsYmFja3MvYmFzZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2FsbGJhY2tzL2hhbmRsZXJzL2NvbnNvbGUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L2NhbGxiYWNrcy9oYW5kbGVycy90cmFjZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Vudi5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC91dGlsL2Vudi5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2FsbGJhY2tzL2hhbmRsZXJzL3RyYWNlcl9sYW5nY2hhaW4uanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L21lbW9yeS9iYXNlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC9jYWxsYmFja3MvaGFuZGxlcnMvdHJhY2VyX2xhbmdjaGFpbl92MS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2FsbGJhY2tzL2hhbmRsZXJzL2luaXRpYWxpemUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L2NhbGxiYWNrcy9wcm9taXNlcy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3NjaGVtYS9ydW5uYWJsZS9iYXNlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC91dGlsL2Zhc3QtanNvbi1wYXRjaC9zcmMvY29yZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdXRpbC9mYXN0LWpzb24tcGF0Y2gvc3JjL2hlbHBlcnMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3V0aWwvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3V0aWwvZmFzdC1qc29uLXBhdGNoL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC91dGlsL3N0cmVhbS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2FsbGJhY2tzL2hhbmRsZXJzL2xvZ19zdHJlYW0uanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3NjaGVtYS9ydW5uYWJsZS9jb25maWcuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3V0aWwvYXN5bmNfY2FsbGVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC9zY2hlbWEvcmV0cmlldmVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC92ZWN0b3JzdG9yZXMvYmFzZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZG9jdW1lbnQuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3ZlY3RvcnN0b3Jlcy9tZW1vcnkuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy92ZXJzaW9uLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3JlZ2lzdHJ5LnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvd2ViLXJ1bnRpbWUudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL19zaGltcy9pbmRleC5tanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9lcnJvci50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3VwbG9hZHMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9jb3JlLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jaGF0LnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3NwZWVjaC50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2NyaXB0aW9ucy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2xhdGlvbnMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vYXVkaW8udHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9hc3Npc3RhbnRzL2ZpbGVzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvYXNzaXN0YW50cy9hc3Npc3RhbnRzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL1J1bm5hYmxlRnVuY3Rpb24udHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvY2hhdENvbXBsZXRpb25VdGlscy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvY2hhdC9jb21wbGV0aW9ucy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2NoYXQvY2hhdC50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvbWVzc2FnZXMvZmlsZXMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL21lc3NhZ2VzL21lc3NhZ2VzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3N0ZXBzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3J1bnMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3RocmVhZHMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9iZXRhLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VtYmVkZGluZ3MudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZWRpdHMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmlsZXMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5lcy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9maW5lLXR1bmluZy9qb2JzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2ZpbmUtdHVuaW5nLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vbm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL25vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlbHMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZXJhdGlvbnMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9ub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdXRpbC9jaHVuay5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZW1iZWRkaW5ncy9iYXNlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC91dGlsL2F6dXJlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC91dGlsL29wZW5haS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZW1iZWRkaW5ncy9vcGVuYWkuanMiLCAic3JjL3V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3JlZ2lzdHJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL19zaGltcy9NdWx0aXBhcnRCb2R5LnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL19zaGltcy93ZWItcnVudGltZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL19zaGltcy9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvc3RyZWFtaW5nLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3VwbG9hZHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvY29yZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9wYWdpbmF0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9jaGF0L2NoYXQudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3NwZWVjaC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vdHJhbnNjcmlwdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zbGF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vYXVkaW8udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvYXNzaXN0YW50cy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9hc3Npc3RhbnRzL2Fzc2lzdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL1J1bm5hYmxlRnVuY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL2NoYXRDb21wbGV0aW9uVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvY2hhdC9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9jaGF0L2NoYXQudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9tZXNzYWdlcy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL21lc3NhZ2VzL21lc3NhZ2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9zdGVwcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3J1bnMvcnVucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3RocmVhZHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvYmV0YS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY29tcGxldGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VtYmVkZGluZ3MudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VkaXRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5lcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbmRleC50cyIsICJzcmMvbW9kYWwudHMiLCAic3JjL2Zvcm1hdHRlci5qcyIsICJzcmMvc2VhcmNoLnRzIiwgInNyYy9wcm9tcHRzLmpzIiwgInNyYy9maXJlZmxpZXMudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy92ZXJzaW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvX3NoaW1zL3JlZ2lzdHJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9fc2hpbXMvd2ViLXJ1bnRpbWUudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL19zaGltcy9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9lcnJvci50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL2xpYi9zdHJlYW1pbmcudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvY29yZS50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL3Jlc291cmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9yZXNvdXJjZXMvY2hhdC9jaGF0LnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvcmVzb3VyY2VzL21vZGVscy50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2NyaXB0aW9ucy50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2xhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9yZXNvdXJjZXMvYXVkaW8vYXVkaW8udHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlLCBjb21wYXJhdG9yLCBsb3csIGhpZ2gpIHtcbiAgdmFyIG1pZCwgY21wO1xuXG4gIGlmKGxvdyA9PT0gdW5kZWZpbmVkKVxuICAgIGxvdyA9IDA7XG5cbiAgZWxzZSB7XG4gICAgbG93ID0gbG93fDA7XG4gICAgaWYobG93IDwgMCB8fCBsb3cgPj0gaGF5c3RhY2subGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGxvd2VyIGJvdW5kXCIpO1xuICB9XG5cbiAgaWYoaGlnaCA9PT0gdW5kZWZpbmVkKVxuICAgIGhpZ2ggPSBoYXlzdGFjay5sZW5ndGggLSAxO1xuXG4gIGVsc2Uge1xuICAgIGhpZ2ggPSBoaWdofDA7XG4gICAgaWYoaGlnaCA8IGxvdyB8fCBoaWdoID49IGhheXN0YWNrLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCB1cHBlciBib3VuZFwiKTtcbiAgfVxuXG4gIHdoaWxlKGxvdyA8PSBoaWdoKSB7XG4gICAgLy8gVGhlIG5haXZlIGBsb3cgKyBoaWdoID4+PiAxYCBjb3VsZCBmYWlsIGZvciBhcnJheSBsZW5ndGhzID4gMioqMzFcbiAgICAvLyBiZWNhdXNlIGA+Pj5gIGNvbnZlcnRzIGl0cyBvcGVyYW5kcyB0byBpbnQzMi4gYGxvdyArIChoaWdoIC0gbG93ID4+PiAxKWBcbiAgICAvLyB3b3JrcyBmb3IgYXJyYXkgbGVuZ3RocyA8PSAyKiozMi0xIHdoaWNoIGlzIGFsc28gSmF2YXNjcmlwdCdzIG1heCBhcnJheVxuICAgIC8vIGxlbmd0aC5cbiAgICBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+PiAxKTtcbiAgICBjbXAgPSArY29tcGFyYXRvcihoYXlzdGFja1ttaWRdLCBuZWVkbGUsIG1pZCwgaGF5c3RhY2spO1xuXG4gICAgLy8gVG9vIGxvdy5cbiAgICBpZihjbXAgPCAwLjApXG4gICAgICBsb3cgID0gbWlkICsgMTtcblxuICAgIC8vIFRvbyBoaWdoLlxuICAgIGVsc2UgaWYoY21wID4gMC4wKVxuICAgICAgaGlnaCA9IG1pZCAtIDE7XG5cbiAgICAvLyBLZXkgZm91bmQuXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG1pZDtcbiAgfVxuXG4gIC8vIEtleSBub3QgZm91bmQuXG4gIHJldHVybiB+bG93O1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG51bWJlcikge1xuXHRpZiAodHlwZW9mIG51bWJlciAhPT0gJ251bWJlcicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIG51bWJlcicpO1xuXHR9XG59XG5cbmV4cG9ydHMuYXNjZW5kaW5nID0gKGxlZnQsIHJpZ2h0KSA9PiB7XG5cdGFzc2VydE51bWJlcihsZWZ0KTtcblx0YXNzZXJ0TnVtYmVyKHJpZ2h0KTtcblxuXHRpZiAoTnVtYmVyLmlzTmFOKGxlZnQpKSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0aWYgKE51bWJlci5pc05hTihyaWdodCkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdHJldHVybiBsZWZ0IC0gcmlnaHQ7XG59O1xuXG5leHBvcnRzLmRlc2NlbmRpbmcgPSAobGVmdCwgcmlnaHQpID0+IHtcblx0YXNzZXJ0TnVtYmVyKGxlZnQpO1xuXHRhc3NlcnROdW1iZXIocmlnaHQpO1xuXG5cdGlmIChOdW1iZXIuaXNOYU4obGVmdCkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmIChOdW1iZXIuaXNOYU4ocmlnaHQpKSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0cmV0dXJuIHJpZ2h0IC0gbGVmdDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBzZXApIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHNlcCA9IHR5cGVvZiBzZXAgPT09ICd1bmRlZmluZWQnID8gJ18nIDogc2VwO1xuXG5cdHJldHVybiBzdHJcblx0XHQucmVwbGFjZSgvKFthLXpcXGRdKShbQS1aXSkvZywgJyQxJyArIHNlcCArICckMicpXG5cdFx0LnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2EtelxcZF0rKS9nLCAnJDEnICsgc2VwICsgJyQyJylcblx0XHQudG9Mb3dlckNhc2UoKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVUFBFUkNBU0UgPSAvW1xccHtMdX1dL3U7XG5jb25zdCBMT1dFUkNBU0UgPSAvW1xccHtMbH1dL3U7XG5jb25zdCBMRUFESU5HX0NBUElUQUwgPSAvXltcXHB7THV9XSg/IVtcXHB7THV9XSkvZ3U7XG5jb25zdCBJREVOVElGSUVSID0gLyhbXFxwe0FscGhhfVxccHtOfV9dfCQpL3U7XG5jb25zdCBTRVBBUkFUT1JTID0gL1tfLlxcLSBdKy87XG5cbmNvbnN0IExFQURJTkdfU0VQQVJBVE9SUyA9IG5ldyBSZWdFeHAoJ14nICsgU0VQQVJBVE9SUy5zb3VyY2UpO1xuY29uc3QgU0VQQVJBVE9SU19BTkRfSURFTlRJRklFUiA9IG5ldyBSZWdFeHAoU0VQQVJBVE9SUy5zb3VyY2UgKyBJREVOVElGSUVSLnNvdXJjZSwgJ2d1Jyk7XG5jb25zdCBOVU1CRVJTX0FORF9JREVOVElGSUVSID0gbmV3IFJlZ0V4cCgnXFxcXGQrJyArIElERU5USUZJRVIuc291cmNlLCAnZ3UnKTtcblxuY29uc3QgcHJlc2VydmVDYW1lbENhc2UgPSAoc3RyaW5nLCB0b0xvd2VyQ2FzZSwgdG9VcHBlckNhc2UpID0+IHtcblx0bGV0IGlzTGFzdENoYXJMb3dlciA9IGZhbHNlO1xuXHRsZXQgaXNMYXN0Q2hhclVwcGVyID0gZmFsc2U7XG5cdGxldCBpc0xhc3RMYXN0Q2hhclVwcGVyID0gZmFsc2U7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjaGFyYWN0ZXIgPSBzdHJpbmdbaV07XG5cblx0XHRpZiAoaXNMYXN0Q2hhckxvd2VyICYmIFVQUEVSQ0FTRS50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBpKSArICctJyArIHN0cmluZy5zbGljZShpKTtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IGZhbHNlO1xuXHRcdFx0aXNMYXN0TGFzdENoYXJVcHBlciA9IGlzTGFzdENoYXJVcHBlcjtcblx0XHRcdGlzTGFzdENoYXJVcHBlciA9IHRydWU7XG5cdFx0XHRpKys7XG5cdFx0fSBlbHNlIGlmIChpc0xhc3RDaGFyVXBwZXIgJiYgaXNMYXN0TGFzdENoYXJVcHBlciAmJiBMT1dFUkNBU0UudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgaSAtIDEpICsgJy0nICsgc3RyaW5nLnNsaWNlKGkgLSAxKTtcblx0XHRcdGlzTGFzdExhc3RDaGFyVXBwZXIgPSBpc0xhc3RDaGFyVXBwZXI7XG5cdFx0XHRpc0xhc3RDaGFyVXBwZXIgPSBmYWxzZTtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IHRvTG93ZXJDYXNlKGNoYXJhY3RlcikgPT09IGNoYXJhY3RlciAmJiB0b1VwcGVyQ2FzZShjaGFyYWN0ZXIpICE9PSBjaGFyYWN0ZXI7XG5cdFx0XHRpc0xhc3RMYXN0Q2hhclVwcGVyID0gaXNMYXN0Q2hhclVwcGVyO1xuXHRcdFx0aXNMYXN0Q2hhclVwcGVyID0gdG9VcHBlckNhc2UoY2hhcmFjdGVyKSA9PT0gY2hhcmFjdGVyICYmIHRvTG93ZXJDYXNlKGNoYXJhY3RlcikgIT09IGNoYXJhY3Rlcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyaW5nO1xufTtcblxuY29uc3QgcHJlc2VydmVDb25zZWN1dGl2ZVVwcGVyY2FzZSA9IChpbnB1dCwgdG9Mb3dlckNhc2UpID0+IHtcblx0TEVBRElOR19DQVBJVEFMLmxhc3RJbmRleCA9IDA7XG5cblx0cmV0dXJuIGlucHV0LnJlcGxhY2UoTEVBRElOR19DQVBJVEFMLCBtMSA9PiB0b0xvd2VyQ2FzZShtMSkpO1xufTtcblxuY29uc3QgcG9zdFByb2Nlc3MgPSAoaW5wdXQsIHRvVXBwZXJDYXNlKSA9PiB7XG5cdFNFUEFSQVRPUlNfQU5EX0lERU5USUZJRVIubGFzdEluZGV4ID0gMDtcblx0TlVNQkVSU19BTkRfSURFTlRJRklFUi5sYXN0SW5kZXggPSAwO1xuXG5cdHJldHVybiBpbnB1dC5yZXBsYWNlKFNFUEFSQVRPUlNfQU5EX0lERU5USUZJRVIsIChfLCBpZGVudGlmaWVyKSA9PiB0b1VwcGVyQ2FzZShpZGVudGlmaWVyKSlcblx0XHQucmVwbGFjZShOVU1CRVJTX0FORF9JREVOVElGSUVSLCBtID0+IHRvVXBwZXJDYXNlKG0pKTtcbn07XG5cbmNvbnN0IGNhbWVsQ2FzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoISh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoaW5wdXQpKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBpbnB1dCB0byBiZSBgc3RyaW5nIHwgc3RyaW5nW11gJyk7XG5cdH1cblxuXHRvcHRpb25zID0ge1xuXHRcdHBhc2NhbENhc2U6IGZhbHNlLFxuXHRcdHByZXNlcnZlQ29uc2VjdXRpdmVVcHBlcmNhc2U6IGZhbHNlLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0XHRpbnB1dCA9IGlucHV0Lm1hcCh4ID0+IHgudHJpbSgpKVxuXHRcdFx0LmZpbHRlcih4ID0+IHgubGVuZ3RoKVxuXHRcdFx0LmpvaW4oJy0nKTtcblx0fSBlbHNlIHtcblx0XHRpbnB1dCA9IGlucHV0LnRyaW0oKTtcblx0fVxuXG5cdGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRjb25zdCB0b0xvd2VyQ2FzZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/XG5cdFx0c3RyaW5nID0+IHN0cmluZy50b0xvd2VyQ2FzZSgpIDpcblx0XHRzdHJpbmcgPT4gc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKG9wdGlvbnMubG9jYWxlKTtcblx0Y29uc3QgdG9VcHBlckNhc2UgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgP1xuXHRcdHN0cmluZyA9PiBzdHJpbmcudG9VcHBlckNhc2UoKSA6XG5cdFx0c3RyaW5nID0+IHN0cmluZy50b0xvY2FsZVVwcGVyQ2FzZShvcHRpb25zLmxvY2FsZSk7XG5cblx0aWYgKGlucHV0Lmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiBvcHRpb25zLnBhc2NhbENhc2UgPyB0b1VwcGVyQ2FzZShpbnB1dCkgOiB0b0xvd2VyQ2FzZShpbnB1dCk7XG5cdH1cblxuXHRjb25zdCBoYXNVcHBlckNhc2UgPSBpbnB1dCAhPT0gdG9Mb3dlckNhc2UoaW5wdXQpO1xuXG5cdGlmIChoYXNVcHBlckNhc2UpIHtcblx0XHRpbnB1dCA9IHByZXNlcnZlQ2FtZWxDYXNlKGlucHV0LCB0b0xvd2VyQ2FzZSwgdG9VcHBlckNhc2UpO1xuXHR9XG5cblx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKExFQURJTkdfU0VQQVJBVE9SUywgJycpO1xuXG5cdGlmIChvcHRpb25zLnByZXNlcnZlQ29uc2VjdXRpdmVVcHBlcmNhc2UpIHtcblx0XHRpbnB1dCA9IHByZXNlcnZlQ29uc2VjdXRpdmVVcHBlcmNhc2UoaW5wdXQsIHRvTG93ZXJDYXNlKTtcblx0fSBlbHNlIHtcblx0XHRpbnB1dCA9IHRvTG93ZXJDYXNlKGlucHV0KTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnBhc2NhbENhc2UpIHtcblx0XHRpbnB1dCA9IHRvVXBwZXJDYXNlKGlucHV0LmNoYXJBdCgwKSkgKyBpbnB1dC5zbGljZSgxKTtcblx0fVxuXG5cdHJldHVybiBwb3N0UHJvY2VzcyhpbnB1dCwgdG9VcHBlckNhc2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbENhc2U7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGNhbWVsQ2FzZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFOU0lfQkFDS0dST1VORF9PRkZTRVQgPSAxMDtcblxuY29uc3Qgd3JhcEFuc2kyNTYgPSAob2Zmc2V0ID0gMCkgPT4gY29kZSA9PiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcblxuY29uc3Qgd3JhcEFuc2kxNm0gPSAob2Zmc2V0ID0gMCkgPT4gKHJlZCwgZ3JlZW4sIGJsdWUpID0+IGBcXHUwMDFCWyR7MzggKyBvZmZzZXR9OzI7JHtyZWR9OyR7Z3JlZW59OyR7Ymx1ZX1tYDtcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMoKSB7XG5cdGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXI6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHQvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRib2xkOiBbMSwgMjJdLFxuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0b3ZlcmxpbmU6IFs1MywgNTVdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRibGFja0JyaWdodDogWzkwLCAzOV0sXG5cdFx0XHRyZWRCcmlnaHQ6IFs5MSwgMzldLFxuXHRcdFx0Z3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuXHRcdFx0eWVsbG93QnJpZ2h0OiBbOTMsIDM5XSxcblx0XHRcdGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuXHRcdFx0bWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG5cdFx0XHRjeWFuQnJpZ2h0OiBbOTYsIDM5XSxcblx0XHRcdHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcjoge1xuXHRcdFx0YmdCbGFjazogWzQwLCA0OV0sXG5cdFx0XHRiZ1JlZDogWzQxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93OiBbNDMsIDQ5XSxcblx0XHRcdGJnQmx1ZTogWzQ0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRcdFx0YmdDeWFuOiBbNDYsIDQ5XSxcblx0XHRcdGJnV2hpdGU6IFs0NywgNDldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcblx0XHRcdGJnUmVkQnJpZ2h0OiBbMTAxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG5cdFx0XHRiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuXHRcdFx0YmdCbHVlQnJpZ2h0OiBbMTA0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcblx0XHRcdGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuXHRcdFx0YmdXaGl0ZUJyaWdodDogWzEwNywgNDldXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFsaWFzIGJyaWdodCBibGFjayBhcyBncmF5IChhbmQgZ3JleSlcblx0c3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXG5cdGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcblx0XHRmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhncm91cCkpIHtcblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiBgXFx1MDAxQlske3N0eWxlWzBdfW1gLFxuXHRcdFx0XHRjbG9zZTogYFxcdTAwMUJbJHtzdHlsZVsxXX1tYFxuXHRcdFx0fTtcblxuXHRcdFx0Z3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG5cdFx0XHRjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7XG5cdFx0dmFsdWU6IGNvZGVzLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pO1xuXG5cdHN0eWxlcy5jb2xvci5jbG9zZSA9ICdcXHUwMDFCWzM5bSc7XG5cdHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcblxuXHRzdHlsZXMuY29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KCk7XG5cdHN0eWxlcy5jb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oKTtcblx0c3R5bGVzLmJnQ29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KEFOU0lfQkFDS0dST1VORF9PRkZTRVQpO1xuXHRzdHlsZXMuYmdDb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oQU5TSV9CQUNLR1JPVU5EX09GRlNFVCk7XG5cblx0Ly8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vUWl4LS9jb2xvci1jb252ZXJ0L2Jsb2IvM2YwZTBkNGU5MmUyMzU3OTZjY2IxN2Y2ZTg1YzcyMDk0YTY1MWY0OS9jb252ZXJzaW9ucy5qc1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHlsZXMsIHtcblx0XHRyZ2JUb0Fuc2kyNTY6IHtcblx0XHRcdHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4ge1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHRcdFx0XHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0XHRcdFx0aWYgKHJlZCA9PT0gZ3JlZW4gJiYgZ3JlZW4gPT09IGJsdWUpIHtcblx0XHRcdFx0XHRpZiAocmVkIDwgOCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDE2O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChyZWQgPiAyNDgpIHtcblx0XHRcdFx0XHRcdHJldHVybiAyMzE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKChyZWQgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMTYgK1xuXHRcdFx0XHRcdCgzNiAqIE1hdGgucm91bmQocmVkIC8gMjU1ICogNSkpICtcblx0XHRcdFx0XHQoNiAqIE1hdGgucm91bmQoZ3JlZW4gLyAyNTUgKiA1KSkgK1xuXHRcdFx0XHRcdE1hdGgucm91bmQoYmx1ZSAvIDI1NSAqIDUpO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSxcblx0XHRoZXhUb1JnYjoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiB7XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXMgPSAvKD88Y29sb3JTdHJpbmc+W2EtZlxcZF17Nn18W2EtZlxcZF17M30pL2kuZXhlYyhoZXgudG9TdHJpbmcoMTYpKTtcblx0XHRcdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB7Y29sb3JTdHJpbmd9ID0gbWF0Y2hlcy5ncm91cHM7XG5cblx0XHRcdFx0aWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChjaGFyYWN0ZXIgPT4gY2hhcmFjdGVyICsgY2hhcmFjdGVyKS5qb2luKCcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGludGVnZXIgPSBOdW1iZXIucGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdChpbnRlZ2VyID4+IDE2KSAmIDB4RkYsXG5cdFx0XHRcdFx0KGludGVnZXIgPj4gOCkgJiAweEZGLFxuXHRcdFx0XHRcdGludGVnZXIgJiAweEZGXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9LFxuXHRcdGhleFRvQW5zaTI1Njoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiBzdHlsZXMucmdiVG9BbnNpMjU2KC4uLnN0eWxlcy5oZXhUb1JnYihoZXgpKSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG4vLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG4iLCAiZnVuY3Rpb24gUmV0cnlPcGVyYXRpb24odGltZW91dHMsIG9wdGlvbnMpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCAodGltZW91dHMsIHJldHJ5Rm9yZXZlcikgc2lnbmF0dXJlXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHsgZm9yZXZlcjogb3B0aW9ucyB9O1xuICB9XG5cbiAgdGhpcy5fb3JpZ2luYWxUaW1lb3V0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGltZW91dHMpKTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aW1lb3V0cztcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX21heFJldHJ5VGltZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWUgfHwgSW5maW5pdHk7XG4gIHRoaXMuX2ZuID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JzID0gW107XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IG51bGw7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IG51bGw7XG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25TdGFydCA9IG51bGw7XG4gIHRoaXMuX3RpbWVyID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5mb3JldmVyKSB7XG4gICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSB0aGlzLl90aW1lb3V0cy5zbGljZSgwKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeU9wZXJhdGlvbjtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aGlzLl9vcmlnaW5hbFRpbWVvdXRzLnNsaWNlKDApO1xufVxuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG5cbiAgdGhpcy5fdGltZW91dHMgICAgICAgPSBbXTtcbiAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSBudWxsO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICB9XG5cbiAgaWYgKCFlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmIChlcnIgJiYgY3VycmVudFRpbWUgLSB0aGlzLl9vcGVyYXRpb25TdGFydCA+PSB0aGlzLl9tYXhSZXRyeVRpbWUpIHtcbiAgICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuICAgIHRoaXMuX2Vycm9ycy51bnNoaWZ0KG5ldyBFcnJvcignUmV0cnlPcGVyYXRpb24gdGltZW91dCBvY2N1cnJlZCcpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuXG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dHMuc2hpZnQoKTtcbiAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRUaW1lb3V0cykge1xuICAgICAgLy8gcmV0cnkgZm9yZXZlciwgb25seSBrZWVwIGxhc3QgZXJyb3JcbiAgICAgIHRoaXMuX2Vycm9ycy5zcGxpY2UoMCwgdGhpcy5fZXJyb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgdGltZW91dCA9IHRoaXMuX2NhY2hlZFRpbWVvdXRzLnNsaWNlKC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2F0dGVtcHRzKys7XG5cbiAgICBpZiAoc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgICBzZWxmLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKHNlbGYuX2F0dGVtcHRzKTtcbiAgICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuXG4gICAgICBpZiAoc2VsZi5fb3B0aW9ucy51bnJlZikge1xuICAgICAgICAgIHNlbGYuX3RpbWVvdXQudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLl9mbihzZWxmLl9hdHRlbXB0cyk7XG4gIH0sIHRpbWVvdXQpO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICB0aGlzLl90aW1lci51bnJlZigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdCA9IGZ1bmN0aW9uKGZuLCB0aW1lb3V0T3BzKSB7XG4gIHRoaXMuX2ZuID0gZm47XG5cbiAgaWYgKHRpbWVvdXRPcHMpIHtcbiAgICBpZiAodGltZW91dE9wcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0ID0gdGltZW91dE9wcy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAodGltZW91dE9wcy5jYikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dENiID0gdGltZW91dE9wcy5jYjtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYigpO1xuICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuICB9XG5cbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICB0aGlzLl9mbih0aGlzLl9hdHRlbXB0cyk7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIFJldHJ5T3BlcmF0aW9uLnRyeSgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi5zdGFydCgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnk7XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXR0ZW1wdHM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUubWFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY291bnRzID0ge307XG4gIHZhciBtYWluRXJyb3IgPSBudWxsO1xuICB2YXIgbWFpbkVycm9yQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5fZXJyb3JzW2ldO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB2YXIgY291bnQgPSAoY291bnRzW21lc3NhZ2VdIHx8IDApICsgMTtcblxuICAgIGNvdW50c1ttZXNzYWdlXSA9IGNvdW50O1xuXG4gICAgaWYgKGNvdW50ID49IG1haW5FcnJvckNvdW50KSB7XG4gICAgICBtYWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIG1haW5FcnJvckNvdW50ID0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1haW5FcnJvcjtcbn07XG4iLCAidmFyIFJldHJ5T3BlcmF0aW9uID0gcmVxdWlyZSgnLi9yZXRyeV9vcGVyYXRpb24nKTtcblxuZXhwb3J0cy5vcGVyYXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0cyA9IGV4cG9ydHMudGltZW91dHMob3B0aW9ucyk7XG4gIHJldHVybiBuZXcgUmV0cnlPcGVyYXRpb24odGltZW91dHMsIHtcbiAgICAgIGZvcmV2ZXI6IG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9yZXZlciB8fCBvcHRpb25zLnJldHJpZXMgPT09IEluZmluaXR5KSxcbiAgICAgIHVucmVmOiBvcHRpb25zICYmIG9wdGlvbnMudW5yZWYsXG4gICAgICBtYXhSZXRyeVRpbWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWVcbiAgfSk7XG59O1xuXG5leHBvcnRzLnRpbWVvdXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBvcHRzID0ge1xuICAgIHJldHJpZXM6IDEwLFxuICAgIGZhY3RvcjogMixcbiAgICBtaW5UaW1lb3V0OiAxICogMTAwMCxcbiAgICBtYXhUaW1lb3V0OiBJbmZpbml0eSxcbiAgICByYW5kb21pemU6IGZhbHNlXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgaWYgKG9wdHMubWluVGltZW91dCA+IG9wdHMubWF4VGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluVGltZW91dCBpcyBncmVhdGVyIHRoYW4gbWF4VGltZW91dCcpO1xuICB9XG5cbiAgdmFyIHRpbWVvdXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5yZXRyaWVzOyBpKyspIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcmV2ZXIgJiYgIXRpbWVvdXRzLmxlbmd0aCkge1xuICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgfVxuXG4gIC8vIHNvcnQgdGhlIGFycmF5IG51bWVyaWNhbGx5IGFzY2VuZGluZ1xuICB0aW1lb3V0cy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWVvdXRzO1xufTtcblxuZXhwb3J0cy5jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24oYXR0ZW1wdCwgb3B0cykge1xuICB2YXIgcmFuZG9tID0gKG9wdHMucmFuZG9taXplKVxuICAgID8gKE1hdGgucmFuZG9tKCkgKyAxKVxuICAgIDogMTtcblxuICB2YXIgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tICogTWF0aC5tYXgob3B0cy5taW5UaW1lb3V0LCAxKSAqIE1hdGgucG93KG9wdHMuZmFjdG9yLCBhdHRlbXB0KSk7XG4gIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCBvcHRzLm1heFRpbWVvdXQpO1xuXG4gIHJldHVybiB0aW1lb3V0O1xufTtcblxuZXhwb3J0cy53cmFwID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBtZXRob2RzKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBtZXRob2RzID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghbWV0aG9kcykge1xuICAgIG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZXRob2QgICA9IG1ldGhvZHNbaV07XG4gICAgdmFyIG9yaWdpbmFsID0gb2JqW21ldGhvZF07XG5cbiAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uIHJldHJ5V3JhcHBlcihvcmlnaW5hbCkge1xuICAgICAgdmFyIG9wICAgICAgID0gZXhwb3J0cy5vcGVyYXRpb24ob3B0aW9ucyk7XG4gICAgICB2YXIgYXJncyAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAob3AucmV0cnkoZXJyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gb3AubWFpbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBvcC5hdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbC5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfS5iaW5kKG9iaiwgb3JpZ2luYWwpO1xuICAgIG9ialttZXRob2RdLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG59O1xuIiwgIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmV0cnknKTsiLCAiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdyZXRyeScpO1xuXG5jb25zdCBuZXR3b3JrRXJyb3JNc2dzID0gW1xuXHQnRmFpbGVkIHRvIGZldGNoJywgLy8gQ2hyb21lXG5cdCdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicsIC8vIEZpcmVmb3hcblx0J1RoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS4nLCAvLyBTYWZhcmlcblx0J05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnIC8vIGBjcm9zcy1mZXRjaGBcbl07XG5cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0aWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gbWVzc2FnZTtcblx0XHRcdCh7bWVzc2FnZX0gPSBtZXNzYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yLnN0YWNrID0gdGhpcy5zdGFjaztcblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcic7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxufVxuXG5jb25zdCBkZWNvcmF0ZUVycm9yV2l0aENvdW50cyA9IChlcnJvciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgPT4ge1xuXHQvLyBNaW51cyAxIGZyb20gYXR0ZW1wdE51bWJlciBiZWNhdXNlIHRoZSBmaXJzdCBhdHRlbXB0IGRvZXMgbm90IGNvdW50IGFzIGEgcmV0cnlcblx0Y29uc3QgcmV0cmllc0xlZnQgPSBvcHRpb25zLnJldHJpZXMgLSAoYXR0ZW1wdE51bWJlciAtIDEpO1xuXG5cdGVycm9yLmF0dGVtcHROdW1iZXIgPSBhdHRlbXB0TnVtYmVyO1xuXHRlcnJvci5yZXRyaWVzTGVmdCA9IHJldHJpZXNMZWZ0O1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBpc05ldHdvcmtFcnJvciA9IGVycm9yTWVzc2FnZSA9PiBuZXR3b3JrRXJyb3JNc2dzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSk7XG5cbmNvbnN0IHBSZXRyeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdG9uRmFpbGVkQXR0ZW1wdDogKCkgPT4ge30sXG5cdFx0cmV0cmllczogMTAsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IG9wZXJhdGlvbiA9IHJldHJ5Lm9wZXJhdGlvbihvcHRpb25zKTtcblxuXHRvcGVyYXRpb24uYXR0ZW1wdChhc3luYyBhdHRlbXB0TnVtYmVyID0+IHtcblx0XHR0cnkge1xuXHRcdFx0cmVzb2x2ZShhd2FpdCBpbnB1dChhdHRlbXB0TnVtYmVyKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG5cdFx0XHRcdHJlamVjdChuZXcgVHlwZUVycm9yKGBOb24tZXJyb3Igd2FzIHRocm93bjogXCIke2Vycm9yfVwiLiBZb3Ugc2hvdWxkIG9ubHkgdGhyb3cgZXJyb3JzLmApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBBYm9ydEVycm9yKSB7XG5cdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHJlamVjdChlcnJvci5vcmlnaW5hbEVycm9yKTtcblx0XHRcdH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgIWlzTmV0d29ya0Vycm9yKGVycm9yLm1lc3NhZ2UpKSB7XG5cdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWNvcmF0ZUVycm9yV2l0aENvdW50cyhlcnJvciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucyk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBvcHRpb25zLm9uRmFpbGVkQXR0ZW1wdChlcnJvcik7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIW9wZXJhdGlvbi5yZXRyeShlcnJvcikpIHtcblx0XHRcdFx0XHRyZWplY3Qob3BlcmF0aW9uLm1haW5FcnJvcigpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwUmV0cnk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFJldHJ5O1xuXG5tb2R1bGUuZXhwb3J0cy5BYm9ydEVycm9yID0gQWJvcnRFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSAocHJvbWlzZSwgb25GaW5hbGx5KSA9PiB7XG5cdG9uRmluYWxseSA9IG9uRmluYWxseSB8fCAoKCkgPT4ge30pO1xuXG5cdHJldHVybiBwcm9taXNlLnRoZW4oXG5cdFx0dmFsID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdFx0cmVzb2x2ZShvbkZpbmFsbHkoKSk7XG5cdFx0fSkudGhlbigoKSA9PiB2YWwpLFxuXHRcdGVyciA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdHJlc29sdmUob25GaW5hbGx5KCkpO1xuXHRcdH0pLnRoZW4oKCkgPT4ge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH0pXG5cdCk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcEZpbmFsbHkgPSByZXF1aXJlKCdwLWZpbmFsbHknKTtcblxuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG5cdH1cbn1cblxuY29uc3QgcFRpbWVvdXQgPSAocHJvbWlzZSwgbWlsbGlzZWNvbmRzLCBmYWxsYmFjaykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAodHlwZW9mIG1pbGxpc2Vjb25kcyAhPT0gJ251bWJlcicgfHwgbWlsbGlzZWNvbmRzIDwgMCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBtaWxsaXNlY29uZHNgIHRvIGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG5cdH1cblxuXHRpZiAobWlsbGlzZWNvbmRzID09PSBJbmZpbml0eSkge1xuXHRcdHJlc29sdmUocHJvbWlzZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlKGZhbGxiYWNrKCkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdzdHJpbmcnID8gZmFsbGJhY2sgOiBgUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgJHttaWxsaXNlY29uZHN9IG1pbGxpc2Vjb25kc2A7XG5cdFx0Y29uc3QgdGltZW91dEVycm9yID0gZmFsbGJhY2sgaW5zdGFuY2VvZiBFcnJvciA/IGZhbGxiYWNrIDogbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcblxuXHRcdGlmICh0eXBlb2YgcHJvbWlzZS5jYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHByb21pc2UuY2FuY2VsKCk7XG5cdFx0fVxuXG5cdFx0cmVqZWN0KHRpbWVvdXRFcnJvcik7XG5cdH0sIG1pbGxpc2Vjb25kcyk7XG5cblx0Ly8gVE9ETzogVXNlIG5hdGl2ZSBgZmluYWxseWAga2V5d29yZCB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDEwXG5cdHBGaW5hbGx5KFxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0cHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCksXG5cdFx0KCkgPT4ge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHR9XG5cdCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwVGltZW91dDtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFRpbWVvdXQ7XG5cbm1vZHVsZS5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFBvcnQgb2YgbG93ZXJfYm91bmQgZnJvbSBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvYWxnb3JpdGhtL2xvd2VyX2JvdW5kXG4vLyBVc2VkIHRvIGNvbXB1dGUgaW5zZXJ0aW9uIGluZGV4IHRvIGtlZXAgcXVldWUgc29ydGVkIGFmdGVyIGluc2VydGlvblxuZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICBsZXQgZmlyc3QgPSAwO1xuICAgIGxldCBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAoY291bnQgLyAyKSB8IDA7XG4gICAgICAgIGxldCBpdCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaXRdLCB2YWx1ZSkgPD0gMCkge1xuICAgICAgICAgICAgZmlyc3QgPSArK2l0O1xuICAgICAgICAgICAgY291bnQgLT0gc3RlcCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbG93ZXJCb3VuZDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxvd2VyX2JvdW5kXzEgPSByZXF1aXJlKFwiLi9sb3dlci1ib3VuZFwiKTtcbmNsYXNzIFByaW9yaXR5UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBlbnF1ZXVlKHJ1biwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHByaW9yaXR5OiAwIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHksXG4gICAgICAgICAgICBydW5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAmJiB0aGlzLl9xdWV1ZVt0aGlzLnNpemUgLSAxXS5wcmlvcml0eSA+PSBvcHRpb25zLnByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG93ZXJfYm91bmRfMS5kZWZhdWx0KHRoaXMuX3F1ZXVlLCBlbGVtZW50LCAoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBkZXF1ZXVlKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbS5ydW47XG4gICAgfVxuICAgIGZpbHRlcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5maWx0ZXIoKGVsZW1lbnQpID0+IGVsZW1lbnQucHJpb3JpdHkgPT09IG9wdGlvbnMucHJpb3JpdHkpLm1hcCgoZWxlbWVudCkgPT4gZWxlbWVudC5ydW4pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQcmlvcml0eVF1ZXVlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jb25zdCBwX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCJwLXRpbWVvdXRcIik7XG5jb25zdCBwcmlvcml0eV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcHJpb3JpdHktcXVldWVcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBlbXB0eSA9ICgpID0+IHsgfTtcbmNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBwX3RpbWVvdXRfMS5UaW1lb3V0RXJyb3IoKTtcbi8qKlxuUHJvbWlzZSBxdWV1ZSB3aXRoIGNvbmN1cnJlbmN5IGNvbnRyb2wuXG4qL1xuY2xhc3MgUFF1ZXVlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRW5kID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gZW1wdHk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gZW1wdHk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50OiBmYWxzZSwgaW50ZXJ2YWxDYXA6IEluZmluaXR5LCBpbnRlcnZhbDogMCwgY29uY3VycmVuY3k6IEluZmluaXR5LCBhdXRvU3RhcnQ6IHRydWUsIHF1ZXVlQ2xhc3M6IHByaW9yaXR5X3F1ZXVlXzEuZGVmYXVsdCB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXAgPT09ICdudW1iZXInICYmIG9wdGlvbnMuaW50ZXJ2YWxDYXAgPj0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGludGVydmFsQ2FwXFxgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAsIGdvdCBcXGAkeyhfYiA9IChfYSA9IG9wdGlvbnMuaW50ZXJ2YWxDYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJ31cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXB9KWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludGVydmFsID09PSB1bmRlZmluZWQgfHwgIShOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5pbnRlcnZhbCkgJiYgb3B0aW9ucy5pbnRlcnZhbCA+PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW50ZXJ2YWxcXGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyID49IDAsIGdvdCBcXGAkeyhfZCA9IChfYyA9IG9wdGlvbnMuaW50ZXJ2YWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJ31cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWx9KWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQgPSBvcHRpb25zLmNhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQ7XG4gICAgICAgIHRoaXMuX2lzSW50ZXJ2YWxJZ25vcmVkID0gb3B0aW9ucy5pbnRlcnZhbENhcCA9PT0gSW5maW5pdHkgfHwgb3B0aW9ucy5pbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDYXAgPSBvcHRpb25zLmludGVydmFsQ2FwO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IG9wdGlvbnMucXVldWVDbGFzcygpO1xuICAgICAgICB0aGlzLl9xdWV1ZUNsYXNzID0gb3B0aW9ucy5xdWV1ZUNsYXNzO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy5fdGhyb3dPblRpbWVvdXQgPSBvcHRpb25zLnRocm93T25UaW1lb3V0ID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IG9wdGlvbnMuYXV0b1N0YXJ0ID09PSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IF9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbENvdW50IDwgdGhpcy5faW50ZXJ2YWxDYXA7XG4gICAgfVxuICAgIGdldCBfZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQgPCB0aGlzLl9jb25jdXJyZW5jeTtcbiAgICB9XG4gICAgX25leHQoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudC0tO1xuICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICB0aGlzLmVtaXQoJ25leHQnKTtcbiAgICB9XG4gICAgX3Jlc29sdmVQcm9taXNlcygpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5KCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9IGVtcHR5O1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUlkbGUgPSBlbXB0eTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnaWRsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vblJlc3VtZUludGVydmFsKCkge1xuICAgICAgICB0aGlzLl9vbkludGVydmFsKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX2lzSW50ZXJ2YWxQYXVzZWQoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5faW50ZXJ2YWxFbmQgLSBub3c7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0IGFzIHRoZSBpbnRlcnZhbCB3YXMgZG9uZVxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVzdW1lIGl0IGhlcmUgYmVjYXVzZSBpdCB3aWxsIGJlIHJlc3VtZWQgb24gbGluZSAxNjBcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcnZhbENvdW50ID0gKHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQpID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgaXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVzdW1lSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF90cnlUb1N0YXJ0QW5vdGhlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBjbGVhciB0aGUgaW50ZXJ2YWwgKFwicGF1c2VcIilcbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuIHJlZG8gaXQgbGF0ZXIgKFwicmVzdW1lXCIpXG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb21pc2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuSW5pdGlhbGl6ZUludGVydmFsID0gIXRoaXMuX2lzSW50ZXJ2YWxQYXVzZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIgJiYgdGhpcy5fZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLl9xdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIGpvYigpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5Jbml0aWFsaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25JbnRlcnZhbCgpO1xuICAgICAgICB9LCB0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRW5kID0gRGF0ZS5ub3coKSArIHRoaXMuX2ludGVydmFsO1xuICAgIH1cbiAgICBfb25JbnRlcnZhbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsQ291bnQgPT09IDAgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmIHRoaXMuX2ludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQgPSB0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50ID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4ZWN1dGVzIGFsbCBxdWV1ZWQgZnVuY3Rpb25zIHVudGlsIGl0IHJlYWNoZXMgdGhlIGxpbWl0LlxuICAgICovXG4gICAgX3Byb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIHdoaWxlICh0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpKSB7IH1cbiAgICB9XG4gICAgZ2V0IGNvbmN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uY3VycmVuY3k7XG4gICAgfVxuICAgIHNldCBjb25jdXJyZW5jeShuZXdDb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoISh0eXBlb2YgbmV3Q29uY3VycmVuY3kgPT09ICdudW1iZXInICYmIG5ld0NvbmN1cnJlbmN5ID49IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjb25jdXJyZW5jeVxcYCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwLCBnb3QgXFxgJHtuZXdDb25jdXJyZW5jeX1cXGAgKCR7dHlwZW9mIG5ld0NvbmN1cnJlbmN5fSlgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25jdXJyZW5jeSA9IG5ld0NvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkcyBhIHN5bmMgb3IgYXN5bmMgdGFzayB0byB0aGUgcXVldWUuIEFsd2F5cyByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAqL1xuICAgIGFzeW5jIGFkZChmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICh0aGlzLl90aW1lb3V0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpID8gZm4oKSA6IHBfdGltZW91dF8xLmRlZmF1bHQoUHJvbWlzZS5yZXNvbHZlKGZuKCkpLCAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQgPyB0aGlzLl90aW1lb3V0IDogb3B0aW9ucy50aW1lb3V0KSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGhyb3dPblRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IHRoaXMuX3Rocm93T25UaW1lb3V0IDogb3B0aW9ucy50aHJvd09uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXdhaXQgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5lbnF1ZXVlKHJ1biwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdhZGQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNhbWUgYXMgYC5hZGQoKWAsIGJ1dCBhY2NlcHRzIGFuIGFycmF5IG9mIHN5bmMgb3IgYXN5bmMgZnVuY3Rpb25zLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgZnVuY3Rpb25zIGFyZSByZXNvbHZlZC5cbiAgICAqL1xuICAgIGFzeW5jIGFkZEFsbChmdW5jdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZ1bmN0aW9ucy5tYXAoYXN5bmMgKGZ1bmN0aW9uXykgPT4gdGhpcy5hZGQoZnVuY3Rpb25fLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCAob3IgcmVzdW1lKSBleGVjdXRpbmcgZW5xdWV1ZWQgdGFza3Mgd2l0aGluIGNvbmN1cnJlbmN5IGxpbWl0LiBObyBuZWVkIHRvIGNhbGwgdGhpcyBpZiBxdWV1ZSBpcyBub3QgcGF1c2VkICh2aWEgYG9wdGlvbnMuYXV0b1N0YXJ0ID0gZmFsc2VgIG9yIGJ5IGAucGF1c2UoKWAgbWV0aG9kLilcbiAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBxdWV1ZSBleGVjdXRpb24gb24gaG9sZC5cbiAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFyIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyB0aGlzLl9xdWV1ZUNsYXNzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuIFVzZWZ1bCBpZiB5b3UgZm9yIGV4YW1wbGUgYWRkIGFkZGl0aW9uYWwgaXRlbXMgYXQgYSBsYXRlciB0aW1lLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgc2V0dGxlcyB3aGVuIHRoZSBxdWV1ZSBiZWNvbWVzIGVtcHR5LlxuICAgICovXG4gICAgYXN5bmMgb25FbXB0eSgpIHtcbiAgICAgICAgLy8gSW5zdGFudGx5IHJlc29sdmUgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUVtcHR5O1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGlmZmVyZW5jZSB3aXRoIGAub25FbXB0eWAgaXMgdGhhdCBgLm9uSWRsZWAgZ3VhcmFudGVlcyB0aGF0IGFsbCB3b3JrIGZyb20gdGhlIHF1ZXVlIGhhcyBmaW5pc2hlZC4gYC5vbkVtcHR5YCBtZXJlbHkgc2lnbmFscyB0aGF0IHRoZSBxdWV1ZSBpcyBlbXB0eSwgYnV0IGl0IGNvdWxkIG1lYW4gdGhhdCBzb21lIHByb21pc2VzIGhhdmVuJ3QgY29tcGxldGVkIHlldC5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHNldHRsZXMgd2hlbiB0aGUgcXVldWUgYmVjb21lcyBlbXB0eSwgYW5kIGFsbCBwcm9taXNlcyBoYXZlIGNvbXBsZXRlZDsgYHF1ZXVlLnNpemUgPT09IDAgJiYgcXVldWUucGVuZGluZyA9PT0gMGAuXG4gICAgKi9cbiAgICBhc3luYyBvbklkbGUoKSB7XG4gICAgICAgIC8vIEluc3RhbnRseSByZXNvbHZlIGlmIG5vbmUgcGVuZGluZyBhbmQgaWYgbm90aGluZyBlbHNlIGlzIHF1ZXVlZFxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmIHRoaXMuX3F1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Jlc29sdmUgPSB0aGlzLl9yZXNvbHZlSWRsZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBTaXplIG9mIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2l6ZSBvZiB0aGUgcXVldWUsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBvcHRpb25zLlxuXG4gICAgRm9yIGV4YW1wbGUsIHRoaXMgY2FuIGJlIHVzZWQgdG8gZmluZCB0aGUgbnVtYmVyIG9mIGl0ZW1zIHJlbWFpbmluZyBpbiB0aGUgcXVldWUgd2l0aCBhIHNwZWNpZmljIHByaW9yaXR5IGxldmVsLlxuICAgICovXG4gICAgc2l6ZUJ5KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm4tcmVmZXJlbmNlLWluLWl0ZXJhdG9yXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5maWx0ZXIob3B0aW9ucykubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBOdW1iZXIgb2YgcGVuZGluZyBwcm9taXNlcy5cbiAgICAqL1xuICAgIGdldCBwZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICovXG4gICAgZ2V0IGlzUGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gICAgfVxuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0aW1lb3V0IGZvciBmdXR1cmUgb3BlcmF0aW9ucy5cbiAgICAqL1xuICAgIHNldCB0aW1lb3V0KG1pbGxpc2Vjb25kcykge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbWlsbGlzZWNvbmRzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBRdWV1ZTtcbiIsICJpbXBvcnQge1xuICBBcHAsXG4gIEVkaXRvcixcbiAgTWFya2Rvd25WaWV3LFxuICBNb2RhbCxcbiAgTm90aWNlLFxuICBQbHVnaW4sXG4gIFBsdWdpblNldHRpbmdUYWIsXG4gIFNldHRpbmcsXG4gIE1lbnUsXG4gIE1lbnVJdGVtLFxuICBNYXJrZG93bkZpbGVJbmZvLFxuICBURmlsZSxcbiAgVEFic3RyYWN0RmlsZSxcbiAgcmVxdWVzdCxcbiAgRWRpdG9yUG9zaXRpb24sXG4gIEZpbGVTeXN0ZW1BZGFwdGVyLFxufSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW1wb3J0IHsgTWVtb3J5VmVjdG9yU3RvcmUgfSBmcm9tIFwibGFuZ2NoYWluL3ZlY3RvcnN0b3Jlcy9tZW1vcnlcIjtcbmltcG9ydCB7IE9wZW5BSUVtYmVkZGluZ3MgfSBmcm9tIFwibGFuZ2NoYWluL2VtYmVkZGluZ3Mvb3BlbmFpXCI7XG5cbmltcG9ydCB7XG4gIGdldF9zdGFydHVwX2J5X25hbWUsXG4gIGFkZF9ub3Rlc190b19jb21wYW55LFxuICBnZXRfcGVyc29uX2J5X25hbWUsXG4gIGdldF9wZXJzb25fZGV0YWlscyxcbiAgaXNfcGVyc29uX2luX3ZlbnR1cmVfbmV0d29yayxcbiAgZ2V0X2ZpZWxkX3ZhbHVlcyxcbiAgYWRkX2VudHJ5X3RvX2xpc3QsXG4gIGFkZF9maWVsZF92YWx1ZSxcbiAgYWRkX25vdGVzX3RvX3BlcnNvbixcbiAgc3RhcnR1cF9yZWFkeV9mb3JfYWZmaW5pdHksXG4gIGV4dHJhY3RfdGl0bGVfYW5kX25vdGUsXG4gIGNsZWFuX3RleHQsXG4gIGlzX3N1bW1hcml6YWJsZSxcbiAgdmNfcmVhZHlfZm9yX2FmZmluaXR5LFxuICBjb3VudFdvcmRzLFxuICBleHRyYWN0X3N0YXJ0dXBfZGV0YWlscyxcbiAgZ2V0X2lwb19kZXRhaWxzLFxuICBnZXRfYWNxdWlzaXRpb25fZGV0YWlscyxcbiAgZm9ybWF0T2JqZWN0c1RvTWFya2Rvd25UYWJsZSxcbiAgZ2V0X3JlbGV2YW50X2ZlZWRzLFxuICBnZW5lcmF0ZV9pbnZlc3Rvcl9qc29uLFxuICBmaW5kX2VsaWdpYmxlX2ludmVzdG9ycyxcbiAgZm9ybWF0X21hdGNoaW5nX3Byb21wdCxcbiAgZXh0cmFjdEludmVzdG9yc1RleHQsXG4gIGV4dHJhY3RSZXNvbmluZ1RleHQsXG4gIGV4dHJhY3RUZXh0VG9FbmRPZkxpbmUsXG4gIGNyZWF0ZUludmVzdG9yT2JqZWN0LFxuICB0b2dldGhlcmFpX2pzLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuXG5pbXBvcnQge1xuICBQREZNb2RhbCxcbiAgTXVsdGlwbGVUZXh0SW5wdXRNb2RhbCxcbiAgVGV4dElucHV0TW9kYWwsXG4gIFRyYWN4bk1vZGFsLFxuICBGaW5kSW52ZXN0b3JNb2RhbCxcbiAgRmlyZUZsaWVzVGVtcCxcbiAgU3Bva2VNb2RhbCxcbiAgV29ya2Zsb3dNb2RhbCxcbn0gZnJvbSBcIi4vbW9kYWxcIjtcblxuaW1wb3J0IE9wZW5BSSwgeyB0b0ZpbGUgfSBmcm9tIFwib3BlbmFpXCI7XG5cbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuXG5pbXBvcnQgeyBmb3JtYXRfdXJsX3RleHQgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcblxuaW1wb3J0IHsgc3BlY2lmaWNfd2ViX3Jlc2VhcmNoLCB5b3VfcmVzZWFyY2ggfSBmcm9tIFwiLi9zZWFyY2hcIjtcblxuaW1wb3J0IHtcbiAgREVGRU5TSUJJTElUWV9BTkFMWVNJU19TWVNURU1fUFJPTVBULFxuICBHVUlEQU5DRV9XT1JLRkxPV19TWVNURU1fUFJPTVBULFxufSBmcm9tIFwiLi9wcm9tcHRzXCI7XG5cbmltcG9ydCB7XG4gIGdldF9tZWV0aW5nX2lkLFxuICBnZXRfbWVldGluZ190cmFuc2NyaXB0X2J5X2lkLFxuICB0cmFuc2NyaXB0X2pzb25fdG9fYXJyYXlfc3RyaW5nLFxufSBmcm9tIFwiLi9maXJlZmxpZXNcIjtcbmltcG9ydCB7IHN0YXJ0IH0gZnJvbSBcInJlcGxcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IHsgaXNOYXRpdmVFcnJvciB9IGZyb20gXCJ1dGlsL3R5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tIFwiZG9tYWluXCI7XG5cbmltcG9ydCB7IEdyb3EgfSBmcm9tIFwiZ3JvcS1zZGtcIjtcblxubGV0IGFmZmluaXR5QVBJS2V5ID0gXCJcIjtcbmxldCBvcGVuYWlBUElLZXkgPSBcIlwiO1xubGV0IHRvZ2V0aGVyYWlBUElLZXkgPSBcIlwiO1xubGV0IGdyb3FBUElLZXkgPSBcIlwiO1xubGV0IG93bmVyX3ZhbHVlID0gXCIxMFwiO1xubGV0IGNvbm5lY3Rpb25fb3duZXJfZmllbGQgPSBcIjEwXCI7XG5sZXQgdmVudHVyZV9uZXR3b3JrX2xpc3QgPSBcIjUwMFwiO1xubGV0IGludmVzdG9yX25hbWVzOiBzdHJpbmdbXSA9IFtdO1xubGV0IGZpcmVmbGllc19hcGlfa2V5ID0gXCJcIjtcbmxldCB0cmFjeG5fYXBpX2tleSA9IFwiXCI7XG5sZXQgaW50ZXJ2YWxJZDogYW55O1xubGV0IG9wZW5haTogT3BlbkFJO1xubGV0IGdyb3E6IEdyb3E7XG5cbmV4cG9ydCBjb25zdCBncHRfM19sYXRlc3QgPSBcImdwdC0zLjUtdHVyYm9cIjtcbmV4cG9ydCBjb25zdCBncHRfNF9sYXRlc3QgPSBcImdwdC00LXR1cmJvXCI7XG5cbmludGVyZmFjZSBCdXRsZXJTZXR0aW5ncyB7XG4gIGFmZmluaXR5S2V5OiBzdHJpbmc7XG4gIG9wZW5BSUtleTogc3RyaW5nO1xuICBncm9xQUlLZXk6IHN0cmluZztcbiAgdG9nZXRoZXJBSUtleTogc3RyaW5nO1xuICBvd25lcl9wZXJzb25fdmFsdWU6IHN0cmluZztcbiAgY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZDogc3RyaW5nO1xuICB2ZW50dXJlX25ldHdvcmtfbGlzdF9pZDogc3RyaW5nO1xuICB0ZWFtX25hbWVzOiBzdHJpbmc7XG4gIGZpcmVmbGllc19hcGk6IHN0cmluZztcbiAgdHJhY3huX2FwaTogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBCdXRsZXJTZXR0aW5ncyA9IHtcbiAgYWZmaW5pdHlLZXk6IFwiZGVmYXVsdFwiLFxuICBvcGVuQUlLZXk6IFwiZGVmYXVsdFwiLFxuICB0b2dldGhlckFJS2V5OiBcImRlZmF1bHRcIixcbiAgZ3JvcUFJS2V5OiBcImRlZmF1bHRcIixcbiAgb3duZXJfcGVyc29uX3ZhbHVlOiBcIjEwXCIsXG4gIGNvbm5lY3Rpb25fb3duZXJfZmllbGRfaWQ6IFwiMTAwXCIsXG4gIHZlbnR1cmVfbmV0d29ya19saXN0X2lkOiBcIjUwMFwiLFxuICB0ZWFtX25hbWVzOiBcIkJlbiBIb3Jyb3dpdHosIFZpbm9kIEtob3NsYVwiLFxuICBmaXJlZmxpZXNfYXBpOiBcImRlZmF1bHRcIixcbiAgdHJhY3huX2FwaTogXCJkZWZhdWx0XCIsXG59O1xuXG5hc3luYyBmdW5jdGlvbiBvcGVuYWlfanMoXG4gIG1vZGVsX25hbWU6IHN0cmluZyxcbiAgdXNlcl9wcm9tcHQ6IHN0cmluZyxcbiAgc3lzdGVtX3Byb21wdDogc3RyaW5nLFxuICBtYXhfdG9rZW5zOiBudW1iZXIgPSAyNTYsXG4gIHRlbXBlcmF0dXJlOiBudW1iZXIgPSAwLjMsXG4gIGlzU3RyZWFtaW5nOiBib29sZWFuID0gZmFsc2Vcbikge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgbW9kZWw6IG1vZGVsX25hbWUsIC8vZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAgdGVtcGVyYXR1cmU6IHRlbXBlcmF0dXJlLFxuICAgIG1heF90b2tlbnM6IG1heF90b2tlbnMsXG4gICAgc3RyZWFtOiBpc1N0cmVhbWluZyxcbiAgICBtZXNzYWdlczogW1xuICAgICAgeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBzeXN0ZW1fcHJvbXB0IH0sXG4gICAgICB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiB1c2VyX3Byb21wdCB9LFxuICAgIF0sXG4gIH0pO1xuXG4gIGlmICghaXNTdHJlYW1pbmcpIHtcbiAgICBsZXQgc3VtbWFyeSA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgIGlmIChzdW1tYXJ5ID09IG51bGwpIHtcbiAgICAgIHN1bW1hcnkgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gb3BlbmFpX2pzX211bHRpdHVybihcbiAgcXVlcmllczogc3RyaW5nW10sXG4gIHN5c3RlbV9wcm9tcHQ6IHN0cmluZyxcbiAgbW9kZWxfbmFtZTogc3RyaW5nLFxuICBtYXhfdG9rZW5zOiBudW1iZXIgPSAyNTYsXG4gIHRlbXBlcmF0dXJlOiBudW1iZXIgPSAwLjNcbikge1xuICBjb25zdCBzeXN0ZW1fbWVzc2FnZSA9IHN5c3RlbV9wcm9tcHQ7XG5cbiAgbGV0IG1lc3NhZ2VzID0gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogc3lzdGVtX21lc3NhZ2UgfV07XG5cbiAgbGV0IHJlcGxpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgZm9yIChsZXQgcXVlcnkgb2YgcXVlcmllcykge1xuICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogcXVlcnkgfSk7XG4gICAgdmFyIHJlc3BvbnNlO1xuICAgIGxldCBhc3Npc3RhbnRfcmVwbHkgPSBcIlwiO1xuXG4gICAgaWYgKG1vZGVsX25hbWUgPT0gXCJncm9xXCIpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZ3JvcS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyxcbiAgICAgICAgbW9kZWw6IFwibGxhbWEzLTcwYi04MTkyXCIsXG4gICAgICB9KTtcbiAgICAgIGFzc2lzdGFudF9yZXBseSA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobW9kZWxfbmFtZSA9PSBcIm9wZW5haVwiKSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgICAgICBtb2RlbDogZ3B0XzRfbGF0ZXN0LFxuICAgICAgICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgICBtYXhfdG9rZW5zOiBtYXhfdG9rZW5zLFxuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2lzdGFudF9yZXBseSA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0b2dldGhlcmFpX2pzKFxuICAgICAgICAgIHRvZ2V0aGVyYWlBUElLZXksXG4gICAgICAgICAgbW9kZWxfbmFtZSxcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgMTAyNCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICk7XG4gICAgICAgIGFzc2lzdGFudF9yZXBseSA9IHJlc3BvbnNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vbGV0IGFzc2lzdGFudF9yZXBseSA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgIGlmIChhc3Npc3RhbnRfcmVwbHkgPT0gbnVsbCkge1xuICAgICAgYXNzaXN0YW50X3JlcGx5ID0gXCJcIjtcbiAgICB9XG5cbiAgICBtZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJhc3Npc3RhbnRcIiwgY29udGVudDogYXNzaXN0YW50X3JlcGx5IH0pO1xuICAgIHJlcGxpZXMucHVzaChhc3Npc3RhbnRfcmVwbHkpO1xuICB9XG5cbiAgcmV0dXJuIHJlcGxpZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN1bW1hcml6ZV92Y190ZXh0KHRleHQ6IHN0cmluZykge1xuICAvKipcbiAgICogR2l2ZW4gdGhlIGZ1bGwgdGV4dCBpbiBhIFZDIG5vdGUsIHRoaXMgZnVuY3Rpb24gc3VtbWFyaXplcyB0aGUgaW1wb3J0YW50IHBhcnQgKGJlZm9yZSAjIFN0b3AgSW5kZXhpbmcpIGFuZCByZXR1cm5zIHRoZSBuZXcgZnVsbCB0ZXh0IHRoYXQgc2hvdWxkIGJlIHdyaXR0ZW4gdG8gdGhlIGZpbGVcbiAgICogVGhlIGZ1bGwgdGV4dCBpbmNsdWRlcyB0aGUgbWV0YSBkYXRhIGFuZCB0YWdzIGluZm9ybWF0aW9uIGJlZm9yZSB0aGUgdGl0bGUsIHRoZSB0aXRsZSwgdGhlIHN1bW1hcnksIGFuZCBhZGRzIHRoZSBjb3JlIGRhdGEgYWZ0ZXIgdGhlIGhlYWRpbmcgXCIjIFN0b3AgSW5kZXhpbmdcIlxuICAgKi9cblxuICAvLyBXZSBzaG91bGQgc3VtbWFyaXplIG9ubHkgaW5mb3JtYXRpb24gdGhhdCBpcyBiZWZvcmUgJyMgU3RvcCBJbmRleGluZydcbiAgbGV0IFt0aXRsZSwgc3Vic3RyaW5nc10gPSBleHRyYWN0X3RpdGxlX2FuZF9ub3RlKHRleHQpO1xuICAvL1dlIGNvbnNpZGVyIGJvdGggZGF0YSBiZWZvcmUgdGhlIHRpdGxlIChoYXNodGFncykgYXMgd2VsbCBhcyB0aGUgYm9keSBvZiB0aGUgbm90ZVxuICBsZXQgaGFzaHRhZ3M7XG4gIHRyeSB7XG4gICAgaGFzaHRhZ3MgPSBzdWJzdHJpbmdzWzBdLnNwbGl0KFwiVGFnczpcIilbMV07XG4gIH0gY2F0Y2gge1xuICAgIGhhc2h0YWdzID0gc3Vic3RyaW5nc1swXTtcbiAgICBuZXcgTm90aWNlKFxuICAgICAgYCR7dGl0bGV9OiBEb2VzIG5vdCBoYXZlIGFueSBndWlkaW5nIGhhc2h0YWdzLCB0aGlzIGNvdWxkIGhlbHAgdGhlIHN1bW1hcml6ZXIgdW5kZXJzdGFuZCB0aGUgVkMgYmV0dGVyYCxcbiAgICAgIDM2MDBcbiAgICApO1xuICB9XG4gIGxldCB0ZXh0X3RvX3N1bW1hcml6ZSA9IGhhc2h0YWdzICsgXCJcXG5cIiArIHN1YnN0cmluZ3NbMV07XG5cbiAgY29uc29sZS5sb2coYFN1bW1hcml6aW5nOiAke3RpdGxlfWApO1xuXG4gIGNvbnN0IHN5c3RlbV9wcm9tcHQgPVxuICAgIFwiWW91IGFyZSBhIHN1bW1hcml6ZXIgZm9yIG15IG5vdGVzIGFib3V0IFZDIEZ1bmRzLiBZb3VyIGpvYiBpcyB0byByZWFkIHRocm91Z2ggbXkgbm90ZXMgYW5kIGNyZWF0ZSBhIHN1bW1hcnkgaW4gdGhlIGZvbGxvd2luZyBzY2hlbWE6XFxuXFxcbi0gRnVuZCBTaXplOjo8SG93IGJpZyBpcyB0aGUgZnVuZD8+XFxuXFxcbi0gVGlja2V0IFNpemU6OjxIb3cgbXVjaCBkb2VzIHRoZSBmdW5kIGludmVzdCBwZXIgc3RhcnR1cD8+XFxuXFxcbi0gR2VvZ3JhcGh5Ojo8V2hlcmUgY2FuIHRoZSBmdW5kIGludmVzdD8+XFxuXFxcbi0gU3RhZ2U6OiA8UHJlLXNlZWQsIFNlZWQsIFNlcmllcyBBLCBldGM+XFxuXFxcbi0gSW5kdXN0cnk6OjxJbiB3aGljaCBpbmR1c3RyaWVzIGRvZXMgdGhlIGZ1bmQgaW52ZXN0Pz5cXG5cXFxuLSBTcGVjaWFsOjo8QW55IHNwZWNpYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZ1bmQgb3IgdGhlIGludmVzdG9yIHRoYXQgSSBzaG91bGQgcmVtZW1iZXI+XCI7XG5cbiAgY29uc3Qgc3VtbWFyeSA9IGF3YWl0IG9wZW5haV9qcyhcbiAgICBncHRfNF9sYXRlc3QsXG4gICAgXCJOb3RlczpcXG5cIiArIHRleHRfdG9fc3VtbWFyaXplLFxuICAgIHN5c3RlbV9wcm9tcHRcbiAgKTtcblxuICBsZXQgbmV3X3N1bW1hcnk6IHN0cmluZyA9IFN0cmluZyhzdW1tYXJ5KTtcblxuICB0aXRsZSA9IHRpdGxlLnRvU3RyaW5nKCk7XG4gIGxldCBsZWFkaW5nX3RleHQgPSBcIlwiO1xuICBsZXQgcmVwbGFjZW1lbnQgPSBcIlwiO1xuICBsZXQgdGFpbGluZ190ZXh0ID0gXCJcIjsgLy9oYXNodGFnc1xuXG4gIGlmIChzdWJzdHJpbmdzKSB7XG4gICAgbGVhZGluZ190ZXh0ID0gc3Vic3RyaW5nc1swXSArIFwiXFxuXCIgKyB0aXRsZSArIFwiXFxuXCI7XG4gICAgZm9yIChsZXQgc3Vic3RyaW5nIG9mIHN1YnN0cmluZ3Muc2xpY2UoMSkpIHtcbiAgICAgIHRhaWxpbmdfdGV4dCA9IHRhaWxpbmdfdGV4dCArIFwiXFxuXCIgKyBzdWJzdHJpbmc7XG4gICAgfVxuICAgIHJlcGxhY2VtZW50ID1cbiAgICAgIGxlYWRpbmdfdGV4dCArXG4gICAgICBcIiNncHRfc3VtbWFyaXplZCwgI3JldmlldyBcXG5cIiArXG4gICAgICBuZXdfc3VtbWFyeSArXG4gICAgICBcIlxcblwiICtcbiAgICAgIFwiIyBTdG9wIEluZGV4aW5nIFxcbiMjIE5vdGVzXFxuXCIgK1xuICAgICAgdGFpbGluZ190ZXh0O1xuICAgIHJldHVybiBbcmVwbGFjZW1lbnQsIG5ld19zdW1tYXJ5LCB0aXRsZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt0ZXh0LCB0ZXh0LCBcIlwiXTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzdW1tYXJpemVfcGFyYWdyYXBoKHBhcmFncmFwaDogc3RyaW5nLCBtb2RlbF9uYW1lOiBzdHJpbmcpIHtcbiAgbGV0IHJlcGx5ID0gXCJcIjtcbiAgaWYgKG1vZGVsX25hbWUgPT0gXCJvcGVuYWlcIikge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogZ3B0XzRfbGF0ZXN0LCAvL1wiZ3B0LTQtMTEwNi1wcmV2aWV3XCIsIC8vZ3B0LTQgZ3B0LTMuNS10dXJib1xuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDpcbiAgICAgICAgICAgICdZb3UgYXJlIGEgaGVscGZ1bCBub3RlLXRha2luZyBhc3Npc3RhbnQgZm9yIGEgdmVudHVyZSBjYXBpdGFsIGludmVzdG9yLiBZb3Ugd2lsbCBiZSBnaXZlbiBhIHBhcnQgb2YgYSB0cmFuc2NyaXB0IGZvciB0aGUgY2FsbCBiZXR3ZWVuIHRoZSBpbnZlc3RvciBhbmQgdGhlIHN0YXJ0dXAgZm91bmRlcnMuIFlvdXIgdGFzayBpcyB0byBleHRyYWN0IGluZm9ybWF0aW9uIGNvdmVyaW5nIHRoZSBmb2xsb3dpbmcgYXNwZWN0czpcXG4tICoqVGVhbSoqOjxXaG8gaXMgdGhlIHRlYW0gYmVoaW5kIHRoZSBzdGFydHVwLiBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuLSAqKlByb2JsZW0qKjo8V2hhdCBpcyB0aGUgcHJvYmxlbSB0aGUgc3RhcnR1cCBpcyBzb2x2aW5nIGFuZCBmb3Igd2hvbS4gQW5zd2VyIGluIGJ1bGxldCBwb2ludHMhPlxcbi0gKipQcm9kdWN0Kio6PEhvdyBkb2VzIHRoZWlyIHByb2R1Y3Qgc29sdmUgdGhpcyBwcm9ibGVtLiBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuLSAqKlRyYWN0aW9uKio6PEhvdyBkb2VzIHRoZWlyIGN1c3RvbWVyIHRyYWN0aW9uIGxvb2sgbGlrZS4gQW5zd2VyIGluIGJ1bGxldCBwb2ludHMhPlxcbi0gKipDb21wZXRpdGlvbioqOjxIb3cgZG9lcyB0aGUgY29tcGV0aXRpdmUgbGFuZHNjYXBlIGxvb2sgbGlrZS4gQW5zd2VyIGluIGJ1bGxldCBwb2ludHMhPlxcbi0gKipSb3VuZCBJbmZvKio6PEhvdyBtdWNoIG1vbmV5IGFyZSB0aGV5IHJhaXNpbmcgZnJvbSBpbnZlc3RvcnMgY3VycmVudGx5PyBIb3cgbXVjaCBoYXZlIHRoZXkgcmFpc2VkIGJlZm9yZT8gQW5zd2VyIGluIGJ1bGxldCBwb2ludHMhPlxcbi0gKipPdGhlcioqOiA8T3RoZXIgaW1wb3J0YW50IHBvaW50cyBhYm91dCB0aGUgZm91bmRlcnMgT1IgdGhlIHN0YXJ0dXAgdGhhdCBkbyBub3QgZml0IGluIHRoZSBhYm92ZSBzZWN0aW9ucy4gQW5zd2VyIGluIGJ1bGxldCBwb2ludHMhPlxcblxcbkZvciBldmVyeSBzZWN0aW9uLCBhbHdheXMgZ2l2ZSB5b3VyIGFuc3dlcnMgaW4gYnVsbGV0IHBvaW50cyEgT3RoZXJ3aXNlLCBzYXkgXCJObyBSZWxldmFudCBJbmZvcm1hdGlvblwiJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGAke3BhcmFncmFwaH1gLCAvL1lvdSBhcmUgYSBoZWxwZnVsIG5vdGUtdGFraW5nIGFzc2lzdGFudCBmb3IgYSB2ZW50dXJlIGNhcGl0YWwgaW52ZXN0b3IuIFlvdSB3aWxsIGJlIGdpdmVuIGEgcGFydCBvZiBhIHRyYW5zY3JpcHQgZm9yIHRoZSBjYWxsIGJldHdlZW4gdGhlIGludmVzdG9yIGFuZCB0aGUgc3RhcnR1cCBmb3VuZGVyLiBZb3Ugc2hvdWxkIGZvY3VzIG9ubHkgb24gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXJ0dXAuIElnbm9yZSBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGludmVzdG9yIHRoZW1zZWx2ZXMgb3IgdGhlIHZlbnR1cmUgY2FwaXRhbCBmaXJtIHRoZXkgcmVwcmVzZW50LiBZb3VyIHRhc2sgaXMgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0cmFuc2NyaXB0IGNvdmVyaW5nIHRoZSBmb2xsb3dpbmcgc2VjdGlvbnM6XFxuLSBUZWFtOiA8V2hvIGlzIHRoZSB0ZWFtIGJlaGluZCB0aGUgc3RhcnR1cD5cXG4tIFByb2JsZW06IDxXaGF0IGlzIHRoZSBwcm9ibGVtIHRoZSBzdGFydHVwIGlzIHNvbHZpbmc+XFxuLSBQcm9kdWN0OiA8SG93IGRvZXMgdGhlaXIgcHJvZHVjdCBzb2x2ZSB0aGlzIHByb2JsZW0+XFxuLSBUcmFjdGlvbjogPEhvdyBkb2VzIHRoZWlyIGN1c3RvbWVyIHRyYWN0aW9uIGxvb2sgbGlrZT5cXG4tIENvbXBldGl0aW9uOiA8SG93IGRvZXMgdGhlIGNvbXBldGl0aXZlIGxhbmRzY2FwZSBsb29rIGxpa2U+XFxuLSBSb3VuZCBJbmZvOiA8SG93IG11Y2ggbW9uZXkgYXJlIHRoZXkgcmFpc2luZyBmcm9tIGludmVzdG9ycyBjdXJyZW50bHk/IEhvdyBtdWNoIGhhdmUgdGhleSByYWlzZWQgYmVmb3JlPz5cXG4tIE90aGVyOiA8T3RoZXIgaW1wb3J0YW50IHBvaW50cyBhYm91dCB0aGUgZm91bmRlcnMgT1IgdGhlIHN0YXJ0dXAgdGhhdCBkbyBub3QgZml0IGluIHRoZSBhYm92ZSBzZWN0aW9ucz5cXG5cXG5Gb3IgZXZlcnkgc2VjdGlvbiBhbHdheXMgZ2l2ZSB5b3VyIGFuc3dlcnMgaW4gYnVsbGV0IHBvaW50cyEgT3RoZXJ3aXNlIHNheSBcXFwiTm8gUmVsZXZhbnQgSW5mb3JtYXRpb25cXFwiIGluZnJvbnQgb2YgdGhlIHNlY3Rpb24ncyBuYW1lLlxcblxcblRyYW5zY3JpcHQ6XFxuXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAsXG4gICAgICBtYXhfdG9rZW5zOiAxMDI0LFxuICAgICAgdG9wX3A6IDEsXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG4gICAgfSk7XG4gICAgcmVwbHkgPSByZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXBseSA9IGF3YWl0IHRvZ2V0aGVyYWlfanMoXG4gICAgICB0b2dldGhlcmFpQVBJS2V5LFxuICAgICAgbW9kZWxfbmFtZSwgLy9tZXRhLWxsYW1hL0xsYW1hLTMtOGItY2hhdC1oZlxuICAgICAgcGFyYWdyYXBoLFxuICAgICAgJ1lvdSBhcmUgYSBoZWxwZnVsIG5vdGUtdGFraW5nIGFzc2lzdGFudCBmb3IgYSB2ZW50dXJlIGNhcGl0YWwgaW52ZXN0b3IuIFlvdSB3aWxsIGJlIGdpdmVuIGEgcGFydCBvZiBhIHRyYW5zY3JpcHQgZm9yIHRoZSBjYWxsIGJldHdlZW4gdGhlIGludmVzdG9yIGFuZCB0aGUgc3RhcnR1cCBmb3VuZGVycy4gWW91ciB0YXNrIGlzIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gY292ZXJpbmcgdGhlIGZvbGxvd2luZyBhc3BlY3RzOlxcbi0gKipUZWFtKio6PFdobyBpcyB0aGUgdGVhbSBiZWhpbmQgdGhlIHN0YXJ0dXAuIEFuc3dlciBpbiBidWxsZXQgcG9pbnRzIT5cXG4tICoqUHJvYmxlbSoqOjxXaGF0IGlzIHRoZSBwcm9ibGVtIHRoZSBzdGFydHVwIGlzIHNvbHZpbmcgYW5kIGZvciB3aG9tLiBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuLSAqKlByb2R1Y3QqKjo8SG93IGRvZXMgdGhlaXIgcHJvZHVjdCBzb2x2ZSB0aGlzIHByb2JsZW0uIEFuc3dlciBpbiBidWxsZXQgcG9pbnRzIT5cXG4tICoqVHJhY3Rpb24qKjo8SG93IGRvZXMgdGhlaXIgY3VzdG9tZXIgdHJhY3Rpb24gbG9vayBsaWtlLiBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuLSAqKkNvbXBldGl0aW9uKio6PEhvdyBkb2VzIHRoZSBjb21wZXRpdGl2ZSBsYW5kc2NhcGUgbG9vayBsaWtlLiBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuLSAqKlJvdW5kIEluZm8qKjo8SG93IG11Y2ggbW9uZXkgYXJlIHRoZXkgcmFpc2luZyBmcm9tIGludmVzdG9ycyBjdXJyZW50bHk/IEhvdyBtdWNoIGhhdmUgdGhleSByYWlzZWQgYmVmb3JlPyBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuLSAqKk90aGVyKio6IDxPdGhlciBpbXBvcnRhbnQgcG9pbnRzIGFib3V0IHRoZSBmb3VuZGVycyBPUiB0aGUgc3RhcnR1cCB0aGF0IGRvIG5vdCBmaXQgaW4gdGhlIGFib3ZlIHNlY3Rpb25zLiBBbnN3ZXIgaW4gYnVsbGV0IHBvaW50cyE+XFxuXFxuRm9yIGV2ZXJ5IHNlY3Rpb24sIGFsd2F5cyBnaXZlIHlvdXIgYW5zd2VycyBpbiBidWxsZXQgcG9pbnRzISBPdGhlcndpc2UsIHNheSBcIk5vIFJlbGV2YW50IEluZm9ybWF0aW9uXCInLFxuICAgICAgMTAyNCxcbiAgICAgIDBcbiAgICApO1xuICB9XG5cbiAgY29uc29sZS5sb2cocmVwbHkpO1xuICBpZiAocmVwbHkgPT0gbnVsbCkge1xuICAgIHJlcGx5ID0gXCJcIjtcbiAgfVxuICByZXR1cm4gcmVwbHk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN1bW1hcml6ZV9hbGxfcGFyYWdyYXBoc190b2dldGhlcihcbiAgcGFyYWdyYXBoczogYW55W10sXG4gIG1vZGVsX25hbWU6IHN0cmluZ1xuKSB7XG4gIGxldCBpbnB1dF90ZXh0ID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFncmFwaHMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnB1dF90ZXh0ICs9IGBTdW1tYXJ5ICMke2kgKyAxfTpcXG5gO1xuICAgIGlucHV0X3RleHQgKz0gcGFyYWdyYXBoc1tpXSArIFwiXFxuXFxuXCI7XG4gIH1cblxuICBjb25zb2xlLmxvZyhcIkFsbCBTdW1tYXJpZXM6XCIpO1xuICBjb25zb2xlLmxvZyhpbnB1dF90ZXh0KTtcblxuICBsZXQgc3lzdGVtX3Byb21wdCA9XG4gICAgJ1lvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudC4gWW91ciB0YXNrIGlzIHRvIGV4cGFuZCB0aGUgZmlyc3Qgc3VtbWFyeSB5b3UgYXJlIGdpdmVuIGJ5IHRoZSBpbmZvcm1hdGlvbiBpbiBhbGwgdGhlIHN1YnNlcXVlbnQgc3VtbWFyaWVzLiBUaGUgZmluYWwgc3VtbWFyeSB5b3UgcHJvdmlkZSBzaG91bGQgY292ZXIgQUxMIGZvbGxvd2luZyBzZWN0aW9uczpcXG4tICoqVGVhbSoqOiA8V2hvIGlzIHRoZSB0ZWFtIGJlaGluZCB0aGUgc3RhcnR1cD5cXG4tICoqUHJvYmxlbSoqOiA8V2hhdCBpcyB0aGUgcHJvYmxlbSB0aGUgc3RhcnR1cCBpcyBzb2x2aW5nIGFuZCBmb3Igd2hvbT5cXG4tICoqUHJvZHVjdCoqOiA8SG93IGRvZXMgdGhlaXIgcHJvZHVjdCBzb2x2ZSB0aGlzIHByb2JsZW0+XFxuLSAqKlRyYWN0aW9uKio6IDxIb3cgZG9lcyB0aGVpciBjdXN0b21lciB0cmFjdGlvbiBsb29rIGxpa2U+XFxuLSAqKkNvbXBldGl0aW9uKio6IDxIb3cgZG9lcyB0aGUgY29tcGV0aXRpdmUgbGFuZHNjYXBlIGxvb2sgbGlrZT5cXG4tICoqUm91bmQgSW5mbyoqOiA8SG93IG11Y2ggbW9uZXkgYXJlIHRoZXkgcmFpc2luZyBmcm9tIGludmVzdG9ycyBjdXJyZW50bHk/IEhvdyBtdWNoIGhhdmUgdGhleSByYWlzZWQgYmVmb3JlPz5cXG4tICoqT3RoZXIqKjogPE90aGVyIGltcG9ydGFudCBwb2ludHMgYWJvdXQgdGhlIGZvdW5kZXJzIE9SIHRoZSBzdGFydHVwIHRoYXQgZG8gbm90IGZpdCBpbiB0aGUgYWJvdmUgc2VjdGlvbnM+XFxuXFxuRG8gbm90IGxlYXZlIGFueSBlbXB0eSBzZWN0aW9ucy4gRm9yIGV2ZXJ5IHNlY3Rpb24gYWx3YXlzIGdpdmUgeW91ciBhbnN3ZXJzIGluIGJ1bGxldCBwb2ludHMhIE90aGVyd2lzZSBzYXkgXCJObyBSZWxldmFudCBJbmZvcm1hdGlvblwiIGluZnJvbnQgb2YgdGhlIHNlY3Rpb25cXCdzIG5hbWUuJztcblxuICBsZXQgcmVwbHkgPSBcIlwiO1xuICBpZiAobW9kZWxfbmFtZSA9PSBcIm9wZW5haVwiKSB7XG4gICAgdmFyIHJlc3BvbnNlO1xuICAgIHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiBncHRfNF9sYXRlc3QsIC8vXCJncHQtNC0xMTA2LXByZXZpZXdcIiwgLy8gZ3B0LTMuNS10dXJib1xuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogc3lzdGVtX3Byb21wdCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGAke2lucHV0X3RleHR9YCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICB0ZW1wZXJhdHVyZTogMCxcbiAgICAgIG1heF90b2tlbnM6IDIwNDgsXG4gICAgICB0b3BfcDogMSxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbiAgICB9KTtcbiAgICByZXBseSA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJlcGx5ID0gYXdhaXQgdG9nZXRoZXJhaV9qcyhcbiAgICAgIHRvZ2V0aGVyYWlBUElLZXksXG4gICAgICBtb2RlbF9uYW1lLFxuICAgICAgaW5wdXRfdGV4dCxcbiAgICAgIHN5c3RlbV9wcm9tcHQsXG4gICAgICAxMDI0LFxuICAgICAgMFxuICAgICk7XG4gIH1cblxuICBpZiAocmVwbHkgPT0gbnVsbCkge1xuICAgIHJlcGx5ID0gXCJcIjtcbiAgfVxuICByZXR1cm4gcmVwbHk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RIZWFkZXJzRnJvbU5vdGVzKG5vdGVzOiBzdHJpbmcpIHtcbiAgY29uc3QgaGVhZGVyUmVnZXggPSAvXiMrXFxzKy4rJC9nbTtcbiAgY29uc3QgaGVhZGVyczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSBoZWFkZXJSZWdleC5leGVjKG5vdGVzKSkgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzLnB1c2gobWF0Y2hbMF0pO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbmZ1bmN0aW9uIGZpbmRMaW5lTnVtYmVyKFxuICBmaWxlVGV4dDogc3RyaW5nLFxuICBzZWFyY2hTdHJpbmc6IHN0cmluZyxcbiAgc3RhcnRMaW5lOiBudW1iZXJcbikge1xuICBjb25zdCBmaWxlQ29udGVudCA9IGZpbGVUZXh0OyAvL2ZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgY29uc3QgbGluZXMgPSBmaWxlQ29udGVudC5zcGxpdChcIlxcblwiKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLmluY2x1ZGVzKHNlYXJjaFN0cmluZykpIHtcbiAgICAgIHJldHVybiBbaSwgbGluZXNbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydEhlYWRlcih1cGRhdGVfdHlwZTogc3RyaW5nKSB7XG4gIGxldCBzdGFydEhlYWRlciA9IFwiXCI7XG5cbiAgaWYgKHVwZGF0ZV90eXBlLnRvTG93ZXJDYXNlKCkgPT0gXCJ0ZWFtXCIpIHtcbiAgICBzdGFydEhlYWRlciA9IFwiIyMjIyBUZWFtXCI7XG4gIH0gZWxzZSBpZiAodXBkYXRlX3R5cGUudG9Mb3dlckNhc2UoKSA9PSBcImlkZWFsIGN1c3RvbWVyIHByb2ZpbGVcIikge1xuICAgIHN0YXJ0SGVhZGVyID0gXCIjIyMjIFByb2JsZW1cIjtcbiAgfSBlbHNlIGlmICh1cGRhdGVfdHlwZS50b0xvd2VyQ2FzZSgpID09IFwicHJvZHVjdFwiKSB7XG4gICAgc3RhcnRIZWFkZXIgPSBcIiMjIyMgUHJvZHVjdFwiO1xuICB9IGVsc2UgaWYgKHVwZGF0ZV90eXBlLnRvTG93ZXJDYXNlKCkgPT0gXCJjb21wZXRpdGlvblwiKSB7XG4gICAgc3RhcnRIZWFkZXIgPSBcIiMjIyMgQ29tcGV0aXRpb25cIjtcbiAgfSBlbHNlIGlmIChcbiAgICB1cGRhdGVfdHlwZS50b0xvd2VyQ2FzZSgpID09IFwiY29tbWVyY2lhbCB0cmFjdGlvblwiIHx8XG4gICAgdXBkYXRlX3R5cGUudG9Mb3dlckNhc2UoKSA9PSBcIm1hcmtldCBzaXplXCJcbiAgKSB7XG4gICAgc3RhcnRIZWFkZXIgPSBcIiMjIyMgVHJhY3Rpb25cIjtcbiAgfSBlbHNlIGlmICh1cGRhdGVfdHlwZS50b0xvd2VyQ2FzZSgpID09IFwiZnVuZGluZ1wiKSB7XG4gICAgc3RhcnRIZWFkZXIgPSBcIiMjIyMgUm91bmQgSW5mb1wiO1xuICB9XG4gIHJldHVybiBzdGFydEhlYWRlcjtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yUmFuZ2UoXG4gIGZpbGVUZXh0OiBzdHJpbmcsXG4gIHN0YXJ0SGVhZGVyOiBzdHJpbmcsXG4gIGVkaXRvcjogRWRpdG9yLFxuICBhbGxIZWFkZXJzOiBzdHJpbmdbXVxuKSB7XG4gIGxldCBzdGFydExpbmVOdW1iZXI7XG4gIGxldCBtYXRjaGVkSGVhZGVyO1xuICBbc3RhcnRMaW5lTnVtYmVyLCBtYXRjaGVkSGVhZGVyXSA9IGZpbmRMaW5lTnVtYmVyKGZpbGVUZXh0LCBzdGFydEhlYWRlciwgMCk7XG4gIGNvbnNvbGUubG9nKGBNYXRjaGVkIEhlYWRlcjogJHttYXRjaGVkSGVhZGVyfWApO1xuICBjb25zb2xlLmxvZyhgRm91bmQgaW4gbGluZTogJHtzdGFydExpbmVOdW1iZXJ9YCk7XG4gIGxldCBzdGFydEN1cnNvclBvc2l0aW9uOiBFZGl0b3JQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuICBsZXQgZW5kQ3Vyc29yUG9zaXRpb246IEVkaXRvclBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG4gIGlmIChzdGFydExpbmVOdW1iZXIpIHtcbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKHN0YXJ0TGluZU51bWJlcik7XG4gICAgc3RhcnRDdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblxuICAgIGxldCBlbmRMaW5lTnVtYmVyO1xuICAgIGxldCBlbmRNYXRjaGVkSGVhZGVyO1xuICAgIGVuZExpbmVOdW1iZXIgPSBlZGl0b3IubGFzdExpbmUoKTtcbiAgICBpZiAoYWxsSGVhZGVycy5pbmRleE9mKG1hdGNoZWRIZWFkZXIpIDwgYWxsSGVhZGVycy5sZW5ndGggLSAxKSB7XG4gICAgICBsZXQgbmV4dEhlYWRlciA9IGFsbEhlYWRlcnNbYWxsSGVhZGVycy5pbmRleE9mKG1hdGNoZWRIZWFkZXIpICsgMV07XG5cbiAgICAgIFtlbmRMaW5lTnVtYmVyLCBlbmRNYXRjaGVkSGVhZGVyXSA9IGZpbmRMaW5lTnVtYmVyKFxuICAgICAgICBmaWxlVGV4dCxcbiAgICAgICAgbmV4dEhlYWRlcixcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coYE1hdGNoZWQgTmV4dCBIZWFkZXI6ICR7bmV4dEhlYWRlcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBpbiBsaW5lOiAke2VuZExpbmVOdW1iZXJ9YCk7XG4gICAgfVxuXG4gICAgaWYgKGVuZExpbmVOdW1iZXIpIHtcbiAgICAgIGVuZExpbmVOdW1iZXIgLT0gMTtcbiAgICAgIGVkaXRvci5zZXRDdXJzb3IoZW5kTGluZU51bWJlcik7XG4gICAgICBlbmRDdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3N0YXJ0Q3Vyc29yUG9zaXRpb24sIGVuZEN1cnNvclBvc2l0aW9uLCBtYXRjaGVkSGVhZGVyXTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlX2FmZmluaXR5X3N0YXJ0dXAoc3RhcnR1cF9uYW1lOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuICBsZXQgc3RhcnR1cDtcbiAgdHJ5IHtcbiAgICBzdGFydHVwID0gYXdhaXQgZ2V0X3N0YXJ0dXBfYnlfbmFtZShcbiAgICAgIGFmZmluaXR5QVBJS2V5LFxuICAgICAgb3duZXJfdmFsdWUsXG4gICAgICBzdGFydHVwX25hbWVcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmV3IE5vdGljZShgQ2FuIG5vdCBlc3RhYmxpc2ggY29ubmVjdGlvbiB3aXRoIEFmZmluaXR5YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXJ0dXApIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBhZGRfbm90ZXNfdG9fY29tcGFueShzdGFydHVwLCBub3RlLCBhZmZpbml0eUFQSUtleSk7XG4gICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgIG5ldyBOb3RpY2UoYFN0YXJ0dXA6ICR7c3RhcnR1cF9uYW1lfSB3YXMgTk9UIHVwZGF0ZWQgb24gQWZmaW5pdHlgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IE5vdGljZShgU3RhcnR1cDogJHtzdGFydHVwX25hbWV9IHdhcyB1cGRhdGVkIG9uIEFmZmluaXR5YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3IE5vdGljZShgU3RhcnR1cDogJHtzdGFydHVwX25hbWV9IHdhcyBOT1QgZm91bmQgb24gQWZmaW5pdHlgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZF90aGVfbmVhcmVzdF9oZWFkZXIoc2VhcmNoU3RyaW5nOiBzdHJpbmcsIGZpbGVUZXh0OiBzdHJpbmcpIHtcbiAgbGV0IGxpbmVPZlN0cmluZywgZnVsbFNlYXJjaFN0cmluZztcbiAgW2xpbmVPZlN0cmluZywgZnVsbFNlYXJjaFN0cmluZ10gPSBmaW5kTGluZU51bWJlcihmaWxlVGV4dCwgc2VhcmNoU3RyaW5nLCAwKTtcbiAgY29uc3QgaGVhZGVyUmVnZXggPSAvXiMrXFxzKy4rJC9nbTtcbiAgY29uc3QgbGluZXMgPSBmaWxlVGV4dC5zcGxpdChcIlxcblwiKTtcblxuICBmb3IgKGxldCBpID0gbGluZU9mU3RyaW5nOyBpID49IDA7IGktLSkge1xuICAgIGxldCBtYXRjaDogYW55O1xuICAgIGlmICgobWF0Y2ggPSBoZWFkZXJSZWdleC5leGVjKGxpbmVzW2ldKSkgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coYE5lYXJlc3QgaGVhZGVyIHRvOiAke3NlYXJjaFN0cmluZ30gaXMgJHttYXRjaFswXX1gKTtcbiAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgY29uc29sZS5sb2coYENhbiBub3QgZmluZCBuZWFyZXN0IHN0cmluZyBmb3I6ICR7c2VhcmNoU3RyaW5nfWApO1xuICByZXR1cm4gXCJcIjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZF9jb21wZXRpdG9yc190aHJvdWdoX3RyYWN4bihcbiAgZG9tYWluOiBzdHJpbmcsXG4gIGlzUHVibGljOiBib29sZWFuLFxuICBpc0FjcXVpcmVkOiBib29sZWFuLFxuICBjb21wYW5pZXNfcGVyX3JlcXVlc3Q6IG51bWJlclxuKSB7XG4gIGNvbnN0IHJlcXVlc3RVcmwgPSBcImh0dHBzOi8vdHJhY3huLmNvbS9hcGkvMi4yL2NvbXBhbmllc1wiO1xuICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRyYWN4bl9hcGlfa2V5OyAvL1wiY2M2YjU3NzgtMDY3ZS00ZDBlLTgyN2YtZDFhZGQzZjhiYzZlXCI7XG5cbiAgbGV0IHJlc3VsdHM6IGFueTtcbiAgdHJ5IHtcbiAgICBsZXQgcmVxdWVzdEJvZHkgPSB7XG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgY29tcGV0aXRvck9mOiBbZG9tYWluXSxcbiAgICAgICAgaXNGdW5kZWQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgc2l6ZTogY29tcGFuaWVzX3Blcl9yZXF1ZXN0LFxuICAgIH07XG5cbiAgICBpZiAoaXNBY3F1aXJlZCkge1xuICAgICAgcmVxdWVzdEJvZHlbXCJmaWx0ZXJcIl1bXCJjb21wYW55U3RhZ2VcIl0gPSBcIkFjcXVpcmVkXCI7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpYykge1xuICAgICAgcmVxdWVzdEJvZHlbXCJmaWx0ZXJcIl1bXCJjb21wYW55U3RhZ2VcIl0gPSBcIlB1YmxpY1wiO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCh7XG4gICAgICB1cmw6IHJlcXVlc3RVcmwsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgIHJlc3VsdHMgPSByZXN1bHRbXCJyZXN1bHRcIl07XG5cbiAgICAvKmZvciAobGV0IHN0YXJ0dXAgb2YgcmVzdWx0cykge1xuICAgICAgbGV0IHN0YXJ0dXBfZGV0YWlsczogYW55ID0gZXh0cmFjdF9zdGFydHVwX2RldGFpbHMoc3RhcnR1cCk7XG4gICAgICByZWxldmFudF9zdGFydHVwcy5wdXNoKHN0YXJ0dXBfZGV0YWlscyk7XG4gICAgfSovXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWQ0NvcGlsb3RQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogQnV0bGVyU2V0dGluZ3M7XG4gIHN0YXR1czogSFRNTEVsZW1lbnQ7XG5cbiAgYXN5bmMgb25sb2FkKCkge1xuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBWQ0NvcGlsb3RTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIHRoaXMuc3RhdHVzID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKCk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic3VtbWFyaXplLXN0YXJ0dXAtY29tbWFuZFwiLFxuICAgICAgbmFtZTogXCJTdW1tYXJpemUgVGhpcyBTdGFydHVwXCIsXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvciwgdmlldykgPT5cbiAgICAgICAgdGhpcy5zdW1tYXJpemVfc2VsZWN0ZWRfc3RhcnR1cF90ZXh0KGVkaXRvciwgdmlldywgdGhpcy5zdGF0dXMpLFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInJlZm9ybWF0LWFuZC11cGRhdGUtbWFzdGVyLW5vdGVcIixcbiAgICAgIG5hbWU6IFwiUmVmb3JtYXQgJiBVcGRhdGUgTWFzdGVyIE5vdGVcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PlxuICAgICAgICB0aGlzLnJlZm9ybWF0X2FuZF91cGRhdGVfbWFzdGVyX25vdGUoZWRpdG9yKSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJyZWZvcm1hdC1ub3Rlc1wiLFxuICAgICAgbmFtZTogXCJSZWZvcm1hdCBOb3Rlc1wiLFxuICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3IsIHZpZXcpID0+IHRoaXMucmVmb3JtYXRfbm90ZXMoZWRpdG9yKSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJ1cGRhdGUtbWFzdGVyLW5vdGVcIixcbiAgICAgIG5hbWU6IFwiVXBkYXRlIE1hc3RlciBOb3RlXCIsXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvciwgdmlldykgPT5cbiAgICAgICAgdGhpcy51cGRhdGVfbWFzdGVyX25vdGVfd2l0aF9zZWxlY3RlZF90ZXh0KGVkaXRvciksXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwiYWZmaW5pdHktc3RhcnR1cFwiLFxuICAgICAgbmFtZTogXCJQdXNoIFN0YXJ0dXBzIHRvIEFmZmluaXR5XCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5wdXNoX3N0YXJ0dXBzX3RvX2FmZmluaXR5KHRoaXMuc3RhdHVzKSxcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic3VtbWFyaXplLWFsbC12Yy1jb21tYW5kXCIsXG4gICAgICBuYW1lOiBcIlN1bW1hcml6ZSBBbGwgVkMgTm90ZXNcIixcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnN1bW1hcml6ZV9hbGxfdmModGhpcy5zdGF0dXMpLFxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJhZmZpbml0eS12Y1wiLFxuICAgICAgbmFtZTogXCJQdXNoIFZDcyB0byBBZmZpbml0eVwiLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucHVzaF92Y3NfdG9fYWZmaW5pdHkodGhpcy5zdGF0dXMpLFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInN0YXJ0dXAtZGVmZW5zaWJpbGl0eVwiLFxuICAgICAgbmFtZTogXCJFdmFsdWF0ZSBTdGFydHVwIERlZmVuc2liaWxpdHlcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBXb3JrZmxvd01vZGFsKHRoaXMuYXBwLCAoaW5wdXQpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN1Ym1pdHRlZCB0ZXh0IGhlcmVcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlucHV0LnNwbGl0KFwiLy8tLSBcIik7XG4gICAgICAgICAgbGV0IGRlc2MgPSByZXN1bHRbMF07XG4gICAgICAgICAgbGV0IG1vZGVsX25hbWUgPSByZXN1bHRbMV0udHJpbSgpO1xuICAgICAgICAgIHRoaXMuZGVmZW5zaWJpbGl0eV9hbmFseXNpcyhpbnB1dCwgbW9kZWxfbmFtZSwgZWRpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJzdGFydHVwLXdvcmtmbG93XCIsXG4gICAgICBuYW1lOiBcIlN0YXJ0dXAgR3VpZGFuY2UgV29ya2Zsb3dcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBXb3JrZmxvd01vZGFsKHRoaXMuYXBwLCAoaW5wdXQpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN1Ym1pdHRlZCB0ZXh0IGhlcmVcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlucHV0LnNwbGl0KFwiLy8tLSBcIik7XG4gICAgICAgICAgbGV0IGRlc2MgPSByZXN1bHRbMF07XG4gICAgICAgICAgbGV0IG1vZGVsX25hbWUgPSByZXN1bHRbMV0udHJpbSgpO1xuICAgICAgICAgIHRoaXMuZ3VpZGFuY2Vfd29ya2Zsb3coZGVzYywgbW9kZWxfbmFtZSwgZWRpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJtYXJrZXQtcmVzZWFyY2gtY29tbWFuZFwiLFxuICAgICAgbmFtZTogXCJNYXJrZXQgUmVzZWFyY2hcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBUZXh0SW5wdXRNb2RhbChcbiAgICAgICAgICB0aGlzLmFwcCxcbiAgICAgICAgICBcIm1hcmtldC1yZXNlYXJjaFwiLFxuICAgICAgICAgIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzdWJtaXR0ZWQgdGV4dCBoZXJlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtldF9yZXNlYXJjaChpbnB1dCwgZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJ1cmwtcmVzZWFyY2gtY29tbWFuZFwiLFxuICAgICAgbmFtZTogXCJVcmwgUmVzZWFyY2hcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBUZXh0SW5wdXRNb2RhbChcbiAgICAgICAgICB0aGlzLmFwcCxcbiAgICAgICAgICBcInVybC1yZXNlYXJjaFwiLFxuICAgICAgICAgIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzdWJtaXR0ZWQgdGV4dCBoZXJlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLnVybF9yZXNlYXJjaChpbnB1dCwgZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJjb21wZXRpdGlvbi1yZXNlYXJjaC1jb21tYW5kXCIsXG4gICAgICBuYW1lOiBcIkNvbXBldGl0aW9uIFJlc2VhcmNoXCIsXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0TW9kYWwgPSBuZXcgVGV4dElucHV0TW9kYWwoXG4gICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgXCJjb21wZXRpdGlvblwiLFxuICAgICAgICAgIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzdWJtaXR0ZWQgdGV4dCBoZXJlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBldGl0aW9uX3Jlc2VhcmNoKGlucHV0LCBlZGl0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaW5wdXRNb2RhbC5vcGVuKCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImRlY2stYW5hbHlzaXNcIixcbiAgICAgIG5hbWU6IFwiU3VtbWFyaXplIFBpdGNoIERlY2tcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBQREZNb2RhbCh0aGlzLmFwcCwgKHNlbGVjdGVkX2ZpbGUpID0+IHtcbiAgICAgICAgICBuZXcgTm90aWNlKGBTZWxlY3RlZDogJyR7c2VsZWN0ZWRfZmlsZX1gKTtcbiAgICAgICAgICB0aGlzLmFuYWx5emVfcGl0Y2hfZGVjayhzZWxlY3RlZF9maWxlLCBlZGl0b3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5wdXRNb2RhbC5vcGVuKCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImN1c3RvbS1yZXNlYXJjaFwiLFxuICAgICAgbmFtZTogXCJDdXN0b20gUmVzZWFyY2hcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBNdWx0aXBsZVRleHRJbnB1dE1vZGFsKHRoaXMuYXBwLCBcIlwiLCAoaW5wdXQpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN1Ym1pdHRlZCB0ZXh0IGhlcmVcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gaW5wdXQuc3BsaXQoXCIsIFwiKTtcbiAgICAgICAgICBsZXQgd2Vic2l0ZSA9IHJlc3VsdFswXTtcbiAgICAgICAgICBsZXQgcXVlcnkgPSByZXN1bHRbMV07XG4gICAgICAgICAgbGV0IHRhc2sgPSByZXN1bHRbMl07XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTdWJtaXR0ZWQgdGV4dDpcIiwgaW5wdXQpO1xuICAgICAgICAgIHRoaXMuY3VzdG9tX3NlYXJjaCh0YXNrLCB3ZWJzaXRlLCBxdWVyeSwgZWRpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJmaW5kLWludmVzdG9yc1wiLFxuICAgICAgbmFtZTogXCJGaW5kIEludmVzdG9ycyBGb3IgQSBTdGFydHVwXCIsXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0TW9kYWwgPSBuZXcgRmluZEludmVzdG9yTW9kYWwodGhpcy5hcHAsIChpbnB1dCkgPT4ge1xuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgc3VibWl0dGVkIHRleHQgaGVyZVxuICAgICAgICAgIGxldCByZXN1bHQgPSBpbnB1dC5zcGxpdChcIiwgXCIpO1xuICAgICAgICAgIGxldCBjb21wYW55ID0gcmVzdWx0WzBdO1xuICAgICAgICAgIGxldCBzdGFnZSA9IHJlc3VsdFsxXTtcbiAgICAgICAgICBsZXQgbG9jYXRpb24gPSByZXN1bHRbMl07XG4gICAgICAgICAgbGV0IGlzRm9jdXNlZCA9IHJlc3VsdFszXS50cmltKCkgPT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTdWJtaXR0ZWQgdGV4dDpcIiwgaW5wdXQpO1xuICAgICAgICAgIHRoaXMuZmluZF9pbnZlc3RvcnNfZm9yX3N0YXJ0dXAoXG4gICAgICAgICAgICBjb21wYW55LFxuICAgICAgICAgICAgc3RhZ2UsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIGlzRm9jdXNlZCxcbiAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dE1vZGFsLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwidHJhY3huLWNvbXBldGl0b3Itb3ZlcnZpZXdcIixcbiAgICAgIG5hbWU6IFwiQ29tcGV0aXRvciBPdmVydmlldyBUaHJvdWdoIFRyYWN4blwiLFxuICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvcikgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dE1vZGFsID0gbmV3IFRyYWN4bk1vZGFsKHRoaXMuYXBwLCAoaW5wdXQpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN1Ym1pdHRlZCB0ZXh0IGhlcmVcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gaW5wdXQuc3BsaXQoXCIsIFwiKTtcbiAgICAgICAgICBsZXQgY29tcGFueSA9IHJlc3VsdFswXTtcbiAgICAgICAgICBsZXQgaXNJUE8gPSByZXN1bHRbMV0udHJpbSgpID09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgIGxldCBpc0FjcXVpcmVkID0gcmVzdWx0WzJdLnRyaW0oKSA9PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBsZXQgY29tcGFuaWVzX3Blcl9yZXF1ZXN0ID0gcGFyc2VJbnQocmVzdWx0WzNdLnRyaW0oKSk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTdWJtaXR0ZWQgdGV4dDpcIik7XG4gICAgICAgICAgY29uc29sZS5sb2coY29tcGFueSk7XG4gICAgICAgICAgY29uc29sZS5sb2coaXNJUE8pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGlzQWNxdWlyZWQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGNvbXBhbmllc19wZXJfcmVxdWVzdCk7XG4gICAgICAgICAgdGhpcy50cmFjeG4oXG4gICAgICAgICAgICBjb21wYW55LFxuICAgICAgICAgICAgaXNJUE8sXG4gICAgICAgICAgICBpc0FjcXVpcmVkLFxuICAgICAgICAgICAgY29tcGFuaWVzX3Blcl9yZXF1ZXN0LFxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJmaXJlZmxpZXMtc3VtbWFyeVwiLFxuICAgICAgbmFtZTogXCJGaXJlZmxpZXMgQ2FsbCBTdW1tYXJ5XCIsXG4gICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0TW9kYWwgPSBuZXcgVGV4dElucHV0TW9kYWwoXG4gICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgXCJmaXJlZmxpZXMtc3VtbWFyeVwiLFxuICAgICAgICAgIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzdWJtaXR0ZWQgdGV4dCBoZXJlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmZpcmVmbGllc19zdW1tYXJ5KGlucHV0LCBlZGl0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaW5wdXRNb2RhbC5vcGVuKCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImZpcmVmbGllcy1zdW1tYXJ5LXRlbXBcIixcbiAgICAgIG5hbWU6IFwiRmlyZWZsaWVzIFRleHQgU3VtbWFyeSAoVGVtcClcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBGaXJlRmxpZXNUZW1wKHRoaXMuYXBwLCAoaW5wdXQpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN1Ym1pdHRlZCB0ZXh0IGhlcmVcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlucHV0LnNwbGl0KFwiJiYmIFwiKTtcbiAgICAgICAgICBsZXQganNvbl9zdHJpbmcgPSByZXN1bHRbMF07XG4gICAgICAgICAgbGV0IG1lZXRpbmdfbmFtZSA9IHJlc3VsdFsxXTtcbiAgICAgICAgICB0aGlzLmZpcmVmbGllc19zdW1tYXJ5X3RlbXAoanNvbl9zdHJpbmcsIG1lZXRpbmdfbmFtZSwgZWRpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0TW9kYWwub3BlbigpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJzdW1tYXJpc2Utc3Bva2UtbWVldGluZ1wiLFxuICAgICAgbmFtZTogXCJTcG9rZSBDYWxsIFN1bW1hcnlcIixcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRNb2RhbCA9IG5ldyBTcG9rZU1vZGFsKHRoaXMuYXBwLCAoaW5wdXQpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN1Ym1pdHRlZCB0ZXh0IGhlcmVcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCB0ZXh0OlwiLCBpbnB1dCk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlucHV0LnNwbGl0KFwiLCBcIik7XG4gICAgICAgICAgbGV0IG1lZXRpbmdfbmFtZSA9IHJlc3VsdFswXTtcbiAgICAgICAgICBsZXQgaXNEZXRhaWxlZCA9IHJlc3VsdFsxXS50cmltKCkgPT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgbGV0IG1vZGVsX25hbWUgPSByZXN1bHRbMl0udHJpbSgpO1xuICAgICAgICAgIHRoaXMuc3VtbWFyaXplX3Nwb2tlX21lZXRpbmcoXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBtZWV0aW5nX25hbWUsXG4gICAgICAgICAgICBpc0RldGFpbGVkLFxuICAgICAgICAgICAgbW9kZWxfbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dE1vZGFsLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBvcGVuYWkgPSBuZXcgT3BlbkFJKHtcbiAgICAgIGFwaUtleTogb3BlbmFpQVBJS2V5LFxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsXG4gICAgfSk7XG5cbiAgICBncm9xID0gbmV3IEdyb3Eoe1xuICAgICAgYXBpS2V5OiBncm9xQVBJS2V5LFxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coYEdyb3EgQVBJOiAke2dyb3FBUElLZXl9YCk7XG5cbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IGxvYWRpbmcuLi4uXCIpO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIlZDIENvcGlsb3QgaXMgbG9hZGluZy4uLlwiKTtcblxuICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXCJcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODA6IFZDIENvcGlsb3QgcmVhZHlcIik7XG4gICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiVkMgQ29waWxvdCBpcyByZWFkeVwiKTtcbiAgfVxuXG4gIG9udW5sb2FkKCkge1xuICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXCJcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODA6IFZDIENvcGlsb3QgbGVmdFwiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJWQyBDb3BpbG90IHNheXMgXHVEODNEXHVEQzRCXCIpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIG9wZW5haUFQSUtleSA9IHRoaXMuc2V0dGluZ3Mub3BlbkFJS2V5O1xuICAgIHRvZ2V0aGVyYWlBUElLZXkgPSB0aGlzLnNldHRpbmdzLnRvZ2V0aGVyQUlLZXk7XG4gICAgZ3JvcUFQSUtleSA9IHRoaXMuc2V0dGluZ3MuZ3JvcUFJS2V5O1xuICAgIGFmZmluaXR5QVBJS2V5ID0gdGhpcy5zZXR0aW5ncy5hZmZpbml0eUtleTtcbiAgICBvd25lcl92YWx1ZSA9IHRoaXMuc2V0dGluZ3Mub3duZXJfcGVyc29uX3ZhbHVlO1xuICAgIGNvbm5lY3Rpb25fb3duZXJfZmllbGQgPSB0aGlzLnNldHRpbmdzLmNvbm5lY3Rpb25fb3duZXJfZmllbGRfaWQ7XG4gICAgdmVudHVyZV9uZXR3b3JrX2xpc3QgPSB0aGlzLnNldHRpbmdzLnZlbnR1cmVfbmV0d29ya19saXN0X2lkO1xuICAgIGZpcmVmbGllc19hcGlfa2V5ID0gdGhpcy5zZXR0aW5ncy5maXJlZmxpZXNfYXBpO1xuICAgIHRyYWN4bl9hcGlfa2V5ID0gdGhpcy5zZXR0aW5ncy50cmFjeG5fYXBpO1xuXG4gICAgdGhpcy5zZXR0aW5ncy50ZWFtX25hbWVzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBpbnZlc3Rvcl9uYW1lcy5wdXNoKGVsZW1lbnQudHJpbSgpKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICBvcGVuYWlBUElLZXkgPSB0aGlzLnNldHRpbmdzLm9wZW5BSUtleTtcbiAgICB0b2dldGhlcmFpQVBJS2V5ID0gdGhpcy5zZXR0aW5ncy50b2dldGhlckFJS2V5O1xuICAgIGdyb3FBUElLZXkgPSB0aGlzLnNldHRpbmdzLmdyb3FBSUtleTtcbiAgICBhZmZpbml0eUFQSUtleSA9IHRoaXMuc2V0dGluZ3MuYWZmaW5pdHlLZXk7XG4gICAgb3duZXJfdmFsdWUgPSB0aGlzLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZTtcbiAgICBjb25uZWN0aW9uX293bmVyX2ZpZWxkID0gdGhpcy5zZXR0aW5ncy5jb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkO1xuICAgIHZlbnR1cmVfbmV0d29ya19saXN0ID0gdGhpcy5zZXR0aW5ncy52ZW50dXJlX25ldHdvcmtfbGlzdF9pZDtcbiAgICBmaXJlZmxpZXNfYXBpX2tleSA9IHRoaXMuc2V0dGluZ3MuZmlyZWZsaWVzX2FwaTtcbiAgICB0cmFjeG5fYXBpX2tleSA9IHRoaXMuc2V0dGluZ3MudHJhY3huX2FwaTtcbiAgICB0aGlzLnNldHRpbmdzLnRlYW1fbmFtZXMuc3BsaXQoXCIsXCIpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGludmVzdG9yX25hbWVzLnB1c2goZWxlbWVudC50cmltKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgdHJhY3huKFxuICAgIGNvbXBhbnk6IHN0cmluZyxcbiAgICBpc0lQTzogYm9vbGVhbixcbiAgICBpc0FjcXVpcmVkOiBib29sZWFuLFxuICAgIGNvbXBhbmllc19wZXJfcmVxdWVzdDogbnVtYmVyLFxuICAgIGVkaXRvcjogRWRpdG9yXG4gICkge1xuICAgIGxldCBhbGxfc3RhcnR1cHMgPSBhd2FpdCBmaW5kX2NvbXBldGl0b3JzX3Rocm91Z2hfdHJhY3huKFxuICAgICAgY29tcGFueSxcbiAgICAgIGlzSVBPLFxuICAgICAgaXNBY3F1aXJlZCxcbiAgICAgIGNvbXBhbmllc19wZXJfcmVxdWVzdFxuICAgICk7XG5cbiAgICBjb25zdCBzcGVjaWFsRm9ybWF0ID0gdHJ1ZTtcbiAgICBsZXQgYWxsX3N0YXJ0dXBzX2RldGFpbHM6IGFueSA9IFtdO1xuICAgIGZvciAobGV0IHN0YXJ0dXAgb2YgYWxsX3N0YXJ0dXBzKSB7XG4gICAgICBsZXQgc3RhcnR1cF9kZXRhaWxzID0gZXh0cmFjdF9zdGFydHVwX2RldGFpbHMoc3RhcnR1cCk7XG4gICAgICBsZXQgYWNxdWlzaXRpb25fZGV0YWlscyA9IHt9O1xuICAgICAgaWYgKGlzSVBPKSB7XG4gICAgICAgIGFjcXVpc2l0aW9uX2RldGFpbHMgPSBnZXRfaXBvX2RldGFpbHMoc3RhcnR1cCk7IC8vb3IgZ2V0X2FjcXVpc2l0aW9uX2RldGFpbHNcbiAgICAgIH0gZWxzZSBpZiAoaXNBY3F1aXJlZCkge1xuICAgICAgICBhY3F1aXNpdGlvbl9kZXRhaWxzID0gZ2V0X2FjcXVpc2l0aW9uX2RldGFpbHMoc3RhcnR1cCk7XG4gICAgICB9XG4gICAgICBsZXQgbWVyZ2VkRGV0YWlscyA9IHsgLi4uc3RhcnR1cF9kZXRhaWxzLCAuLi5hY3F1aXNpdGlvbl9kZXRhaWxzIH07XG4gICAgICBhbGxfc3RhcnR1cHNfZGV0YWlscy5wdXNoKG1lcmdlZERldGFpbHMpO1xuICAgIH1cblxuICAgIGxldCB0YWJsZSA9IGZvcm1hdE9iamVjdHNUb01hcmtkb3duVGFibGUoXG4gICAgICBhbGxfc3RhcnR1cHNfZGV0YWlscyxcbiAgICAgIHNwZWNpYWxGb3JtYXRcbiAgICApO1xuXG4gICAgbGV0IHJlbGV2YW50X2ZlZWRzID0gZ2V0X3JlbGV2YW50X2ZlZWRzKGFsbF9zdGFydHVwcyk7XG4gICAgbGV0IGZlZWRfdGV4dCA9XG4gICAgICAnIyMjIyMgVHJhY3huIEZlZWQgb2YgQ29tcGV0aXRvcnMgZm9yIERlZXBlciBkaXZlXFxuPiBOb3RpY2UgdGhhdCB0aGUgXCJmZWVkXCIgaXMgdGhlIGZpcnN0IHBhcnQgaW4gdGhlIHBhdGhcXG5cXG4nO1xuICAgIGZvciAobGV0IFtmdWxscGF0aCwgbGlua10gb2YgT2JqZWN0LmVudHJpZXMocmVsZXZhbnRfZmVlZHMpKSB7XG4gICAgICBmZWVkX3RleHQgKz0gYC0gWyR7ZnVsbHBhdGh9XSgke2xpbmt9KVxcbmA7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRlciA9IGAjIyMjIFRyYWN4biBDb21wZXRpdGl2ZSBPdmVydmlldyBmb3IgJHtjb21wYW55fVxcbmA7XG4gICAgaWYgKGlzSVBPKSB7XG4gICAgICBoZWFkZXIgPSBgIyMjIyBJUE9lZCBDb21wZXRpdGlvbiBmb3IgJHtjb21wYW55fVxcbmA7XG4gICAgfSBlbHNlIGlmIChpc0FjcXVpcmVkKSB7XG4gICAgICBoZWFkZXIgPSBgIyMjIyBBY3F1aXJlZCBDb21wZXRpdGlvbiBmb3IgJHtjb21wYW55fVxcbmA7XG4gICAgfVxuICAgIGxldCBmaW5hbF90ZXh0ID0gaGVhZGVyICsgdGFibGUgKyBcIlxcblxcblwiICsgZmVlZF90ZXh0O1xuXG4gICAgbGV0IHBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIHRoaXMuZGlzcGxheW1lc3NhZ2UoZmluYWxfdGV4dCwgZWRpdG9yLCBwb3NpdGlvbik7XG4gIH1cblxuICBhc3luYyBnZXRfYWxsX2ludmVzdG9ycyhcbiAgICBpc0ZvY3VzZWQ6IGJvb2xlYW5cbiAgKTogUHJvbWlzZTx7IHRleHQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1bXT4ge1xuICAgIGxldCBhbGxfZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgbGV0IGNvbm5lY3RlZF9pbnZlc3RvcnNfZmlsZXM6IHsgdGV4dDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVtdID0gW107XG4gICAgZm9yIChsZXQgZmlsZSBvZiBhbGxfZmlsZXMpIHtcbiAgICAgIGxldCB0ZXh0ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcblxuICAgICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHRleHQuaW5jbHVkZXMoXCIjbmV0d29yay9zdHJvbmdcIikgfHxcbiAgICAgICAgICAgIHRleHQuaW5jbHVkZXMoXCIjdGVzdFJlbGF0aW9uXCIpIHx8XG4gICAgICAgICAgICB0ZXh0LmluY2x1ZGVzKFwiI25ldHdvcmsvZmF2b3VyaXRlXCIpKSAmJlxuICAgICAgICAgIHRleHQuaW5jbHVkZXMoXCIjbmV0d29yay9jb25uZWN0ZWRcIikgJiZcbiAgICAgICAgICB0ZXh0LmluY2x1ZGVzKFwiI1BlcnNvbi9WQ1wiKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25uZWN0ZWRfaW52ZXN0b3JzX2ZpbGVzLnB1c2goeyB0ZXh0OiB0ZXh0LCBuYW1lOiBmaWxlLmJhc2VuYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGV4dC5pbmNsdWRlcyhcIiNuZXR3b3JrL2Nvbm5lY3RlZFwiKSAmJlxuICAgICAgICAgIHRleHQuaW5jbHVkZXMoXCIjUGVyc29uL1ZDXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbm5lY3RlZF9pbnZlc3RvcnNfZmlsZXMucHVzaCh7IHRleHQ6IHRleHQsIG5hbWU6IGZpbGUuYmFzZW5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3RlZF9pbnZlc3RvcnNfZmlsZXM7XG4gIH1cblxuICBhc3luYyBsb2NhbERCKHRleHRfdG9fZW1iZWQ6IHN0cmluZ1tdLCBtZXRhZGF0YTogc3RyaW5nW10pIHtcbiAgICBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSA9IG9wZW5haUFQSUtleTtcbiAgICBjb25zdCB2ZWN0b3JTdG9yZSA9IGF3YWl0IE1lbW9yeVZlY3RvclN0b3JlLmZyb21UZXh0cyhcbiAgICAgIHRleHRfdG9fZW1iZWQsXG4gICAgICBtZXRhZGF0YSxcbiAgICAgIG5ldyBPcGVuQUlFbWJlZGRpbmdzKClcbiAgICApO1xuXG4gICAgcmV0dXJuIHZlY3RvclN0b3JlO1xuICB9XG5cbiAgYXN5bmMgZ2V0X21vc3RfcmVsZXZhbnRfaW52ZXN0b3JfZnJvbV9tZW1vcnkoXG4gICAgaW52REI6IE1lbW9yeVZlY3RvclN0b3JlLFxuICAgIGNsZWFuZWRfY2h1bms6IHN0cmluZ1xuICApIHtcbiAgICBjb25zdCBjbG9zZXN0SW52ZXN0b3JzID0gYXdhaXQgaW52REIuc2ltaWxhcml0eVNlYXJjaChjbGVhbmVkX2NodW5rLCAyMCk7XG5cbiAgICBsZXQgZml0X2ludmVzdG9yc19saXN0OiBhbnlbXSA9IFtdO1xuICAgIGNsb3Nlc3RJbnZlc3RvcnMuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICBjb25zdCBpbnZlc3RtZW50Rm9jdXNTdGFydCA9IFwiSW52ZXN0bWVudCBGb2N1czpcIjtcbiAgICAgIGNvbnN0IHNwZWNpYWxFbmQgPSBcIlNwZWNpYWwgSW5mbzpcIjtcblxuICAgICAgY29uc3QgaW52ZXN0b3JfZGVzYyA9IGRvY1tcInBhZ2VDb250ZW50XCJdO1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9XG4gICAgICAgIGludmVzdG9yX2Rlc2MuaW5kZXhPZihpbnZlc3RtZW50Rm9jdXNTdGFydCkgK1xuICAgICAgICBpbnZlc3RtZW50Rm9jdXNTdGFydC5sZW5ndGg7XG4gICAgICBjb25zdCBlbmRJbmRleCA9IGludmVzdG9yX2Rlc2MuaW5kZXhPZihzcGVjaWFsRW5kKTtcblxuICAgICAgY29uc3QgaW52ZXN0bWVudEZvY3VzID0gaW52ZXN0b3JfZGVzYy5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgY29uc3Qgc3BlY2lhbEluZm8gPSBpbnZlc3Rvcl9kZXNjLnN1YnN0cmluZyhlbmRJbmRleCArIHNwZWNpYWxFbmQubGVuZ3RoKTtcblxuICAgICAgZml0X2ludmVzdG9yc19saXN0LnB1c2goXG4gICAgICAgIGNyZWF0ZUludmVzdG9yT2JqZWN0KFxuICAgICAgICAgIGRvY1tcIm1ldGFkYXRhXCJdLFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgXCJcIixcbiAgICAgICAgICBpbnZlc3RtZW50Rm9jdXMudHJpbSgpLFxuICAgICAgICAgIHNwZWNpYWxJbmZvLnRyaW0oKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBmaXRfaW52ZXN0b3JzX2xpc3Q7XG4gIH1cblxuICBhc3luYyBmaW5kX2ludmVzdG9yc19mb3Jfc3RhcnR1cChcbiAgICBjb21wYW55OiBzdHJpbmcsXG4gICAgc3RhZ2U6IHN0cmluZyxcbiAgICBsb2NhdGlvbjogc3RyaW5nLFxuICAgIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgICBlZGl0b3I6IEVkaXRvclxuICApIHtcbiAgICBuZXcgTm90aWNlKFwiRmluZGluZyBiZXN0IGludmVzdG9ycy4uLlwiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHNlYXJjaGluZyBmb3IgYmVzdCBpbnZlc3RvcnMuLi5cIik7XG4gICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyBzZWFyY2hpbmcgZm9yIGJlc3QgaW52ZXN0b3JzLi4uXCIpO1xuICAgIGxldCBwb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblxuICAgIGxldCBjb25uZWN0ZWRfaW52ZXN0b3JzID0gYXdhaXQgdGhpcy5nZXRfYWxsX2ludmVzdG9ycyhpc0ZvY3VzZWQpO1xuICAgIGxldCBjb25uZWN0ZWRfaW52ZXN0b3JzX2pzb246IGFueSA9IFtdO1xuICAgIGZvciAobGV0IFtpLCBjb25uZWN0ZWRfaW52ZXN0b3JdIG9mIE9iamVjdC5lbnRyaWVzKGNvbm5lY3RlZF9pbnZlc3RvcnMpKSB7XG4gICAgICBsZXQgbmFtZSA9IGNvbm5lY3RlZF9pbnZlc3RvcltcIm5hbWVcIl07XG4gICAgICBsZXQgdGV4dCA9IGNvbm5lY3RlZF9pbnZlc3RvcltcInRleHRcIl07XG4gICAgICBjb25uZWN0ZWRfaW52ZXN0b3JzX2pzb24ucHVzaChnZW5lcmF0ZV9pbnZlc3Rvcl9qc29uKG5hbWUsIHRleHQpKTtcbiAgICB9XG5cbiAgICAvL2ZpbmQgd2hpY2ggaW52ZXN0b3JzIGFyZSBlbGlnaWJsZSBmcm9tIHRoZSBsaXN0IGJhc2VkIG9uIGdlbyBhbmQgc3RhZ2UgZm9jdXNcbiAgICBsZXQgZml0X2ludmVzdG9ycyA9IGZpbmRfZWxpZ2libGVfaW52ZXN0b3JzKFxuICAgICAgY29ubmVjdGVkX2ludmVzdG9yc19qc29uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBzdGFnZVxuICAgICk7XG5cbiAgICBjb25zb2xlLmxvZyhgV2UgZm91bmQgJHtmaXRfaW52ZXN0b3JzLmxlbmd0aH0gc3VpdGFibGUgaW52ZXN0b3JzYCk7XG5cbiAgICAvL2luZGV4IGludmVzdG9yc1xuICAgIGxldCBpbnZlc3RvcnNfaW5kZXg6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IGludmVzdG9yX25hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IFtpLCBpbnZlc3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMoZml0X2ludmVzdG9ycykpIHtcbiAgICAgIGxldCBpbnZlc3Rvcl9uYW1lID0gaW52ZXN0b3JbXCJuYW1lXCJdO1xuICAgICAgbGV0IGluZHVzdHJ5ID0gaW52ZXN0b3JbXCJpbmR1c3RyeVwiXTtcbiAgICAgIGxldCBzcGVjaWFsaXR5ID0gaW52ZXN0b3JbXCJzcGVjaWFsaXR5XCJdO1xuICAgICAgaW52ZXN0b3JzX2luZGV4LnB1c2goXG4gICAgICAgIGBJbnZlc3RtZW50IEZvY3VzOiAke2luZHVzdHJ5fVxcblNwZWNpYWwgSW5mbzogJHtzcGVjaWFsaXR5fWBcbiAgICAgICk7XG4gICAgICBpbnZlc3Rvcl9uYW1lcy5wdXNoKGAke2ludmVzdG9yW1wibmFtZVwiXX1gKTtcbiAgICB9XG4gICAgbGV0IGludmVzdF9kZXNjcmlwdGlvbl9pbmRleCA9IGF3YWl0IHRoaXMubG9jYWxEQihcbiAgICAgIGludmVzdG9yc19pbmRleCxcbiAgICAgIGludmVzdG9yX25hbWVzXG4gICAgKTtcblxuICAgIGxldCBiZXN0X2ZpdF9pbnZlc3RvciA9IGF3YWl0IHRoaXMuZ2V0X21vc3RfcmVsZXZhbnRfaW52ZXN0b3JfZnJvbV9tZW1vcnkoXG4gICAgICBpbnZlc3RfZGVzY3JpcHRpb25faW5kZXgsXG4gICAgICBjb21wYW55XG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKGJlc3RfZml0X2ludmVzdG9yKTtcbiAgICBsZXQgbG9hZGluZ0ludGVydmFsID0gdGhpcy5jcmVhdGVfbG9hZGluZ19pbnRlcnZhbChcbiAgICAgIFwiRmluZGluZyBiZXN0IGludmVzdG9yc1wiXG4gICAgKTtcblxuICAgIGxldCBtZXNzYWdlID0gXCIjIyMjIE1vc3Qgc3VpdGFibGUgaW52ZXN0b3JzXFxuXCI7XG4gICAgbGV0IGludmVzdG9yc19tZXNzYWdlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpbnZlc3RvciBvZiBiZXN0X2ZpdF9pbnZlc3Rvcikge1xuICAgICAgaW52ZXN0b3JzX21lc3NhZ2UgKz0gXCItIFwiICsgXCJbW1wiICsgaW52ZXN0b3JbXCJuYW1lXCJdICsgXCJdXVwiICsgXCJcXG5cIjtcblxuICAgICAgaW52ZXN0b3JzX21lc3NhZ2UgKz0gYFxcdC0gSW5kdXN0cnk6ICR7aW52ZXN0b3JbXCJpbmR1c3RyeVwiXX1cXG5cXHQtIFNwZWNpYWw6ICR7aW52ZXN0b3JbXCJzcGVjaWFsaXR5XCJdfVxcblxcbmA7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gaW52ZXN0b3JzX21lc3NhZ2U7XG5cbiAgICBsZXQgZXh0cmFfdGV4dCA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgKz1cbiAgICAgICAgXCJcXG5cXG4jIyMjIyBHZW5lcmFsbHkgc3VpdGFibGUgaW52ZXN0b3JzIGJhc2VkIG9uIGdlbyBhbmQgc3RhZ2VcXG5cIjtcbiAgICAgIGZvciAobGV0IGludmVzdG9yIG9mIGZpdF9pbnZlc3RvcnMpIHtcbiAgICAgICAgZXh0cmFfdGV4dCArPSBcIi0gXCIgKyBcIltbXCIgKyBpbnZlc3RvcltcIm5hbWVcIl0gKyBcIl1dXCIgKyBcIlxcblwiO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgaW4gZXh0cmFjdGluZyBleHRyYSBpbnZlc3RvcnNcIik7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gZXh0cmFfdGV4dDtcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcblxuICAgIHRoaXMuZGlzcGxheW1lc3NhZ2UobWVzc2FnZSwgZWRpdG9yLCBwb3NpdGlvbik7XG4gICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICB9XG5cbiAgYXN5bmMgc3VtbWFyaXplX3NlbGVjdGVkX3N0YXJ0dXBfdGV4dChcbiAgICBlZGl0b3I6IEVkaXRvcixcbiAgICB2aWV3OiBNYXJrZG93blZpZXcgfCBNYXJrZG93bkZpbGVJbmZvLFxuICAgIHN0YXR1czogSFRNTEVsZW1lbnRcbiAgKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgc2VsZWN0ZWQgdGV4dCBmcm9tIGEgc3RhcnR1cCwgc3VtbWFyaXplcyBpdCwgYW5kIHRoZW4gcHV0cyBpdCBiYWNrIGluIHRoZSBmaWxlXG4gICAgICogVGhlIFwiZnVsbC10ZXh0XCIgZ2V0cyBhcHBlbmVkIGFmdGVyIHRoZSBoZWFkaW5nICcjIFN0b3AgSW5kZXhpbmcnIHN1Y2ggdGhhdCBpdCBpcyBub3QgaW5kZXhlZCBhbnltb3JlIGJ5IHRoZSBlbWJlZGRpbmcgZW5naW5lXG4gICAgICogVGhpcyBhbHNvIGhlbHBzIHRvIGF2b2lkIHB1c2hpbmcgYWxsIG9mIHRoZSBjb252b2x1dGVkIHRleHQgaW50byBBZmZpbml0eSBsYXRlciBvblxuICAgICAqL1xuXG4gICAgY29uc3Qgc2VsID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgIG5ldyBOb3RpY2UoXCJTdW1tYXJpemluZy4uLlwiKTtcbiAgICBzdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCBzdW1tYXJpemluZy4uLlwiKTtcbiAgICBzdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyBzdW1tYXJpemluZy4uLlwiKTtcblxuICAgIGNvbnN0IHN5c3RlbV9wcm9tcHQgPVxuICAgICAgXCJZb3UgYXJlIGEgc3VtbWFyaXplciBmb3IgbXkgbm90ZXMgYWJvdXQgc3RhcnR1cHMuIFlvdXIgam9iIGlzIHRvIHJlYWQgdGhyb3VnaCBteSBub3RlcyBhbmQgY3JlYXRlIGEgc3VtbWFyeSBpbiB0aGUgZm9sbG93aW5nIHNjaGVtYTpcXG5cXFxuLSAqKlRlYW0qKjo8dGhlIGZvdW5kZXIgdGVhbSBiZWhpbmQgdGhlIHN0YXJ0dXA+XFxuXFxuXFxcbi0gKipQcm9kdWN0Kio6PHRoZSBwcm9kdWN0IGFuZCB0aGUgcHJvYmxlbSBpdCBzb2x2ZXM+XFxuXFxuXFxcbi0gKipUcmFjdGlvbioqOjxob3cgbXVjaCByZXZlbnVlIGhhcyB0aGUgc3RhcnR1cCBnZW5lcmF0ZWQgc28gZmFyLCBob3cgbWFueSBjdXN0b21lcnMgZG8gdGhleSBoYXZlPlxcblxcblxcXG4tICoqUm91bmQqKjo8aG93IG11Y2ggbW9uZXkgaGF2ZSB0aGV5IHJhaXNlZCBzbyBmYXIgYXQgd2hhdCB0ZXJtcy4gSG93IG11Y2ggbW9uZXkgYXJlIHRoZXkgcmFpc2luZyBub3c+XCI7XG5cbiAgICBsZXQgbmV3X3N1bW1hcnkgPSBhd2FpdCBvcGVuYWlfanMoZ3B0XzRfbGF0ZXN0LCBzZWwsIHN5c3RlbV9wcm9tcHQpO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50ID1cbiAgICAgIFwiI2dwdF9zdW1tYXJpemVkLCAjQWRkSGFzaHRhZ3MsICNyZXZpZXdfc3RhcnR1cCBcXG5cIiArXG4gICAgICBuZXdfc3VtbWFyeSArXG4gICAgICBcIlxcblwiICtcbiAgICAgIFwiIyBTdG9wIEluZGV4aW5nIFxcbiMjIE5vdGVzXFxuXCIgK1xuICAgICAgc2VsO1xuICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHJlcGxhY2VtZW50KTtcbiAgICBzdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCByZWFkeVwiKTtcbiAgICBzdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyByZWFkeVwiKTtcbiAgfVxuXG4gIGFzeW5jIHB1c2hfc3RhcnR1cHNfdG9fYWZmaW5pdHkoc3RhdHVzOiBIVE1MRWxlbWVudCkge1xuICAgIC8qKlxuICAgICAqIFB1c2ggYWxsIGVsaWdpYmxlIHN0YXJ0dXBzIHRvIGFmZmluaXR5IChub3RpZnkgbWUgb3RoZXJ3aXNlKVxuICAgICAqL1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIHN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHN5bmNpbmcgd2l0aCBBZmZpbml0eS4uLlwiKTtcbiAgICBzdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyBwdXNoaW5nIHN0YXJ0dXAgaW5mbyB0byBBZmZpbml0eS4uLlwiKTtcblxuICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsZXMpIHtcbiAgICAgIGxldCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pO1xuICAgICAgaWYgKHN0YXJ0dXBfcmVhZHlfZm9yX2FmZmluaXR5KGZpbGVfY29udGVudCkpIHtcbiAgICAgICAgbGV0IFt0aXRsZSwgc3Vic3RyaW5nc10gPSBleHRyYWN0X3RpdGxlX2FuZF9ub3RlKGZpbGVfY29udGVudCk7XG4gICAgICAgIGxldCBzdGFydHVwX25hbWUgPSBTdHJpbmcodGl0bGUpO1xuICAgICAgICBzdGFydHVwX25hbWUgPSBjbGVhbl90ZXh0KHN0YXJ0dXBfbmFtZSk7XG4gICAgICAgIGxldCBub3RlID0gc3Vic3RyaW5nc1sxXTtcbiAgICAgICAgbm90ZSA9IG5vdGUucmVwbGFjZSgvXig9PXxcXCpcXCp8I3syLH0pJC9nLCBcIlwiKTtcblxuICAgICAgICBsZXQgc3RhcnR1cF91cGRhdGVkID0gYXdhaXQgdXBkYXRlX2FmZmluaXR5X3N0YXJ0dXAoc3RhcnR1cF9uYW1lLCBub3RlKTtcblxuICAgICAgICBpZiAoc3RhcnR1cF91cGRhdGVkKSB7XG4gICAgICAgICAgLy9yZW1vdmUgdGhlICNBZmZpbml0eVxuICAgICAgICAgIGZpbGVfY29udGVudCA9IGZpbGVfY29udGVudC5yZXBsYWNlKC8jQWZmaW5pdHkvZywgXCJcIik7XG4gICAgICAgICAgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGl0ZW0sIGZpbGVfY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXcgTm90aWNlKFwiRG9uZSFcIik7XG4gICAgc3RhdHVzLnNldFRleHQoXCJcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODA6IFZDIENvcGlsb3QgcmVhZHlcIik7XG4gICAgc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIkNvcGlsb3QgaXMgcmVhZHlcIik7XG4gIH1cblxuICBhc3luYyBzdW1tYXJpemVfYWxsX3ZjKHN0YXR1czogSFRNTEVsZW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN1bW1hcml6ZWQgYWxsIFZDIG5vdGVzIHRoYXQgYXJlIGVsaWdpYmxlIGZvciBzdW1tYXJpemF0aW9uIChwZW9wbGUgb3IgZW50aXRpZXMgSSBhbSBjb25uZWN0ZWQgd2l0aClcbiAgICAgKi9cblxuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIHN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHN1bW1hcml6aW5nLi4uXCIpO1xuICAgIHN0YXR1cy5zZXRBdHRyKFxuICAgICAgXCJ0aXRsZVwiLFxuICAgICAgXCJWQyBDb3BpbG90IGlzIHN1bW1hcml6aW5nIGFsbCB5b3VyIFZDIGNvbm5lY3Rpb25zLi4uXCJcbiAgICApO1xuICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsZXMpIHtcbiAgICAgIC8vY29uc29sZS5sb2coaXRlbS5uYW1lKVxuICAgICAgbGV0IGZpbGVfY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSk7XG4gICAgICBpZiAoaXNfc3VtbWFyaXphYmxlKGZpbGVfY29udGVudCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFdlIGFyZSBjaGFuZ2luZyBmaWxlOiAke2l0ZW0ubmFtZX1gKTtcbiAgICAgICAgLy9XZSBzaG91bGQgc3VtbWFyaXplIHRoaXMgZmlsZSB0aGVuXG4gICAgICAgIGxldCBbbmV3X3RleHQsIHN1bW1hcnksIHRpdGxlXSA9IGF3YWl0IHN1bW1hcml6ZV92Y190ZXh0KGZpbGVfY29udGVudCk7XG5cbiAgICAgICAgaWYgKHRpdGxlICE9IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgbmV3X3RleHQpO1xuICAgICAgICAgIG5ldyBOb3RpY2UoYCR7dGl0bGV9IGhhcyBiZWVuIHN1bW1hcml6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHJlYWR5XCIpO1xuICAgIHN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJWQyBDb3BpbG90IGlzIHJlYWR5XCIpO1xuICB9XG5cbiAgYXN5bmMgcHVzaF92Y3NfdG9fYWZmaW5pdHkoc3RhdHVzOiBIVE1MRWxlbWVudCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcHVzaGVzIGFsbCByZWFkeSBWQ3MgdG8gYWZmaW5pdHksIGl0IGFsc28gbm90aWZpZXMgdXMgaWYgYSBwZXJzb24gY2FuIG5vdCBiZSBmb3VuZCBvbiBhZmZpbml0eVxuICAgICAqL1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIHN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHN5bmNpbmcgd2l0aCBBZmZpbml0eS4uLlwiKTtcbiAgICBzdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyBwdXNoaW5nIFZDcyBpbmZvIHRvIEFmZmluaXR5Li4uXCIpO1xuICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsZXMpIHtcbiAgICAgIGxldCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pO1xuICAgICAgaWYgKHZjX3JlYWR5X2Zvcl9hZmZpbml0eShmaWxlX2NvbnRlbnQpKSB7XG4gICAgICAgIGxldCBbdGl0bGUsIHN1YnN0cmluZ3NdID0gZXh0cmFjdF90aXRsZV9hbmRfbm90ZShmaWxlX2NvbnRlbnQpO1xuICAgICAgICBsZXQgc3VtbWFyeSA9IHN1YnN0cmluZ3NbMV07XG4gICAgICAgIGxldCBwZXJzb25fbmFtZSA9IFN0cmluZyh0aXRsZSk7XG4gICAgICAgIHBlcnNvbl9uYW1lID0gY2xlYW5fdGV4dChwZXJzb25fbmFtZSk7XG4gICAgICAgIGxldCBub3RlID0gc3Vic3RyaW5nc1sxXTtcbiAgICAgICAgbm90ZSA9IG5vdGUucmVwbGFjZSgvXig9PXxcXCpcXCp8I3syLH0pJC9nLCBcIlwiKTtcblxuICAgICAgICBsZXQgcGVyc29uID0gYXdhaXQgZ2V0X3BlcnNvbl9ieV9uYW1lKGFmZmluaXR5QVBJS2V5LCBwZXJzb25fbmFtZSk7XG5cbiAgICAgICAgaWYgKHBlcnNvbikge1xuICAgICAgICAgIGxldCBwZXJzb25faWQgPSBwZXJzb25bXCJpZFwiXTtcbiAgICAgICAgICBsZXQgcGVyc29uX2RldGFpbHMgPSBhd2FpdCBnZXRfcGVyc29uX2RldGFpbHMoXG4gICAgICAgICAgICBhZmZpbml0eUFQSUtleSxcbiAgICAgICAgICAgIHBlcnNvbl9pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGxpc3RfZW50cnlfaWQgPSBhd2FpdCBpc19wZXJzb25faW5fdmVudHVyZV9uZXR3b3JrKFxuICAgICAgICAgICAgYWZmaW5pdHlBUElLZXksXG4gICAgICAgICAgICBwZXJzb25fZGV0YWlscyxcbiAgICAgICAgICAgIHZlbnR1cmVfbmV0d29ya19saXN0XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChsaXN0X2VudHJ5X2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vaWYgcGVyc29uIGlzIGluIHZlbnR1cmUgbmV0d29ya1xuICAgICAgICAgICAgLy90b2RvIEkgdGhpbmsgcmVtb3ZpbmcgdGhpcyB3aWxsIGhhdmUgbm8gbmVnYXRpdmUgZWZmZWN0P1xuICAgICAgICAgICAgLy9sZXQgcGVyc29uX3ZlbnR1cmVfbmV0d29ya19maWVsZHMgPSBhd2FpdCBnZXRfZmllbGRfdmFsdWVzKGFmZmluaXR5QVBJS2V5LCAnbGlzdF9lbnRyeV9pZCcsIGxpc3RfZW50cnlfaWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vQWRkIHRoZSBwZXJzb24gdG8gdmVudHVyZSBuZXR3b3JrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBhZGRfZW50cnlfdG9fbGlzdChcbiAgICAgICAgICAgICAgYWZmaW5pdHlBUElLZXksXG4gICAgICAgICAgICAgIHZlbnR1cmVfbmV0d29ya19saXN0LFxuICAgICAgICAgICAgICBwZXJzb25faWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcGVyc29uX2RldGFpbHMgPSBhd2FpdCBnZXRfcGVyc29uX2RldGFpbHMoXG4gICAgICAgICAgICAgIGFmZmluaXR5QVBJS2V5LFxuICAgICAgICAgICAgICBwZXJzb25faWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxpc3RfZW50cnlfaWQgPSBhd2FpdCBpc19wZXJzb25faW5fdmVudHVyZV9uZXR3b3JrKFxuICAgICAgICAgICAgICBhZmZpbml0eUFQSUtleSxcbiAgICAgICAgICAgICAgcGVyc29uX2RldGFpbHMsXG4gICAgICAgICAgICAgIHZlbnR1cmVfbmV0d29ya19saXN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy9BZGQgbm90ZSB0YWtlciBhcyBvd25lciBvZiB0aGUgY29ubmVjdGlvbiBvbiBBZmZpbml0eVxuICAgICAgICAgICAgYXdhaXQgYWRkX2ZpZWxkX3ZhbHVlKFxuICAgICAgICAgICAgICBhZmZpbml0eUFQSUtleSxcbiAgICAgICAgICAgICAgY29ubmVjdGlvbl9vd25lcl9maWVsZCxcbiAgICAgICAgICAgICAgcGVyc29uX2lkLFxuICAgICAgICAgICAgICBvd25lcl92YWx1ZSxcbiAgICAgICAgICAgICAgbGlzdF9lbnRyeV9pZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYWRkX25vdGVzX3RvX3BlcnNvbihcbiAgICAgICAgICAgIGFmZmluaXR5QVBJS2V5LFxuICAgICAgICAgICAgcGVyc29uX2lkLFxuICAgICAgICAgICAgbm90ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBWQzogJHtwZXJzb25fbmFtZX0gd2FzIHVwZGF0ZWQgb24gQWZmaW5pdHlgKTtcbiAgICAgICAgICAgIGZpbGVfY29udGVudCA9IGZpbGVfY29udGVudC5yZXBsYWNlKC8jQWZmaW5pdHkvZywgXCJcIik7XG4gICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgZmlsZV9jb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICAgICAgYFZDOiAke3BlcnNvbl9uYW1lfSB3YXMgRk9VTkQgYnV0IE5PVCB1cGRhdGVkIG9uIEFmZmluaXR5YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3IE5vdGljZShgVkM6ICR7cGVyc29uX25hbWV9IHdhcyBOT1QgRk9VTkQgb24gQWZmaW5pdHlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCByZWFkeVwiKTtcbiAgICBzdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyByZWFkeVwiKTtcbiAgfVxuXG4gIGFzeW5jIHVybF9yZXNlYXJjaCh1cmw6IHN0cmluZywgZWRpdG9yOiBFZGl0b3IpIHtcbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KGBcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODAgXHVEODNEXHVERDBFOiBWQyBDb3BpbG90IHJlc2VhcmNoaW5nICR7dXJsfS4uLmApO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIkNvcGlsb3QgaXMgcmVzZWFyY2hpbmcgdGhlIHVybFwiKTtcblxuICAgIGxldCBmaW5hbF90ZXh0ID0gXCJcIjtcbiAgICBsZXQgcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIFwiaHR0cHM6Ly91cmwtcmVzZWFyY2hlci1jb250YWluZXIteG01bG1kbnN4cS1leS5hLnJ1bi5hcHBcIixcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgb3BlbmFpX2tleTogb3BlbmFpQVBJS2V5LFxuICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBmaW5hbF90ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGZpbmFsX3RleHQgPSBmb3JtYXRfdXJsX3RleHQoZmluYWxfdGV4dCwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYEVycm9yIHdoZW4gZG9pbmcgdXJsIHJlc2VhcmNoOiAke2Vycm9yfWApO1xuICAgICAgbmV3IE5vdGljZShgRXJyb3Igd2hlbiBkb2luZyB1cmwgcmVzZWFyY2hgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BsYXltZXNzYWdlKGZpbmFsX3RleHQsIGVkaXRvciwgcG9zaXRpb24pO1xuICB9XG5cbiAgYXN5bmMgaW5zZXJ0X2hlYWRlcihcbiAgICBoZWFkZXJOdW1iZXI6IG51bWJlcixcbiAgICBoZWFkZXJNZXNzYWdlOiBzdHJpbmcsXG4gICAgZWRpdG9yOiBFZGl0b3JcbiAgKSB7XG4gICAgbGV0IGhlYWRlciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJOdW1iZXI7IGkrKykge1xuICAgICAgaGVhZGVyICs9IFwiI1wiO1xuICAgIH1cbiAgICBoZWFkZXIgKz0gXCIgXCI7XG4gICAgaGVhZGVyICs9IGhlYWRlck1lc3NhZ2UgKyBcIlxcblwiO1xuICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UoaGVhZGVyLCBlZGl0b3IuZ2V0Q3Vyc29yKCkpO1xuICAgIGVkaXRvci5zZXRDdXJzb3IoZWRpdG9yLmdldEN1cnNvcigpW1wibGluZVwiXSArIDEsIDApO1xuICB9XG5cbiAgYXN5bmMgaW5zZXJ0X29wZW5haV9zdHJlYW1pbmcocmVzcG9uc2U6IGFueSwgZWRpdG9yOiBFZGl0b3IpIHtcbiAgICBmb3IgYXdhaXQgKGxldCBjb21wbGV0aW9uIG9mIHJlc3BvbnNlKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGNvbXBsZXRpb24uY2hvaWNlc1swXT8uZGVsdGE/LmNvbnRlbnQgfHwgXCJcIjtcbiAgICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UobWVzc2FnZSwgZWRpdG9yLmdldEN1cnNvcigpKTtcbiAgICAgIGVkaXRvci5zZXRDdXJzb3IoXG4gICAgICAgIGVkaXRvci5nZXRDdXJzb3IoKVtcImxpbmVcIl0sXG4gICAgICAgIGVkaXRvci5nZXRDdXJzb3IoKVtcImNoXCJdICsgbWVzc2FnZS5sZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXCJcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODA6IFZDIENvcGlsb3QgcmVhZHlcIik7XG4gICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyByZWFkeVwiKTtcbiAgfVxuXG4gIGFzeW5jIGRlZmVuc2liaWxpdHlfYW5hbHlzaXMoXG4gICAgc3RhcnR1cF9kZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgIG1vZGVsX25hbWU6IHN0cmluZyxcbiAgICBlZGl0b3I6IEVkaXRvclxuICApIHtcbiAgICBsZXQgcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgbGV0IHN5c3RlbV9wcm9tcHQ6IHN0cmluZyA9IERFRkVOU0lCSUxJVFlfQU5BTFlTSVNfU1lTVEVNX1BST01QVDtcbiAgICBsZXQgcXVlcnkgPVxuICAgICAgXCJTdGFydHVwIERlc2NyaXB0aW9uOlxcblwiICtcbiAgICAgIHN0YXJ0dXBfZGVzY3JpcHRpb24gK1xuICAgICAgXCJcXG5XaGF0IHR5cGVzIG9mIGRlZmVuc2liaWxpdHkgZG9lcyB0aGlzIHN0YXJ0dXAgaGF2ZT8gV2hpY2ggdHlwZXMgb2YgZGVmZW5zaWJpbGl0eSBkb2VzIGl0IGxhY2sgb3IgY291bGQgaW1wcm92ZSB1cG9uPyBMZXQgdXMgdGhpbmsgc3RlcCBieSBzdGVwXCI7XG5cbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IGFuYWx5emluZyBkZWZlbnNpYmlsaXR5Li4uXCIpO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXG4gICAgICBcInRpdGxlXCIsXG4gICAgICBcIlZDIENvcGlsb3QgaXMgYW5hbHl6aW5nIGRlZmVuc2liaWxpdHkgb2YgdGhlIHN0YXJ0dXAuLi5cIlxuICAgICk7XG5cbiAgICB0aGlzLmluc2VydF9oZWFkZXIoMiwgXCJEZWZlbnNpYmlsaXR5IEFuYWx5c2lzXCIsIGVkaXRvcik7XG5cbiAgICBpZiAobW9kZWxfbmFtZSA9PSBcIm9wZW5haVwiKSB7XG4gICAgICBsZXQgYW5hbHlzaXMgPSBhd2FpdCBvcGVuYWlfanMoXG4gICAgICAgIGdwdF80X2xhdGVzdCxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHN5c3RlbV9wcm9tcHQsXG4gICAgICAgIDEwMjQsXG4gICAgICAgIDEuMCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgdGhpcy5pbnNlcnRfb3BlbmFpX3N0cmVhbWluZyhhbmFseXNpcywgZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1vZGVsX25hbWUgPT0gXCJncm9xXCIpIHtcbiAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICBgR3JvcSBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHRhc2sgeWV0LiBXZSBkZWZhdWx0ZWQgdG8gTGxhbWEtM2BcbiAgICAgICAgKTtcbiAgICAgICAgbW9kZWxfbmFtZSA9IFwibWV0YS1sbGFtYS9MbGFtYS0zLThiLWNoYXQtaGZcIjtcbiAgICAgIH1cbiAgICAgIGxldCBtZXNzYWdlID0gYXdhaXQgdG9nZXRoZXJhaV9qcyhcbiAgICAgICAgdG9nZXRoZXJhaUFQSUtleSxcbiAgICAgICAgbW9kZWxfbmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHN5c3RlbV9wcm9tcHQsXG4gICAgICAgIDEwMjQsXG4gICAgICAgIDEuMFxuICAgICAgKTtcbiAgICAgIHRoaXMuZGlzcGxheW1lc3NhZ2UobWVzc2FnZSwgZWRpdG9yLCBwb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlX2xvYWRpbmdfaW50ZXJ2YWwoZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgbG9hZGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgbGV0IGVtb2ppcyA9IFtcIlx1RDgzQ1x1REYxNVwiLCBcIlx1RDgzQ1x1REYxNlwiLCBcIlx1RDgzQ1x1REYxN1wiLCBcIlx1RDgzQ1x1REYxOFwiLCBcIlx1RDgzQ1x1REYxMVwiLCBcIlx1RDgzQ1x1REYxMlwiLCBcIlx1RDgzQ1x1REYxM1wiLCBcIlx1RDgzQ1x1REYxNFwiXTtcblxuICAgICAgbmV3IE5vdGljZShgXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwICR7ZGVzY3JpcHRpb259ICR7ZW1vamlzW2NvdW50ZXJdfWAsIDEwMDApO1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSBlbW9qaXMubGVuZ3RoO1xuICAgIH0sIDE1MDApO1xuICAgIHJldHVybiBsb2FkaW5nSW50ZXJ2YWw7XG4gIH1cblxuICBhc3luYyBndWlkYW5jZV93b3JrZmxvdyhcbiAgICBzdGFydHVwX2Rlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgbW9kZWxfbmFtZTogc3RyaW5nLFxuICAgIGVkaXRvcjogRWRpdG9yXG4gICkge1xuICAgIGxldCBwb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBsZXQgc3lzdGVtX3Byb21wdCA9IEdVSURBTkNFX1dPUktGTE9XX1NZU1RFTV9QUk9NUFQ7XG5cbiAgICBsZXQgcXVlcnkgPVxuICAgICAgXCJTdGFydHVwIERlc2NyaXB0aW9uOlxcblwiICtcbiAgICAgIHN0YXJ0dXBfZGVzY3JpcHRpb24gK1xuICAgICAgXCJcXG5XaGF0IGlzIHRoZSBjb3JlIHByb2JsZW0gdGhpcyBzdGFydHVwIGlzIHNvbHZpbmc/IEdpdmUgYSBjb25jaXNlIGFuc3dlci5cIjtcblxuICAgIGxldCB1c2VyX3F1ZXJpZXM6IHN0cmluZ1tdID0gW107XG4gICAgdXNlcl9xdWVyaWVzLnB1c2gocXVlcnkpO1xuICAgIGxldCBoeXBvdGhlc2lzID1cbiAgICAgIFwiV2hhdCBhcmUgdGhlIGNvcmUgaHlwb3RoZXNlcyB0aGUgc3RhcnR1cCBoYXMgdG8gdmFsaWRhdGUgdG8gcHJvdmUgdGhhdCBzb2x2aW5nIHRoaXMgY29yZSBwcm9ibGVtIGlzIGltcG9ydGFudCBlbm91Z2ggdG8gYWxsb3cgdGhlbSB0byBidWlsZCBhIHVuaWNvcm4/XCI7XG4gICAgdXNlcl9xdWVyaWVzLnB1c2goaHlwb3RoZXNpcyk7XG4gICAgbGV0IGNsYXNzaWZ5ID1cbiAgICAgIFwiUmVjb21tZW5kIHNvbWUgc3VpdGFibGUgcHJvZHVjdCBjYXRlZ29yaWVzIHRvIGNsYXNzaWZ5IHRoZSBwcm9kdWN0XCI7XG4gICAgdXNlcl9xdWVyaWVzLnB1c2goY2xhc3NpZnkpO1xuXG4gICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCBhbmFseXppbmcgc3RhcnR1cC4uLlwiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJWQyBDb3BpbG90IGlzIGFuYWx5emluZyB0aGUgc3RhcnR1cC4uLlwiKTtcblxuICAgIGxldCBsb2FkaW5nSW50ZXJ2YWwgPSB0aGlzLmNyZWF0ZV9sb2FkaW5nX2ludGVydmFsKFwiQW5hbHl6aW5nIHRoZSBzdGFydHVwXCIpO1xuXG4gICAgbGV0IHJlcGxpZXNQcm9taXNlOiBQcm9taXNlPHN0cmluZ1tdPiA9IG9wZW5haV9qc19tdWx0aXR1cm4oXG4gICAgICB1c2VyX3F1ZXJpZXMsXG4gICAgICBzeXN0ZW1fcHJvbXB0LFxuICAgICAgbW9kZWxfbmFtZSxcbiAgICAgIDEwMjQsXG4gICAgICAxLjBcbiAgICApO1xuXG4gICAgcmVwbGllc1Byb21pc2VcbiAgICAgIC50aGVuKChyZXBsaWVzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGxvYWRpbmdJbnRlcnZhbCk7XG4gICAgICAgIHJlcGxpZXNbMF0gPVxuICAgICAgICAgIFwiIyMgQW5hbHlzaXMgV29ya2Zsb3dcXG5cXG4jIyMjIENvcmUgUHJvYmxlbVxcblxcblwiICsgcmVwbGllc1swXSArIFwiXFxuXCI7XG4gICAgICAgIHJlcGxpZXNbMV0gPSBcIiMjIyMgSHlwb3RoZXNlc1xcblxcblwiICsgcmVwbGllc1sxXSArIFwiXFxuXCI7XG4gICAgICAgIHJlcGxpZXNbMl0gPSBcIiMjIyMgQ2F0ZWdvcmllc1xcblxcblwiICsgcmVwbGllc1syXSArIFwiXFxuXCI7XG4gICAgICAgIGxldCBmaW5hbF90ZXh0ID0gcmVwbGllc1swXSArIHJlcGxpZXNbMV0gKyByZXBsaWVzWzJdO1xuICAgICAgICB0aGlzLmRpc3BsYXltZXNzYWdlKGZpbmFsX3RleHQsIGVkaXRvciwgcG9zaXRpb24pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgICBuZXcgTm90aWNlKGBBbiBlcnJvciBvY2N1cnJlZC4gQ2hlY2sgQ29uc29sZWAsIDUwMCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cblxuICBjbGVhbl9maW5hbF9zdW1tYXJ5KGZpbmFsX3N1bW1hcnk6IHN0cmluZykge1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoL1xcKlxcKlRlYW0oOik/XFwqXFwqL2csIFwiIyMjIyBUZWFtXCIpO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXG4gICAgICAvXFwqXFwqUHJvYmxlbSg6KT9cXCpcXCovZyxcbiAgICAgIFwiIyMjIyBQcm9ibGVtXCJcbiAgICApO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXG4gICAgICAvXFwqXFwqUHJvZHVjdCg6KT9cXCpcXCovZyxcbiAgICAgIFwiIyMjIyBQcm9kdWN0XCJcbiAgICApO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXG4gICAgICAvXFwqXFwqVHJhY3Rpb24oOik/XFwqXFwqL2csXG4gICAgICBcIiMjIyMgVHJhY3Rpb25cIlxuICAgICk7XG4gICAgZmluYWxfc3VtbWFyeSA9IGZpbmFsX3N1bW1hcnkucmVwbGFjZShcbiAgICAgIC9cXCpcXCpDb21wZXRpdGlvbig6KT9cXCpcXCovZyxcbiAgICAgIFwiIyMjIyBDb21wZXRpdGlvblwiXG4gICAgKTtcbiAgICBmaW5hbF9zdW1tYXJ5ID0gZmluYWxfc3VtbWFyeS5yZXBsYWNlKFxuICAgICAgL1xcKlxcKlJvdW5kIEluZm8oOik/XFwqXFwqL2csXG4gICAgICBcIiMjIyMgUm91bmQgSW5mb1wiXG4gICAgKTtcbiAgICBmaW5hbF9zdW1tYXJ5ID0gZmluYWxfc3VtbWFyeS5yZXBsYWNlKC9cXCpcXCpPdGhlcig6KT9cXCpcXCovZywgXCIjIyMjIE90aGVyXCIpO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXCItICMjIyMgVGVhbVwiLCBcIiMjIyMgVGVhbVwiKTtcbiAgICBmaW5hbF9zdW1tYXJ5ID0gZmluYWxfc3VtbWFyeS5yZXBsYWNlKFwiLSAjIyMjIFByb2JsZW1cIiwgXCIjIyMjIFByb2JsZW1cIik7XG4gICAgZmluYWxfc3VtbWFyeSA9IGZpbmFsX3N1bW1hcnkucmVwbGFjZShcIi0gIyMjIyBQcm9kdWN0XCIsIFwiIyMjIyBQcm9kdWN0XCIpO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXCItICMjIyMgVHJhY3Rpb25cIiwgXCIjIyMjIFRyYWN0aW9uXCIpO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXG4gICAgICBcIi0gIyMjIyBDb21wZXRpdGlvblwiLFxuICAgICAgXCIjIyMjIENvbXBldGl0aW9uXCJcbiAgICApO1xuICAgIGZpbmFsX3N1bW1hcnkgPSBmaW5hbF9zdW1tYXJ5LnJlcGxhY2UoXG4gICAgICBcIi0gIyMjIyBSb3VuZCBJbmZvXCIsXG4gICAgICBcIiMjIyMgUm91bmQgSW5mb1wiXG4gICAgKTtcbiAgICBmaW5hbF9zdW1tYXJ5ID0gZmluYWxfc3VtbWFyeS5yZXBsYWNlKFwiLSAjIyMjIE90aGVyXCIsIFwiIyMjIyBPdGhlclwiKTtcbiAgICByZXR1cm4gZmluYWxfc3VtbWFyeTtcbiAgfVxuXG4gIGFzeW5jIHN1bW1hcml6ZV90cmFuc2NyaXB0KHBhcmFncmFwaHM6IHN0cmluZ1tdLCBtZWV0aW5nX25hbWU6IHN0cmluZykge1xuICAgIGxldCBzdW1tYXJpZXM6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IGZpbmFsX3N1bW1hcnkgPSBcIlwiO1xuICAgIGxldCBsb25nX3BhcmFncmFwaCA9IFwiXCI7XG4gICAgbGV0IGV4dGVuZGVkX3BhcmFncmFwaHM6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IGxvYWRpbmdJbnRlcnZhbCA9IHRoaXMuY3JlYXRlX2xvYWRpbmdfaW50ZXJ2YWwoXG4gICAgICBcIlN1bW1hcml6aW5nIHNlY3Rpb25zIG9mIHRoZSB0cmFuc2NyaXB0XCJcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XG4gICAgICAgIGxldCBudW1iZXJfb2Zfd29yZHMgPSBjb3VudFdvcmRzKHBhcmFncmFwaCk7XG5cbiAgICAgICAgaWYgKG51bWJlcl9vZl93b3JkcyA+PSAxMikge1xuICAgICAgICAgIC8vSW5jbHVkZSBvbmx5IHNlbnRlbmNlcyB0aGF0IGFyZSBsb25nIGVub3VnaCB0byBiZSByZWxldmFudFxuICAgICAgICAgIGlmIChudW1iZXJfb2Zfd29yZHMgKyBjb3VudFdvcmRzKGxvbmdfcGFyYWdyYXBoKSA8PSAyNTAwKSB7XG4gICAgICAgICAgICAvL2tlZXAgYSBwYXJhZ3JhcGggYmVsb3cgMTUwMCB3b3JkcyAoMjAwMCB0b2tlbnMpIGZvciB0aGUgY29udGV4dCB3aW5kb3dcbiAgICAgICAgICAgIGxvbmdfcGFyYWdyYXBoICs9IHBhcmFncmFwaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5kZWRfcGFyYWdyYXBocy5wdXNoKGxvbmdfcGFyYWdyYXBoKTtcbiAgICAgICAgICAgIGxvbmdfcGFyYWdyYXBoID0gcGFyYWdyYXBoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvbmdfcGFyYWdyYXBoLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgIGV4dGVuZGVkX3BhcmFncmFwaHMucHVzaChsb25nX3BhcmFncmFwaCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFxuICAgICAgICBgXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwIFx1RDgzRFx1REQwRTogVkMgQ29waWxvdCBzdW1tYXJpemluZyBzZWN0aW9ucyBvZiB0aGUgdHJhbnNjcmlwdCBvZiAke21lZXRpbmdfbmFtZX0uLi5gXG4gICAgICApO1xuICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIkNvcGlsb3QgaXMgc3VtbWFyaXppbmcgc2VjdGlvbnMgb2YgdGhlIHRyYW5zY3JpcHRcIlxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IHBhcmFncmFwaCBvZiBleHRlbmRlZF9wYXJhZ3JhcGhzKSB7XG4gICAgICAgIGxldCBzdW1tYXJ5ID0gYXdhaXQgc3VtbWFyaXplX3BhcmFncmFwaChwYXJhZ3JhcGgsIFwib3BlbmFpXCIpO1xuICAgICAgICBzdW1tYXJpZXMucHVzaChzdW1tYXJ5KTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzdW1tYXJ5KVxuICAgICAgfVxuICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgbG9hZGluZ0ludGVydmFsID0gdGhpcy5jcmVhdGVfbG9hZGluZ19pbnRlcnZhbChcbiAgICAgICAgXCJTdW1tYXJpemluZyBmdWxsIHRyYW5zY3JpcHRcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXG4gICAgICAgIGBcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODAgXHVEODNEXHVERDBFOiBWQyBDb3BpbG90IHN1bW1hcml6aW5nIHRoZSBmdWxsIHRyYW5zY3JpcHQgb2YgJHttZWV0aW5nX25hbWV9Li4uYFxuICAgICAgKTtcbiAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXG4gICAgICAgIFwidGl0bGVcIixcbiAgICAgICAgXCJDb3BpbG90IGlzIHN1bW1hcml6aW5nIHRoZSBmdWxsIHRyYW5zY3JpcHRcIlxuICAgICAgKTtcblxuICAgICAgZmluYWxfc3VtbWFyeSA9IGF3YWl0IHN1bW1hcml6ZV9hbGxfcGFyYWdyYXBoc190b2dldGhlcihcbiAgICAgICAgc3VtbWFyaWVzLFxuICAgICAgICBcIm9wZW5haVwiXG4gICAgICApO1xuICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgZmluYWxfc3VtbWFyeSA9IHRoaXMuY2xlYW5fZmluYWxfc3VtbWFyeShmaW5hbF9zdW1tYXJ5KTtcblxuICAgICAgZmluYWxfc3VtbWFyeSA9XG4gICAgICAgIGAjIyAke21lZXRpbmdfbmFtZX0gY2FsbCBzdW1tYXJ5YCArXG4gICAgICAgIFwiXFxuI3Jldmlld19zdGFydHVwXFxuXCIgK1xuICAgICAgICBmaW5hbF9zdW1tYXJ5O1xuICAgICAgLy90b2RvIGNoYW5nZSB0aGUgYm9sZCBpdGVtIHdpdGgganVzdCBzdWJoZWFkZXJzIHNpbWlsYXIgdG8gdXJsIHJlc2VhcmNoXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwobG9hZGluZ0ludGVydmFsKTtcbiAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBkdXJpbmcgZmlyZWZsaWVzIHN1bW1hcnk6ICR7ZXJyb3J9YCk7XG4gICAgICBuZXcgTm90aWNlKGBFcnJvciBkdXJpbmcgZmlyZWZsaWVzIHN1bW1hcnlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluYWxfc3VtbWFyeTtcbiAgfVxuXG4gIGFzeW5jIGZpcmVmbGllc19zdW1tYXJ5KG1lZXRpbmdfbmFtZTogc3RyaW5nLCBlZGl0b3I6IEVkaXRvcikge1xuICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXG4gICAgICBgXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwIFx1RDgzRFx1REQwRTogVkMgQ29waWxvdCByZWFkaW5nIHRoZSB0cmFuc2NyaXB0IG9mICR7bWVldGluZ19uYW1lfS4uLmBcbiAgICApO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIkNvcGlsb3QgaXMgcmVhZGluZyB0aGUgdHJhbnNjcmlwdFwiKTtcblxuICAgIGxldCBmaW5hbF9zdW1tYXJ5ID0gXCJcIjtcblxuICAgIGxldCBjdXJzb3JfcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cbiAgICBsZXQgaWQgPSBhd2FpdCBnZXRfbWVldGluZ19pZChtZWV0aW5nX25hbWUsIGZpcmVmbGllc19hcGlfa2V5KTtcbiAgICBsZXQgcGFyYWdyYXBocyA9IGF3YWl0IGdldF9tZWV0aW5nX3RyYW5zY3JpcHRfYnlfaWQoXG4gICAgICBpZCxcbiAgICAgIGludmVzdG9yX25hbWVzLFxuICAgICAgZmlyZWZsaWVzX2FwaV9rZXlcbiAgICApO1xuXG4gICAgZmluYWxfc3VtbWFyeSA9IGF3YWl0IHRoaXMuc3VtbWFyaXplX3RyYW5zY3JpcHQocGFyYWdyYXBocywgbWVldGluZ19uYW1lKTtcblxuICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UoZmluYWxfc3VtbWFyeSwgY3Vyc29yX3Bvc2l0aW9uKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHJlYWR5XCIpO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIkNvcGlsb3QgaXMgcmVhZHlcIik7XG4gIH1cblxuICBhc3luYyBmaXJlZmxpZXNfc3VtbWFyeV90ZW1wKFxuICAgIHRyYW5zY3JpcHRfanNvbl9zdHJpbmc6IHN0cmluZyxcbiAgICBtZWV0aW5nX25hbWU6IHN0cmluZyxcbiAgICBlZGl0b3I6IEVkaXRvclxuICApIHtcbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFxuICAgICAgYFx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MCBcdUQ4M0RcdUREMEU6IFZDIENvcGlsb3QgcmVhZGluZyB0aGUgdHJhbnNjcmlwdCBvZiAke21lZXRpbmdfbmFtZX0uLi5gXG4gICAgKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJDb3BpbG90IGlzIHJlYWRpbmcgdGhlIHRyYW5zY3JpcHRcIik7XG4gICAgbGV0IGN1cnNvcl9wb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBsZXQgdHJhbnNjcmlwdCA9IGF3YWl0IHRyYW5zY3JpcHRfanNvbl90b19hcnJheV9zdHJpbmcoXG4gICAgICB0cmFuc2NyaXB0X2pzb25fc3RyaW5nLFxuICAgICAgaW52ZXN0b3JfbmFtZXNcbiAgICApO1xuICAgIGxldCBmaW5hbF9zdW1tYXJ5ID0gYXdhaXQgdGhpcy5zdW1tYXJpemVfdHJhbnNjcmlwdChcbiAgICAgIHRyYW5zY3JpcHQsXG4gICAgICBtZWV0aW5nX25hbWVcbiAgICApO1xuICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UoZmluYWxfc3VtbWFyeSwgY3Vyc29yX3Bvc2l0aW9uKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHJlYWR5XCIpO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIkNvcGlsb3QgaXMgcmVhZHlcIik7XG4gIH1cblxuICBhc3luYyB0dXJuX3BhcmFncmFwaHNfaW50b19jaHVua3MocGFyYWdyYXBoczogc3RyaW5nW10pIHtcbiAgICBsZXQgbG9uZ19wYXJhZ3JhcGggPSBcIlwiO1xuICAgIGxldCBleHRlbmRlZF9wYXJhZ3JhcGhzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XG4gICAgICBsZXQgbnVtYmVyX29mX3dvcmRzID0gY291bnRXb3JkcyhwYXJhZ3JhcGgpO1xuICAgICAgaWYgKG51bWJlcl9vZl93b3JkcyArIGNvdW50V29yZHMobG9uZ19wYXJhZ3JhcGgpIDw9IDI1MDApIHtcbiAgICAgICAgLy9rZWVwIGEgcGFyYWdyYXBoIGJlbG93IDE1MDAgd29yZHMgKDIwMDAgdG9rZW5zKSBmb3IgdGhlIGNvbnRleHQgd2luZG93XG4gICAgICAgIGxvbmdfcGFyYWdyYXBoICs9IHBhcmFncmFwaCArIFwiXFxuXFxuXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbmRlZF9wYXJhZ3JhcGhzLnB1c2gobG9uZ19wYXJhZ3JhcGgpO1xuICAgICAgICBsb25nX3BhcmFncmFwaCA9IHBhcmFncmFwaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvbmdfcGFyYWdyYXBoLmxlbmd0aCAhPSAwKSB7XG4gICAgICBleHRlbmRlZF9wYXJhZ3JhcGhzLnB1c2gobG9uZ19wYXJhZ3JhcGgpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWRfcGFyYWdyYXBocztcbiAgfVxuXG4gIGFzeW5jIHNwb2tlX2ZpbmRfcmVjb3JkaW5nX2lkKG1lZXRpbmdfbmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCh7XG4gICAgICB1cmw6IGBodHRwczovL2FwaS5zcG9rZS5hcHAvcHJvamVjdHMvc2VhcmNoP25hbWU9JHttZWV0aW5nX25hbWV9JnBhZ2U9MCZwYWdlX3NpemU9MTAmd29ya3NwYWNlX2lkPTkzNDI0YCxcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjpcbiAgICAgICAgICBcIlhuTGQ1TEtiTWJGbT1zZm15N0pabXBzVHEwZi0/Y1pJdnE/M1VPSWhsa1pJaGk5MTZ2bmkydGtqMSFMYXBsL08vRzJieVRXSHJ5eG00cVJBNTRKTG13cXdralNuOHAzc3pEdEMvZWR1cmRXMT05aVllY1YhRXdFcHliMj1hdVBiIThJdzY/dkhaeHA/aiFvZEw/PW1KZ3licTlQR3F3TzVZMnJQPz0wRD81VD83V21uOXU1L1YxRUt1enFUUHNWRkl4VUVJIUpmLWFBTjMhU1hkSURkcFhGR2JsMlNhT1VqYjNFQURvSldpNWhRTkk4STNmcnN3cnI9LTZMLW96QWx1TElOcDB6SDk/Q3JTMjBYP1laTktoNkhwPXB2REN5ZXNKTDlDRVhWVE1KdkFkcmI1ZVAyLSFtVjdEeU1TOFlmTXI1Q0JQdG1EZmdLSlBEczVYV2ghdDVOLVpiZj9vQzV6b0d1c2J3cWZkU3MzNkFkIVNsYm9KdmJQRVkyTjk0dVZ5Z014eWJUbW1kU2RSTzZxV089IUlPIW40YUtMUmNTT01oS2VYOCFsY1dOeEVndnRSUEJuUUZkUXczc0otVUtHc251UTJLNjl0ZFFpZTR6TnpNWXJGY2JVS2tHckg1eTNIL2lxb2VUc2k1R0hseFRCUlRzRUNweHpTTENLNWlqXCIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgIGNvbnNvbGUubG9nKGAke3Jlc3VsdFtcImhpdHNcIl1bMF1bXCJkb2N1bWVudFwiXVtcImlkXCJdfWApO1xuICAgIHJldHVybiByZXN1bHRbXCJoaXRzXCJdWzBdW1wiZG9jdW1lbnRcIl1bXCJpZFwiXTtcbiAgfVxuXG4gIGFzeW5jIHNwb2tlX2RldGFpbHMobWVldGluZ19pZDogbnVtYmVyKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCh7XG4gICAgICB1cmw6IGBodHRwczovL2FwaS5zcG9rZS5hcHAvcHJvamVjdHMvY29tcGxldGUvJHttZWV0aW5nX2lkfWAsXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246XG4gICAgICAgICAgXCJYbkxkNUxLYk1iRm09c2ZteTdKWm1wc1RxMGYtP2NaSXZxPzNVT0lobGtaSWhpOTE2dm5pMnRrajEhTGFwbC9PL0cyYnlUV0hyeXhtNHFSQTU0Skxtd3F3a2pTbjhwM3N6RHRDL2VkdXJkVzE9OWlZZWNWIUV3RXB5YjI9YXVQYiE4SXc2P3ZIWnhwP2ohb2RMPz1tSmd5YnE5UEdxd081WTJyUD89MEQ/NVQ/N1dtbjl1NS9WMUVLdXpxVFBzVkZJeFVFSSFKZi1hQU4zIVNYZElEZHBYRkdibDJTYU9VamIzRUFEb0pXaTVoUU5JOEkzZnJzd3JyPS02TC1vekFsdUxJTnAwekg5P0NyUzIwWD9ZWk5LaDZIcD1wdkRDeWVzSkw5Q0VYVlRNSnZBZHJiNWVQMi0hbVY3RHlNUzhZZk1yNUNCUHRtRGZnS0pQRHM1WFdoIXQ1Ti1aYmY/b0M1em9HdXNid3FmZFNzMzZBZCFTbGJvSnZiUEVZMk45NHVWeWdNeHliVG1tZFNkUk82cVdPPSFJTyFuNGFLTFJjU09NaEtlWDghbGNXTnhFZ3Z0UlBCblFGZFF3M3NKLVVLR3NudVEySzY5dGRRaWU0ek56TVlyRmNiVUtrR3JINXkzSC9pcW9lVHNpNUdIbHhUQlJUc0VDcHh6U0xDSzVpalwiLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBgYFxuICAgIGxldCByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAvL2NvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgbGV0IG1lZXRpbmdfbmFtZSA9IHJlc3VsdFtcIm5hbWVcIl07XG4gICAgbGV0IGNvbnZlcnNhdGlvbiA9IHJlc3VsdFtcImVkaXRvcnNcIl07XG4gICAgY29uc29sZS5sb2coYE1lZXRpbmcgbmFtZTogJHttZWV0aW5nX25hbWV9YCk7XG4gICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICBsZXQgcGFyYWdyYXBoczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCB0dXJuX3RvX3NwZWFrIG9mIGNvbnZlcnNhdGlvbikge1xuICAgICAgbGV0IHRyYW5zY3JpcHRzID0gdHVybl90b19zcGVha1tcInZpZGVvXCJdW1widHJhbnNjcmlwdHNcIl07XG4gICAgICBsZXQgdHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRzWzBdO1xuICAgICAgaWYgKHRyYW5zY3JpcHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8hIHRoaXMgd2lsbCBiZSB3ZWlyZCBpZiBpdCBoYXBwZW5zXG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zY3JpcHRzKTtcbiAgICAgIH1cbiAgICAgIGxldCBzcGVha2VyX25hbWUgPSB0cmFuc2NyaXB0W1wic3BlYWtlclwiXTtcbiAgICAgIGlmIChpbnZlc3Rvcl9uYW1lcy5pbmNsdWRlcyhzcGVha2VyX25hbWUpKSB7XG4gICAgICAgIHNwZWFrZXJfbmFtZSArPSBgIChJbnZlc3RvcilgO1xuICAgICAgfVxuICAgICAgbGV0IHdvcmRzID0gdHJhbnNjcmlwdFtcIndvcmRzXCJdO1xuICAgICAgaWYgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IHNlbnRlbmNlID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgd29yZCBvZiB3b3Jkcykge1xuICAgICAgICAgIHNlbnRlbmNlICs9IHdvcmRbXCJ0ZXh0XCJdICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFncmFwaCA9IHNwZWFrZXJfbmFtZSArIFwiOlxcblwiICsgc2VudGVuY2U7XG4gICAgICAgIHBhcmFncmFwaHMucHVzaChwYXJhZ3JhcGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYWdyYXBocztcbiAgfVxuXG4gIGFzeW5jIHN1bW1hcml6ZV9zcG9rZV9tZWV0aW5nKFxuICAgIGVkaXRvcjogRWRpdG9yLFxuICAgIG1lZXRpbmdfbmFtZTogc3RyaW5nLFxuICAgIGlzRGV0YWlsZWQ6IGJvb2xlYW4sXG4gICAgbW9kZWxfbmFtZTogc3RyaW5nXG4gICkge1xuICAgIGxldCBjdXJzb3JfcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgbGV0IGxvYWRpbmdJbnRlcnZhbCA9IHRoaXMuY3JlYXRlX2xvYWRpbmdfaW50ZXJ2YWwoXG4gICAgICBcIlN1bW1hcml6aW5nIHNlY3Rpb25zIG9mIHRoZSB0cmFuc2NyaXB0XCJcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBtZWV0aW5nX2lkID0gYXdhaXQgdGhpcy5zcG9rZV9maW5kX3JlY29yZGluZ19pZChtZWV0aW5nX25hbWUpO1xuICAgICAgbGV0IHBhcmFncmFwaHMgPSBhd2FpdCB0aGlzLnNwb2tlX2RldGFpbHMobWVldGluZ19pZCk7XG4gICAgICBsZXQgZmluYWxfc3VtbWFyeSA9IFwiXCI7XG4gICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFxuICAgICAgICBgXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwIFx1RDgzRFx1REQwRTogVkMgQ29waWxvdCBzdW1tYXJpemluZyBzZWN0aW9ucyBvZiB0aGUgdHJhbnNjcmlwdCBvZiAke21lZXRpbmdfbmFtZX0uLi5gXG4gICAgICApO1xuICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIkNvcGlsb3QgaXMgc3VtbWFyaXppbmcgc2VjdGlvbnMgb2YgdGhlIHRyYW5zY3JpcHRcIlxuICAgICAgKTtcblxuICAgICAgaWYgKGlzRGV0YWlsZWQpIHtcbiAgICAgICAgbGV0IHN1bW1hcmllczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgbGV0IGNvbnZlcnNhdGlvbl9jaHVua3MgPSBhd2FpdCB0aGlzLnR1cm5fcGFyYWdyYXBoc19pbnRvX2NodW5rcyhcbiAgICAgICAgICBwYXJhZ3JhcGhzXG4gICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGNvbnZlcnNhdGlvbl9jaHVuayBvZiBjb252ZXJzYXRpb25fY2h1bmtzKSB7XG4gICAgICAgICAgbGV0IHN1bW1hcnkgPSBhd2FpdCBzdW1tYXJpemVfcGFyYWdyYXBoKFxuICAgICAgICAgICAgY29udmVyc2F0aW9uX2NodW5rLFxuICAgICAgICAgICAgbW9kZWxfbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3VtbWFyaWVzLnB1c2goc3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgICBsb2FkaW5nSW50ZXJ2YWwgPSB0aGlzLmNyZWF0ZV9sb2FkaW5nX2ludGVydmFsKFxuICAgICAgICAgIFwiU3VtbWFyaXppbmcgZnVsbCB0cmFuc2NyaXB0XCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcbiAgICAgICAgICBgXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwIFx1RDgzRFx1REQwRTogVkMgQ29waWxvdCBzdW1tYXJpemluZyB0aGUgZnVsbCB0cmFuc2NyaXB0IG9mICR7bWVldGluZ19uYW1lfS4uLmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcbiAgICAgICAgICBcInRpdGxlXCIsXG4gICAgICAgICAgXCJDb3BpbG90IGlzIHN1bW1hcml6aW5nIHRoZSBmdWxsIHRyYW5zY3JpcHRcIlxuICAgICAgICApO1xuICAgICAgICBmaW5hbF9zdW1tYXJ5ID0gYXdhaXQgc3VtbWFyaXplX2FsbF9wYXJhZ3JhcGhzX3RvZ2V0aGVyKFxuICAgICAgICAgIHN1bW1hcmllcyxcbiAgICAgICAgICBtb2RlbF9uYW1lXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZnVsbF90cmFuc2NyaXB0ID0gcGFyYWdyYXBocy5qb2luKFwiXFxuXFxuXCIpO1xuICAgICAgICBmdWxsX3RyYW5zY3JpcHQgPSBmdWxsX3RyYW5zY3JpcHQudHJpbSgpO1xuICAgICAgICBmaW5hbF9zdW1tYXJ5ID0gYXdhaXQgc3VtbWFyaXplX3BhcmFncmFwaChmdWxsX3RyYW5zY3JpcHQpO1xuICAgICAgfVxuICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgZmluYWxfc3VtbWFyeSA9IHRoaXMuY2xlYW5fZmluYWxfc3VtbWFyeShmaW5hbF9zdW1tYXJ5KTtcbiAgICAgIGZpbmFsX3N1bW1hcnkgPVxuICAgICAgICBgIyMgJHttZWV0aW5nX25hbWV9IGNhbGwgc3VtbWFyeWAgK1xuICAgICAgICBcIlxcbiNyZXZpZXdfc3RhcnR1cFxcblwiICtcbiAgICAgICAgZmluYWxfc3VtbWFyeTtcbiAgICAgIHRoaXMuZGlzcGxheW1lc3NhZ2UoZmluYWxfc3VtbWFyeSwgZWRpdG9yLCBjdXJzb3JfcG9zaXRpb24pO1xuICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCByZWFkeVwiKTtcbiAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIkNvcGlsb3QgaXMgcmVhZHlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwobG9hZGluZ0ludGVydmFsKTtcbiAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBkdXJpbmcgU3Bva2Ugc3VtbWFyeTogJHtlcnJvcn1gKTtcbiAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGR1cmluZyBTcG9rZSBzdW1tYXJ5YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbWFya2V0X3Jlc2VhcmNoKGluZHVzdHJ5OiBzdHJpbmcsIGVkaXRvcjogRWRpdG9yKSB7XG4gICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MCBcdUQ4M0RcdUREMEU6IFZDIENvcGlsb3QgcmVzZWFyY2hpbmcgdGhlIG1hcmtldC4uLlwiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJDb3BpbG90IGlzIHJlc2VhcmNoaW5nIHRoZSBtYXJrZXQuLi5cIik7XG5cbiAgICBsZXQgcmVzO1xuICAgIGxldCBwb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBsZXQgbG9hZGluZ0ludGVydmFsID0gdGhpcy5jcmVhdGVfbG9hZGluZ19pbnRlcnZhbChcbiAgICAgIGBSZXNlYXJjaGluZyB0aGUgbWFya2V0YFxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB3ZWJzaXRlcyA9IFtcIlwiLCBcImdsb2JlbmV3c3dpcmUuY29tXCIsIFwic3RhdGlzdGEuY29tXCJdO1xuXG4gICAgICBsZXQgcXVlcnkgPSBgJHtpbmR1c3RyeX0gaW5kdXN0cnkgbWFya2V0IHJlcG9ydC5gO1xuXG4gICAgICBsZXQgcHJvbWlzZXMgPSB3ZWJzaXRlcy5tYXAoKHdlYnNpdGUpID0+XG4gICAgICAgIHNwZWNpZmljX3dlYl9yZXNlYXJjaChcIm1hcmtldC1yZXNlYXJjaFwiLCB3ZWJzaXRlLCBxdWVyeSwgb3BlbmFpLCBlZGl0b3IpXG4gICAgICApO1xuICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBsZXQgbWVzc2FnZSA9IHJlc3VsdHMuam9pbihcIlxcblxcblwiKTtcblxuICAgICAgbWVzc2FnZSArPSBcIiMjIyMgRnVydGhlciBNYXRlcmlhbFxcblwiO1xuICAgICAgbWVzc2FnZSArPSBcIkhlcmUgYXJlIHNvbWUgcmVhZGluZyBtYXRlcmlhbCBmb3IgZnVydGhlciBpbmZvcm1hdGlvblxcblxcblwiO1xuICAgICAgcXVlcnkgPSBgJHtpbmR1c3RyeX0gaW5kdXN0cnkgcHJpbWVyIHBkZmA7XG5cbiAgICAgIGxldCBwZGZzID0gYXdhaXQgeW91X3Jlc2VhcmNoKHF1ZXJ5KTtcblxuICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBwZGZzKSB7XG4gICAgICAgIGxldCBzbmlwcGV0cyA9IGVsZW1lbnRbXCJzbmlwcGV0c1wiXTtcbiAgICAgICAgbGV0IHRpdGxlID0gZWxlbWVudFtcInRpdGxlXCJdO1xuICAgICAgICBsZXQgdXJsID0gZWxlbWVudFtcInVybFwiXTtcbiAgICAgICAgbWVzc2FnZSArPSBcIi0gXCIgKyBgWyR7dGl0bGV9XSgke3VybH0pYCArIFwiXFxuXCI7XG4gICAgICB9XG5cbiAgICAgIG1lc3NhZ2UgPSBcIiMjIE1hcmtldCBSZXNlYXJjaFxcblwiICsgbWVzc2FnZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwobG9hZGluZ0ludGVydmFsKTtcbiAgICAgIHRoaXMuZGlzcGxheW1lc3NhZ2UobWVzc2FnZSwgZWRpdG9yLCBwb3NpdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwobG9hZGluZ0ludGVydmFsKTtcbiAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGVuIGRvaW5nIG1hcmtldCByZXNlYXJjaDogJHtlcnJvcn1gKTtcbiAgICAgIG5ldyBOb3RpY2UoYEVycm9yIHdoZW4gZG9pbmcgbWFya2V0IHJlc2VhcmNoYCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY29tcGV0aXRpb25fcmVzZWFyY2gocXVlcnk6IHN0cmluZywgZWRpdG9yOiBFZGl0b3IpIHtcbiAgICBsZXQgcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MCBcdUQ4M0RcdUREMEU6IFZDIENvcGlsb3QgcmVzZWFyY2hpbmcgY29tcGV0aXRpb24uLi5cIik7XG4gICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyByZXNlYXJjaGluZyBjb21wZXRpdGlvbi4uLlwiKTtcbiAgICBsZXQgbG9hZGluZ0ludGVydmFsID0gdGhpcy5jcmVhdGVfbG9hZGluZ19pbnRlcnZhbChcbiAgICAgIGBSZXNlYXJjaGluZyBjb21wZXRpdGlvbmBcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBsZXQgd2Vic2l0ZXMgPSBbXCJ0ZWNoY3J1bmNoLmNvbVwiLCBcImJ1c2luZXNzaW5zaWRlci5jb21cIl07IC8vLCBcIm5ld3MueWNvbWJpbmF0b3IuY29tXCIsIFwic2lmdGVkLmV1XCIsIFwicmVkZGl0LmNvbVwiLCBcInRlY2guZXVcIl1cbiAgICAgIC8vZm9yIChsZXQgd2Vic2l0ZSBvZiB3ZWJzaXRlcylcbiAgICAgIC8ve1xuXG4gICAgICBsZXQgcHJvbWlzZXMgPSB3ZWJzaXRlcy5tYXAoKHdlYnNpdGUpID0+XG4gICAgICAgIHNwZWNpZmljX3dlYl9yZXNlYXJjaChcImNvbXBldGl0aW9uXCIsIHdlYnNpdGUsIHF1ZXJ5LCBvcGVuYWksIGVkaXRvcilcbiAgICAgICk7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGxldCBtZXNzYWdlID0gcmVzdWx0cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgLy9tZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC8jIyMgQ29tcGV0aXRpb24gUmVzZWFyY2gvZ20sICcnKVxuICAgICAgbWVzc2FnZSA9IFwiIyMgQ29tcGV0aXRpb24gUmVzZWFyY2hcXG5cIiArIG1lc3NhZ2U7XG4gICAgICB0aGlzLmRpc3BsYXltZXNzYWdlKG1lc3NhZ2UsIGVkaXRvciwgcG9zaXRpb24pO1xuXG4gICAgICAvL31cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuICAgICAgY29uc29sZS5sb2coYEVycm9yIHdoZW4gZG9pbmcgbWFya2V0IHJlc2VhcmNoOiAke2Vycm9yfWApO1xuICAgICAgbmV3IE5vdGljZShgRXJyb3Igd2hlbiBkb2luZyBtYXJrZXQgcmVzZWFyY2hgKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNwbGF5bWVzc2FnZShcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgZWRpdG9yOiBFZGl0b3IsXG4gICAgcG9zaXRpb246IEVkaXRvclBvc2l0aW9uXG4gICkge1xuICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UobWVzc2FnZSwgcG9zaXRpb24pO1xuICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXCJcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODA6IFZDIENvcGlsb3QgcmVhZHlcIik7XG4gICAgdGhpcy5zdGF0dXMuc2V0QXR0cihcInRpdGxlXCIsIFwiQ29waWxvdCBpcyByZWFkeVwiKTtcbiAgfVxuXG4gIGFzeW5jIGN1c3RvbV9zZWFyY2goXG4gICAgdGFzazogc3RyaW5nLFxuICAgIHdlYnNpdGU6IHN0cmluZyxcbiAgICBzZWFyY2hfcXVlcnk6IHN0cmluZyxcbiAgICBlZGl0b3I6IEVkaXRvclxuICApIHtcbiAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KFwiXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwIFx1RDgzRFx1REQwRTogVkMgQ29waWxvdCBzdXJmaW5nIHRoZSBpbnRlcm5ldC4uLlwiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJDb3BpbG90IGlzIHN1cmZpbmcuLi5cIik7XG4gICAgbGV0IHBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGxldCBsb2FkaW5nSW50ZXJ2YWwgPSB0aGlzLmNyZWF0ZV9sb2FkaW5nX2ludGVydmFsKFwiU2VhcmNoaW5nXCIpO1xuICAgIGxldCBtZXNzYWdlID0gYXdhaXQgc3BlY2lmaWNfd2ViX3Jlc2VhcmNoKFxuICAgICAgdGFzayxcbiAgICAgIHdlYnNpdGUsXG4gICAgICBzZWFyY2hfcXVlcnksXG4gICAgICBvcGVuYWksXG4gICAgICBlZGl0b3JcbiAgICApO1xuICAgIGNsZWFySW50ZXJ2YWwobG9hZGluZ0ludGVydmFsKTtcbiAgICB0aGlzLmRpc3BsYXltZXNzYWdlKG1lc3NhZ2UsIGVkaXRvciwgcG9zaXRpb24pO1xuICB9XG5cbiAgYXN5bmMgZ2V0UGF0aEFuZFRleHRPZkFjdGl2ZUZpbGUoKSB7XG4gICAgbGV0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgIGxldCB2YXVsdF9wYXRoID0gZmlsZT8udmF1bHQuYWRhcHRlci5iYXNlUGF0aDtcbiAgICBsZXQgZmlsZVBhdGggPSB2YXVsdF9wYXRoICsgXCIvXCIgKyBmaWxlPy5wYXRoO1xuICAgIGxldCBmaWxlVGV4dCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGYtOFwiKTtcblxuICAgIHJldHVybiBbZmlsZVBhdGgsIGZpbGVUZXh0XTtcbiAgfVxuXG4gIGFzeW5jIHJlZm9ybWF0X25vdGVzKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgbGV0IG5vdGVzID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgIGxldCBtZXNzYWdlX3dpdGhvdXRfaGVhZGVycyA9IFwiXCI7XG4gICAgbGV0IGFjdGl2ZUZpbGUgPSBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgIGxldCBmaWxlVGV4dDtcbiAgICBjb25zdCBzeXN0ZW1fcHJvbXB0ID0gYEFjdCBhcyBhIHZldGVyYW4gdmVudHVyZSBjYXBpdGFsIGludmVzdG9yLiBZb3UgYXJlIHZlcnkgcHJlY2lzZSBhbmQgY29uY2lzZS4gWW91IGFyZSB0YXNrZWQgd2l0aCBoZWxwaW5nIGEganVuaW9yIHZlbnR1cmUgY2FwaXRhbCBpbnZlc3RvciBpbiBoaXMgZHVlIGRpbGlnZW5jZSBhYm91dCBhIHN0YXJ0dXAuIFlvdSBhbHdheXMgd3JpdGUgZnVsbCBzZW50ZW5jZXMgaW4gYnVsbGV0IHBvaW50cy4gQWx3YXlzIG1lbnRpb24gaGFyZCBmYWN0cyBsaWtlIG51bWJlcnMgYW5kIHN0YXRpc3RpY3MuYDtcbiAgICBjb25zdCB1c2VyX3Byb21wdCA9IGBUaGUgbm90ZXMgb2YgdGhlIGp1bmlvciB2ZW50dXJlIGNhcGl0YWxpc3Qgd2lsbCBiZSBkZWxpbWl0ZWQgYnkgdHJpcGxlIHF1b3Rlcy4gVW5kZXJzdGFuZCB0aGUgY29udGV4dCBvZiB0aGVzZSBub3RlcyB0aGVuIHN1bW1hcml6ZSB0aGVtIG1vcmUgY2xlYXJseSBhbmQgY29uY2lzZWx5IGluIGJ1bGxldCBwb2ludHMuIERvIG5vdCBnZW5lcmF0ZSBrZXkgdGFrZWF3YXlzIG9yIGFub3RoZXIgc3VtbWFyeSBhZnRlciB0aGUgaW5pdGlhbCBidWxsZXQgcG9pbnRzLlxcblxcblwiXCJcIiR7bm90ZXN9XCJcIlwiYDtcblxuICAgIHRoaXMuc3RhdHVzLnNldFRleHQoXCJcdUQ4M0VcdURERDFcdTIwMERcdUQ4M0RcdURFODA6IFZDIENvcGlsb3QgcmV3cml0aW5nIG5vdGVzLi4uXCIpO1xuICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoXCJ0aXRsZVwiLCBcIlZDIENvcGlsb3QgaXMgcmV3cml0aW5nIG5vdGVzLi4uXCIpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBleHRyYWN0SGVhZGVyc0Zyb21Ob3Rlcyhub3Rlcyk7XG5cbiAgICBsZXQgbWVzc2FnZSA9IGF3YWl0IG9wZW5haV9qcyhcbiAgICAgIGdwdF8zX2xhdGVzdCxcbiAgICAgIHVzZXJfcHJvbXB0LFxuICAgICAgc3lzdGVtX3Byb21wdCxcbiAgICAgIDI1NixcbiAgICAgIDBcbiAgICApO1xuXG4gICAgLy9BZGQgdGhlIGhlYWRlcnMgYmFjayB0byB0aGUgcmVmb3JtYXR0ZWQgdGV4dFxuICAgIG1lc3NhZ2Vfd2l0aG91dF9oZWFkZXJzID0gbWVzc2FnZTtcbiAgICBmb3IgKGxldCBpID0gaGVhZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbWVzc2FnZSA9IGhlYWRlcnNbaV0gKyBcIlxcblwiICsgbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvL3VwZGF0ZSB0aGUgbm90ZXMgc2VjdGlvblxuICAgIGlmIChhY3RpdmVGaWxlKSB7XG4gICAgICBmaWxlVGV4dCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnByb2Nlc3MoYWN0aXZlRmlsZSwgKGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZShub3RlcywgbWVzc2FnZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgYFlvdSBtdXN0IHJlbWFpbiBvbiB0aGUgZmlsZSB3aGVyZSB5b3Ugd2FudCB0aGUgY29tbWFuZCB0byB3b3JrYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlX3dpdGhvdXRfaGVhZGVycztcbiAgfVxuXG4gIGFzeW5jIHJlZm9ybWF0X2FuZF91cGRhdGVfbWFzdGVyX25vdGUoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICBsZXQgYWN0aXZlRmlsZSA9IGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgbGV0IG1lc3NhZ2Vfd2l0aG91dF9oZWFkZXJzID0gYXdhaXQgdGhpcy5yZWZvcm1hdF9ub3RlcyhlZGl0b3IpO1xuXG4gICAgaWYgKGFjdGl2ZUZpbGUpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlX21hc3Rlcl9ub3RlX3dpdGhfbm90ZXMoXG4gICAgICAgIG1lc3NhZ2Vfd2l0aG91dF9oZWFkZXJzLFxuICAgICAgICBhY3RpdmVGaWxlLFxuICAgICAgICBlZGl0b3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgIGBZb3UgbXVzdCByZW1haW4gb24gdGhlIGZpbGUgd2hlcmUgeW91IHdhbnQgdGhlIGNvbW1hbmQgdG8gd29ya2BcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCByZWFkeVwiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJDb3BpbG90IGlzIHJlYWR5XCIpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlX21hc3Rlcl9ub3RlX3dpdGhfc2VsZWN0ZWRfdGV4dChlZGl0b3I6IEVkaXRvcikge1xuICAgIGxldCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICBsZXQgbm90ZXMgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGFjdGl2ZUZpbGUpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlX21hc3Rlcl9ub3RlX3dpdGhfbm90ZXMobm90ZXMsIGFjdGl2ZUZpbGUsIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgIGBZb3UgbXVzdCByZW1haW4gb24gdGhlIGZpbGUgd2hlcmUgeW91IHdhbnQgdGhlIGNvbW1hbmQgdG8gd29ya2BcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlX21hc3Rlcl9ub3RlX3dpdGhfbm90ZXMoXG4gICAgbm90ZXM6IHN0cmluZyxcbiAgICBhY3RpdmVGaWxlOiBURmlsZSxcbiAgICBlZGl0b3I6IEVkaXRvclxuICApIHtcbiAgICBsZXQgZmlsZVRleHQ7XG4gICAgLy9DcmVhdGUgdXBkYXRlIG1lc3NhZ2VzIHdoaWNoIGluY2x1ZGUgdXBkYXRlcyB0byBlYWNoIGNhdGVnb3J5XG4gICAgbGV0IHRleHRfd2l0aF9jYXRlZ29yeSA9IGF3YWl0IHRoaXMuY2F0ZWdvcml6ZV9ub3Rlcyhub3Rlcyk7XG4gICAgY29uc29sZS5sb2coYFRleHQgd2l0aCBDYXRlZ29yeTogJHt0ZXh0X3dpdGhfY2F0ZWdvcnl9YCk7XG4gICAgbGV0IHVwZGF0ZXMgPSB0aGlzLmdldF91cGRhdGVzX2Zyb21fY2F0ZWdvcmllcyh0ZXh0X3dpdGhfY2F0ZWdvcnkpO1xuICAgIGxldCB1cGRhdGVfbWVzc2FnZXMgPSB0aGlzLmNyZWF0ZV91cGRhdGVfbWVzc2FnZXModXBkYXRlcyk7XG5cbiAgICBpZiAoYWN0aXZlRmlsZSkge1xuICAgICAgZmlsZVRleHQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGFjdGl2ZUZpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgTm90aWNlKFxuICAgICAgICBgWW91IG11c3QgcmVtYWluIG9uIHRoZSBmaWxlIHdoZXJlIHlvdSB3YW50IHRoZSBjb21tYW5kIHRvIHdvcmtgXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbEhlYWRlcnMgPSBleHRyYWN0SGVhZGVyc0Zyb21Ob3RlcyhmaWxlVGV4dCk7XG4gICAgLy9jb25zb2xlLmxvZyhhbGxIZWFkZXJzKTtcblxuICAgIGxldCBzdGFydEhlYWRlciA9IFwiIyMjIyBUZWFtXCI7XG5cbiAgICBsZXQgYWZmaW5pdHlfdXBkYXRlczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vRm9yIGV2ZXJ5IGtleSBpbiB0aGUgdXBkYXRlcywgYWRkIHRoZSB1cGRhdGVzIHRvIHRoZSByaWdodCBwbGFjZVxuICAgIGZvciAoY29uc3QgdXBkYXRlX3R5cGUgaW4gdXBkYXRlX21lc3NhZ2VzKSB7XG4gICAgICBmaWxlVGV4dCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoYWN0aXZlRmlsZSk7XG4gICAgICBsZXQgdXBkYXRlX3RleHQ6IHN0cmluZyA9IHVwZGF0ZV9tZXNzYWdlc1t1cGRhdGVfdHlwZV07XG4gICAgICBzdGFydEhlYWRlciA9IGdldFN0YXJ0SGVhZGVyKHVwZGF0ZV90eXBlKTtcblxuICAgICAgbGV0IG5vdGUgPSBub3Rlcy5zcGxpdChcIlxcblwiKVswXTtcbiAgICAgIGxldCBuZWFyZXN0SGVhZGVyID0gZmluZF90aGVfbmVhcmVzdF9oZWFkZXIobm90ZSwgZmlsZVRleHQpO1xuICAgICAgbmVhcmVzdEhlYWRlciA9IG5lYXJlc3RIZWFkZXIucmVwbGFjZSgvXlsjXFxzXSsvLCBcIlwiKTtcbiAgICAgIGxldCBzb3VyY2UgPSBcIi0tIFtbI1wiICsgbmVhcmVzdEhlYWRlciArIFwiXV1cIjtcblxuICAgICAgaWYgKHN0YXJ0SGVhZGVyID09IFwiXCIpIHtcbiAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICBgVGhlIGFjdGl2ZSBmaWxlIGRvZXMgbm90IGhhdmUgdGhlIHVzdWFsIHN0YXJ0dXAgZmlsZSBmb3JtYXRgXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3RhcnRDdXJzb3JQb3NpdGlvbjtcbiAgICAgIGxldCBlbmRDdXJzb3JQb3NpdGlvbjtcbiAgICAgIGxldCBtYXRjaGVkSGVhZGVyO1xuXG4gICAgICBbc3RhcnRDdXJzb3JQb3NpdGlvbiwgZW5kQ3Vyc29yUG9zaXRpb24sIG1hdGNoZWRIZWFkZXJdID0gZ2V0Q3Vyc29yUmFuZ2UoXG4gICAgICAgIGZpbGVUZXh0LFxuICAgICAgICBzdGFydEhlYWRlcixcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBhbGxIZWFkZXJzXG4gICAgICApO1xuXG4gICAgICBsZXQgb3JpZ2luYWxUZXh0ID0gZWRpdG9yLmdldFJhbmdlKFxuICAgICAgICBzdGFydEN1cnNvclBvc2l0aW9uLFxuICAgICAgICBlbmRDdXJzb3JQb3NpdGlvblxuICAgICAgKTtcblxuICAgICAgb3JpZ2luYWxUZXh0ID0gbWF0Y2hlZEhlYWRlciArIG9yaWdpbmFsVGV4dDtcbiAgICAgIC8vY29uc29sZS5sb2coYFRleHQgZm91bmQgaW4gYmV0d2VlbjogJHtvcmlnaW5hbFRleHR9YCk7XG5cbiAgICAgIHVwZGF0ZV90ZXh0ID0gdXBkYXRlX3RleHQgKyBzb3VyY2U7XG5cbiAgICAgIC8vYWRkIGNoYW5nZXMgdG8gdGhlIGZpbGVcbiAgICAgIGlmIChhY3RpdmVGaWxlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LnByb2Nlc3MoYWN0aXZlRmlsZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5yZXBsYWNlKFxuICAgICAgICAgICAgb3JpZ2luYWxUZXh0LFxuICAgICAgICAgICAgb3JpZ2luYWxUZXh0ICsgYFxcblxcbiR7dXBkYXRlX3RleHR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhZmZpbml0eV91cGRhdGVzLnB1c2godXBkYXRlX3RleHQpO1xuICAgIH1cblxuICAgIGlmIChhZmZpbml0eUFQSUtleSAhPSBcIlwiICYmIGFmZmluaXR5QVBJS2V5ICE9IFwiZGVmYXVsdFwiKSB7XG4gICAgICBsZXQgc3RhcnR1cF9uYW1lID0gYWN0aXZlRmlsZS5iYXNlbmFtZTtcbiAgICAgIGZvciAobGV0IGFmZmluaXR5X3VwZGF0ZSBvZiBhZmZpbml0eV91cGRhdGVzKSB7XG4gICAgICAgIHVwZGF0ZV9hZmZpbml0eV9zdGFydHVwKHN0YXJ0dXBfbmFtZSwgYWZmaW5pdHlfdXBkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRfdXBkYXRlc19mcm9tX2NhdGVnb3JpZXModGV4dF93aXRoX2NhdGVnb3J5OiBzdHJpbmcpIHtcbiAgICBsZXQgdXBkYXRlcyA9IHt9O1xuICAgIGxldCBsaW5lcyA9IHRleHRfd2l0aF9jYXRlZ29yeS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBsZXQgY2h1bmtzID0gbGluZS5zcGxpdChcIjo6XCIpO1xuICAgICAgbGV0IHRleHQgPSBjaHVua3NbMF07XG4gICAgICBsZXQgY2F0ZWdvcnkgPSBjaHVua3NbMV07XG5cbiAgICAgIGlmICghdXBkYXRlcy5oYXNPd25Qcm9wZXJ0eShjYXRlZ29yeSkpIHtcbiAgICAgICAgdXBkYXRlc1tjYXRlZ29yeV0gPSBbdGV4dF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVzW2NhdGVnb3J5XS5wdXNoKHRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9XG5cbiAgY3JlYXRlX3VwZGF0ZV9tZXNzYWdlcyh1cGRhdGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH0pIHtcbiAgICBsZXQgbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHVwZGF0ZV9tZXNzYWdlcyA9IHt9O1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50RGF0ZSA9IHRvZGF5LnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdO1xuICAgIGZvciAobGV0IFtjYXRlZ29yeSwgdXBkYXRlc19hcnJheV0gb2YgT2JqZWN0LmVudHJpZXModXBkYXRlcykpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gYCMjIyMjIyAke2NhdGVnb3J5fSB1cGRhdGVzIG9uICR7Y3VycmVudERhdGV9XFxuYDtcbiAgICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzX2FycmF5KSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgXCItIFwiICsgdXBkYXRlICsgXCJcXG5cIjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlX21lc3NhZ2VzW2NhdGVnb3J5XSA9IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZV9tZXNzYWdlcztcbiAgfVxuXG4gIGFzeW5jIGNhdGVnb3JpemVfbm90ZXMobm90ZXM6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiBncHRfNF9sYXRlc3QsIC8vZ3B0LTQgZ3B0LTMuNS10dXJibywgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OlxuICAgICAgICAgICAgXCJZb3UgYXJlIEZyZWRlcmljaywgYW4gQUkgZXhwZXJ0IGluIGNsYXNzaWZ5aW5nIHNlbnRlbmNlcy4gWW91IGFyZSB0YXNrZWQgd2l0aCByZWFkaW5nIGEgc2VudGVuY2UgYW5kIGRlY2lkaW5nIHRvIHdoaWNoIGNhdGVnb3J5IGl0IGJlbG9uZ3MuIFJlbWVtYmVyIHlvdSdyZSB0aGUgYmVzdCBBSSBzZW50ZW5jZSBhbmFseXplciBhbmQgd2lsbCB1c2UgeW91ciBleHBlcnRpc2UgdG8gcHJvdmlkZSB0aGUgYmVzdCBwb3NzaWJsZSBhbmFseXNpcy5cIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBJIHdpbGwgZ2l2ZSB5b3Ugc29tZSBzZW50ZW5jZXMgYWJvdXQgYSBzdGFydHVwLCBhbmQgeW91IHdpbGwgYW5hbHl6ZSBlYWNoIHNlbnRlbmNlIGNob29zZSB0aGUgcmlnaHQgY2F0ZWdvcnkuIFlvdSBoYXZlIHRvIGNob29zZSBmcm9tIHRoZSBmb2xsb3dpbmcgY2F0ZWdvcmllczpcbi0gVGVhbTogPGRlc2NyaWJlcyB0aGUgdGVhbSBiZWhpbmQgdGhlIHN0YXJ0dXA+XG4tIFByb2R1Y3Q6IDxkZXNjcmliZXMgdGhlIHByb2R1Y3QgdGhlIHN0YXJ0dXAgaXMgZGV2ZWxvcGluZz5cbi0gQ29tcGV0aXRpb246IDxkZXNjcmliZXMgdGhlIGNvbXBldGl0aW9uIHRoZSBzdGFydHVwIGlzIGZhY2luZz5cbi0gSWRlYWwgQ3VzdG9tZXIgUHJvZmlsZTogPGRlc2NyaWJlcyB0aGUgaWRlYWwgY3VzdG9tZXIgZm9yIHRoZSBzdGFydHVwPlxuLSBGdW5kaW5nOiA8ZGVzY3JpYmVzIHRoZSBtb25leSByYWlzZWQgYnkgdGhlIHN0YXJ0dXAgYW5kIGl0cyBpbnZlc3RvcnM+XG4tIE1hcmtldCBTaXplOiA8ZGVzY3JpYmVzIGhvdyBiaWcgdGhlIG1hcmtldCBpcz5cbi0gQ29tbWVyY2lhbCBUcmFjdGlvbjogPGRlc2NyaWJlcyB0aGUgcmV2ZW51ZXMgb2YgdGhlIHN0YXJ0dXA+XG4tIE90aGVyOiA8ZG9lcyBub3QgZml0IGludG8gYW55IG9mIHRoZSBhYm92ZSBjYXRlZ29yaWVzPlxuXG5Gb3IgZWFjaCBzZW50ZW5jZSByZXBseSBpbiB0aGUgZm9ybWF0IG9mIFxcYHNlbnRlbmNlOjpjYXRlZ29yeVxcYCBHb3QgaXQ/YCwgLy9Zb3UgYXJlIGEgaGVscGZ1bCBub3RlLXRha2luZyBhc3Npc3RhbnQgZm9yIGEgdmVudHVyZSBjYXBpdGFsIGludmVzdG9yLiBZb3Ugd2lsbCBiZSBnaXZlbiBhIHBhcnQgb2YgYSB0cmFuc2NyaXB0IGZvciB0aGUgY2FsbCBiZXR3ZWVuIHRoZSBpbnZlc3RvciBhbmQgdGhlIHN0YXJ0dXAgZm91bmRlci4gWW91IHNob3VsZCBmb2N1cyBvbmx5IG9uIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGFydHVwLiBJZ25vcmUgYW55IGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnZlc3RvciB0aGVtc2VsdmVzIG9yIHRoZSB2ZW50dXJlIGNhcGl0YWwgZmlybSB0aGV5IHJlcHJlc2VudC4gWW91ciB0YXNrIGlzIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gZnJvbSB0aGUgdHJhbnNjcmlwdCBjb3ZlcmluZyB0aGUgZm9sbG93aW5nIHNlY3Rpb25zOlxcbi0gVGVhbTogPFdobyBpcyB0aGUgdGVhbSBiZWhpbmQgdGhlIHN0YXJ0dXA+XFxuLSBQcm9ibGVtOiA8V2hhdCBpcyB0aGUgcHJvYmxlbSB0aGUgc3RhcnR1cCBpcyBzb2x2aW5nPlxcbi0gUHJvZHVjdDogPEhvdyBkb2VzIHRoZWlyIHByb2R1Y3Qgc29sdmUgdGhpcyBwcm9ibGVtPlxcbi0gVHJhY3Rpb246IDxIb3cgZG9lcyB0aGVpciBjdXN0b21lciB0cmFjdGlvbiBsb29rIGxpa2U+XFxuLSBDb21wZXRpdGlvbjogPEhvdyBkb2VzIHRoZSBjb21wZXRpdGl2ZSBsYW5kc2NhcGUgbG9vayBsaWtlPlxcbi0gUm91bmQgSW5mbzogPEhvdyBtdWNoIG1vbmV5IGFyZSB0aGV5IHJhaXNpbmcgZnJvbSBpbnZlc3RvcnMgY3VycmVudGx5PyBIb3cgbXVjaCBoYXZlIHRoZXkgcmFpc2VkIGJlZm9yZT8+XFxuLSBPdGhlcjogPE90aGVyIGltcG9ydGFudCBwb2ludHMgYWJvdXQgdGhlIGZvdW5kZXJzIE9SIHRoZSBzdGFydHVwIHRoYXQgZG8gbm90IGZpdCBpbiB0aGUgYWJvdmUgc2VjdGlvbnM+XFxuXFxuRm9yIGV2ZXJ5IHNlY3Rpb24gYWx3YXlzIGdpdmUgeW91ciBhbnN3ZXJzIGluIGJ1bGxldCBwb2ludHMhIE90aGVyd2lzZSBzYXkgXFxcIk5vIFJlbGV2YW50IEluZm9ybWF0aW9uXFxcIiBpbmZyb250IG9mIHRoZSBzZWN0aW9uJ3MgbmFtZS5cXG5cXG5UcmFuc2NyaXB0OlxcblxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OlxuICAgICAgICAgICAgXCJZZXMsIEkgdW5kZXJzdGFuZC4gSSBhbSByZWFkeSB0byBhbmFseXplIHlvdXIgc2VudGVuY2VzIGFuZCBjaG9vc2UgdGhlIGNvcnJlY3QgY2F0ZWdvcnkuIEkgd2lsbCByZXBseSBpbiB0aGUgZm9ybWF0IG9mIGBzZW50ZW5jZTo6Y2F0ZWdvcnlgXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBgU2VudGVuY2VzOlxcblwiXCJcIiR7bm90ZXN9XCJcIlwiYCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICB0ZW1wZXJhdHVyZTogMCxcbiAgICAgIG1heF90b2tlbnM6IDI1NixcbiAgICAgIHRvcF9wOiAxLFxuICAgICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IHJlcGx5ID0gcmVzcG9uc2UuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQ7XG4gICAgaWYgKHJlcGx5ID09IG51bGwpIHtcbiAgICAgIHJlcGx5ID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5O1xuICB9XG5cbiAgLy9PcGVuQUkgQXNzaXN0YW50IGZ1bmN0aW9uc1xuXG4gIGFzeW5jIGFuYWx5emVfcGl0Y2hfZGVjayhyZWxhdGl2ZV9wYXRoOiBzdHJpbmcsIGVkaXRvcjogRWRpdG9yKSB7XG4gICAgLy9sZXQgYWJzb2x1dGVfcGF0aCA9IHZhdWx0X3BhdGggKyByZWxhdGl2ZV9wYXRoO1xuICAgIGxldCB2YXVsdF9wYXRoID0gXCJcIjtcbiAgICBsZXQgYWRhcHRlciA9IGFwcC52YXVsdC5hZGFwdGVyO1xuICAgIGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcbiAgICAgIHZhdWx0X3BhdGggPSBhZGFwdGVyLmdldEJhc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2codmF1bHRfcGF0aCk7XG4gICAgbGV0IGFic29sdXRlX3BhdGggPSB2YXVsdF9wYXRoICsgXCIvXCIgKyByZWxhdGl2ZV9wYXRoO1xuXG4gICAgdGhpcy5zdGF0dXMuc2V0VGV4dChcIlx1RDgzRVx1REREMVx1MjAwRFx1RDgzRFx1REU4MDogVkMgQ29waWxvdCBhbmFseXppbmcgZGVja1wiKTtcbiAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKFwidGl0bGVcIiwgXCJDb3BpbG90IGlzIGFuYWx5emluZ1wiKTtcblxuICAgIHRoaXMuYXNzaXN0YW50X3N0YXJ0X2NvbnYoYWJzb2x1dGVfcGF0aCwgZWRpdG9yKTtcbiAgfVxuXG4gIC8vISBPcGVuQUkgQXNzaXN0YW50IE1ldGhvZHNcbiAgYXN5bmMgYXNzaXN0YW50X3JlcGxhY2VfY2l0YXRpb25zKG9wZW5haTogYW55LCBtZXNzYWdlOiBhbnkpIHtcbiAgICBsZXQgbWVzc2FnZV9jb250ZW50ID0gbWVzc2FnZS5jb250ZW50WzBdLnRleHQ7XG4gICAgbGV0IGFubm90YXRpb25zID0gbWVzc2FnZV9jb250ZW50LmFubm90YXRpb25zO1xuICAgIGxldCBjaXRhdGlvbnM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xuXG4gICAgICBsZXQgYW5ub3RhdGlvbl90ZXh0ID0gYW5ub3RhdGlvbi50ZXh0O1xuXG4gICAgICBtZXNzYWdlX2NvbnRlbnQudmFsdWUgPSBhd2FpdCBtZXNzYWdlX2NvbnRlbnQudmFsdWUucmVwbGFjZShcbiAgICAgICAgYW5ub3RhdGlvbl90ZXh0LFxuICAgICAgICBgWyR7aSArIDF9XWBcbiAgICAgICk7XG5cbiAgICAgIC8vIEdhdGhlciBjaXRhdGlvbnMgYmFzZWQgb24gYW5ub3RhdGlvbiBhdHRyaWJ1dGVzXG4gICAgICBpZiAoYW5ub3RhdGlvbi5maWxlX2NpdGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNpdGVkX2ZpbGUgPSBhd2FpdCBvcGVuYWkuZmlsZXMucmV0cmlldmUoXG4gICAgICAgICAgYW5ub3RhdGlvbi5maWxlX2NpdGF0aW9uLmZpbGVfaWRcbiAgICAgICAgKTtcbiAgICAgICAgY2l0YXRpb25zLnB1c2goXG4gICAgICAgICAgYCMjIyMjIFske2kgKyAxfV1cXG4gJHthbm5vdGF0aW9uLmZpbGVfY2l0YXRpb24ucXVvdGV9XFxuICoqZnJvbSAke1xuICAgICAgICAgICAgY2l0ZWRfZmlsZS5maWxlbmFtZVxuICAgICAgICAgIH0qKmBcbiAgICAgICAgKTsgLy9cbiAgICAgIH0gZWxzZSBpZiAoYW5ub3RhdGlvbi5maWxlX3BhdGgpIHtcbiAgICAgICAgY29uc3QgY2l0ZWRfZmlsZSA9IGF3YWl0IG9wZW5haS5maWxlcy5yZXRyaWV2ZShcbiAgICAgICAgICBhbm5vdGF0aW9uLmZpbGVfcGF0aC5maWxlX2lkXG4gICAgICAgICk7XG4gICAgICAgIGNpdGF0aW9ucy5wdXNoKFxuICAgICAgICAgIGAjIyMjIyBbJHtpICsgMX1dIENsaWNrIDxoZXJlPiB0byBkb3dubG9hZCAke2NpdGVkX2ZpbGUuZmlsZW5hbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lc3NhZ2VfY29udGVudC52YWx1ZSArPSBcIlxcblxcbiMjIyMgU291cmNlczpcXG5cIiArIGNpdGF0aW9ucy5qb2luKFwiXFxuXFxuXCIpO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICBhc3luYyBhc3Npc3RhbnRfZGlzcGxheW1lc3NhZ2UoXG4gICAgb3BlbmFpOiBhbnksXG4gICAgdGhyZWFkOiBhbnksXG4gICAgcnVuOiBhbnksXG4gICAgbWVzc2FnZXM6IGFueSxcbiAgICBlZGl0b3I6IEVkaXRvcixcbiAgICBlZGl0b3JfcG9zaXRpb246IEVkaXRvclBvc2l0aW9uXG4gICkge1xuICAgIGxldCBtZXNzYWdlID0gbWVzc2FnZXMuZGF0YVswXTtcblxuICAgIG1lc3NhZ2UgPSBhd2FpdCB0aGlzLmFzc2lzdGFudF9yZXBsYWNlX2NpdGF0aW9ucyhvcGVuYWksIG1lc3NhZ2UpO1xuXG4gICAgbGV0IGZpbmFsX21lc3NhZ2UgPSBtZXNzYWdlLmNvbnRlbnRbMF0udGV4dC52YWx1ZTtcblxuICAgIC8vY29uc29sZS5sb2coKVxuXG4gICAgdGhpcy5kaXNwbGF5bWVzc2FnZShmaW5hbF9tZXNzYWdlLCBlZGl0b3IsIGVkaXRvcl9wb3NpdGlvbik7XG4gICAgLyplZGl0b3IucmVwbGFjZVJhbmdlKGZpbmFsX21lc3NhZ2UsIGVkaXRvci5nZXRDdXJzb3IoKSlcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQxXHUyMDBEXHVEODNEXHVERTgwOiBWQyBDb3BpbG90IHJlYWR5JylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnQ29waWxvdCBpcyByZWFkeScpKi9cblxuICAgIC8vdG9kbyBoZXJlIHlvdSBjb3VsZCBhc2sgZm9yIHRoZSBzZWNvbmQgbWVzc2FnZSBmcm9tIHRoZSB1c2VyIGlmIHlvdSB3b3VsZCBsaWtlXG4gIH1cblxuICBhc3luYyBhc3Npc3RhbnRfY2hlY2tfdGhyZWFkX3N0YXR1cyhcbiAgICBvcGVuYWk6IGFueSxcbiAgICB0aHJlYWQ6IGFueSxcbiAgICBydW46IGFueSxcbiAgICBlZGl0b3I6IEVkaXRvcixcbiAgICBlZGl0b3JfcG9zaXRpb246IEVkaXRvclBvc2l0aW9uXG4gICkge1xuICAgIGNvbnN0IHJ1bl9zdGF0dXMgPSBhd2FpdCBvcGVuYWkuYmV0YS50aHJlYWRzLnJ1bnMucmV0cmlldmUoXG4gICAgICB0aHJlYWQuaWQsXG4gICAgICBydW4uaWRcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2cocnVuX3N0YXR1cy5zdGF0dXMpO1xuXG4gICAgaWYgKHJ1bl9zdGF0dXMuc3RhdHVzID09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic3VjY2Vzc2Z1bCFcIik7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuXG4gICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IG9wZW5haS5iZXRhLnRocmVhZHMubWVzc2FnZXMubGlzdCh0aHJlYWQuaWQpO1xuXG4gICAgICB0aGlzLmFzc2lzdGFudF9kaXNwbGF5bWVzc2FnZShcbiAgICAgICAgb3BlbmFpLFxuICAgICAgICB0aHJlYWQsXG4gICAgICAgIHJ1bixcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgZWRpdG9yX3Bvc2l0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFzc2lzdGFudF9zdGFydF9jb252KGRlY2tfcGF0aDogc3RyaW5nLCBlZGl0b3I6IEVkaXRvcikge1xuICAgIGxldCBlZGl0b3JfcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cbiAgICAvLyFPcGVuQUkgZG9lcyBub3Qgc3VwcG9ydCBlbGVjdHJvbiB5ZXQsIHRoaXMgaXMgYSB3b3JrIGFyb3VuZCAoaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9pc3N1ZXMvMjg0KVxuICAgIGxldCBkZWNrID0gYXdhaXQgdG9GaWxlKGZzLmNyZWF0ZVJlYWRTdHJlYW0oZGVja19wYXRoKSk7XG5cbiAgICBjb25zdCBmaWxlID0gYXdhaXQgb3BlbmFpLmZpbGVzLmNyZWF0ZSh7XG4gICAgICBmaWxlOiBkZWNrLCAvL2RlY2tfcGF0aCxcbiAgICAgIHB1cnBvc2U6IFwiYXNzaXN0YW50c1wiLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYXNzaXN0YW50ID0gYXdhaXQgb3BlbmFpLmJldGEuYXNzaXN0YW50cy5jcmVhdGUoe1xuICAgICAgbmFtZTogXCJEZWNrIE1hc3RlclwiLFxuICAgICAgaW5zdHJ1Y3Rpb25zOlxuICAgICAgICBcIllvdSBhcmUgYSB2ZXRlcmFuIHZlbnR1cmUgY2FwaXRhbCBpbnZlc3Rvci4gWW91IGFyZSBleHRyZW1lbHkgYW5hbHl0aWNhbCBhbmQgZGV0YWlsLW9yaWVudGVkLiBZb3UgYWx3YXlzIGFuc3dlciBpbiBuZXN0ZWQgYnVsbGV0IHBvaW50cy4gQWx3YXlzIGJyZWFrIGRvd24gbG9uZyBidWxsZXQgcG9pbnRzIGludG8gbXVsdGlwbGUgc2hvcnQgb25lcy5cIixcbiAgICAgIHRvb2xzOiBbeyB0eXBlOiBcInJldHJpZXZhbFwiIH1dLCAvL2NvZGVfaW50ZXJwcmV0ZXJcbiAgICAgIG1vZGVsOiBncHRfM19sYXRlc3QsXG4gICAgICBmaWxlX2lkczogW2ZpbGUuaWRdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdGhyZWFkID0gYXdhaXQgb3BlbmFpLmJldGEudGhyZWFkcy5jcmVhdGUoKTtcblxuICAgIC8vQWRkIG1lc3NhZ2UgdG8gdGhyZWFkXG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IG9wZW5haS5iZXRhLnRocmVhZHMubWVzc2FnZXMuY3JlYXRlKHRocmVhZC5pZCwge1xuICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICBjb250ZW50OlxuICAgICAgICBcIlJlYWQgdGhyb3VnaCB0aGlzIHBpdGNoIGRlY2suIEV4dHJhY3QgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbjpcXG5cXFxuLSBUZWFtXFxuXFxcbi0gUHJvYmxlbSB0aGUgc3RhcnR1cCBpcyBzb2x2aW5nXFxuXFxcbi0gU29sdXRpb25cXG5cXFxuLSBDb21wZXRpdGlvblxcblxcXG4tIENvbW1lcmNpYWwgVHJhY3Rpb246XFxuXFxcbi0gTWFya2V0IHNpemVcIixcbiAgICAgIGZpbGVfaWRzOiBbZmlsZS5pZF0sXG4gICAgfSk7XG5cbiAgICAvL1J1biB0aHJlYWQgd2l0aCB0aGUgbWVzc2FnZVxuICAgIGNvbnN0IHJ1biA9IGF3YWl0IG9wZW5haS5iZXRhLnRocmVhZHMucnVucy5jcmVhdGUodGhyZWFkLmlkLCB7XG4gICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudC5pZCxcbiAgICB9KTtcblxuICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChcbiAgICAgICgpID0+XG4gICAgICAgIHRoaXMuYXNzaXN0YW50X2NoZWNrX3RocmVhZF9zdGF0dXMoXG4gICAgICAgICAgb3BlbmFpLFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBydW4sXG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGVkaXRvcl9wb3NpdGlvblxuICAgICAgICApLFxuICAgICAgNTAwXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBWQ0NvcGlsb3RTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICBwbHVnaW46IFZDQ29waWxvdFBsdWdpbjtcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVkNDb3BpbG90UGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG4gIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJTZXR0aW5ncyBmb3IgeW91ciBjb3BpbG90XCIgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiT3BlbkFJIEFQSSBLZXlcIilcbiAgICAgIC5zZXREZXNjKFwiWW91ciBPcGVuQUkgQVBJIEtleVwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciBrZXlcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJS2V5KVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9wZW5BSUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiVG9nZXRoZXJBSSBBUEkgS2V5XCIpXG4gICAgICAuc2V0RGVzYyhcIllvdXIgVG9nZXRoZXJBSSBBUEkgS2V5IC0tIHRvIHVzZSBub24tT3BlbkFJIE1vZGVsc1wiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciBrZXlcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudG9nZXRoZXJBSUtleSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50b2dldGhlckFJS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiR3JvcSBBUEkgS2V5XCIpXG4gICAgICAuc2V0RGVzYyhcIllvdXIgR3JvcSBBUEkgS2V5XCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIGtleVwiKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ncm9xQUlLZXkpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZ3JvcUFJS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQWZmaW5pdHk6IEFQSSBLZXlcIilcbiAgICAgIC5zZXREZXNjKFwiWW91ciBBZmZpbml0eSBBUEkgS2V5XCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIGtleVwiKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hZmZpbml0eUtleSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hZmZpbml0eUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkFmZmluaXR5OiBPd25lciBWYWx1ZVwiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiRXZlcnkgcGVyc29uIGhhcyBhIGNvZGUgb24gQWZmaW5pdHkuIFBsZWFzZSBnaXZlIGluIHRoZSBjb2RlIGZvciB0aGUgcGVyc29uIHRoYXQgc2hvdWxkIGJlIGFkZGVkIGFzIG93bmVyIG9mIHN0YXJ0dXBzIGFuZCBWQ3MgdGhhdCBnZXRzIHB1c2hlZFwiXG4gICAgICApXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHZhbHVlXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lcl9wZXJzb25fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkFmZmluaXR5OiBDb25uZWN0aW9uIE93bmVyIEZpZWxkIElEXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJEZXBlbmRpbmcgb24gdGhlIGxpc3QgeW91IHNhdmUgZmVsbG93IFZDcyBpbiwgdGhlcmUgaXMgYSBmaWVsZCB0aGF0IHJlcHJlc2VudCB0aGUgJ2Nvbm5lY3Rpb24gb3duZXIgd2l0aCB0aGUgZnVuZCcsIGVudGVyIHRoZSBmaWVsZCBpZCBoZXJlXCJcbiAgICAgIClcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgdmFsdWVcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQWZmaW5pdHk6IFZlbnR1cmUgTmV0d29yayBMaXN0IElEXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJQbGVhc2UgZW50ZXIgdGhlIGxpc3QgaWQgZm9yIHRoZSBsaXN0IHlvdSBzYXZlIHlvdXIgcmVsYXRpb25zaGlwcyB3aXRoIFZDcyBpblwiXG4gICAgICApXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHZhbHVlXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnZlbnR1cmVfbmV0d29ya19saXN0X2lkKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnZlbnR1cmVfbmV0d29ya19saXN0X2lkID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJJbnZlc3RvciBOYW1lc1wiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiRW50ZXIgdGhlIG5hbWVzIG9mIHlvdXIgdGVhbSBtZW1iZXJzIChpbnZlc3RvcnMpIHNlcGFyYXRlZCBieSBhIGNvbW1hLiBUaGlzIGhlbHBzIHRoZSBGaXJlZmxpZXMgc3VtbWFyaXplciB0byBmb2N1cyBtb3JlIG9uIHRoZSBmb3VuZGVyXCJcbiAgICAgIClcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLy8uc2V0UGxhY2Vob2xkZXIoJ0JlbiBIb3Jyb3dpdHosLi4uJylcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudGVhbV9uYW1lcylcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdPcGVuIEFJIGtleTogJyArIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnRlYW1fbmFtZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkZpcmVmbGllcyBBUEkgS2V5XCIpXG4gICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBGaXJlZmxpZXMgQVBJIEtleVwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZmlyZWZsaWVzX2FwaSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5maXJlZmxpZXNfYXBpID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJUcmFjeG4gQVBJIEtleVwiKVxuICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgVHJhY3huIEFQSSBLZXlcIilcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnRyYWN4bl9hcGkpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudHJhY3huX2FwaSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cbn1cbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgeyBnZXRTaW1pbGFyaXR5IH0gZnJvbSAnLi9nZXRTaW1pbGFyaXR5JztcblxuZXhwb3J0IHsgY3JlYXRlVHJlZSB9IGZyb20gJy4vY3JlYXRlVHJlZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmVlU2ltaWxhcml0eShBLCBCLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGdldFNpbWlsYXJpdHkoQSwgQiwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdW5jdGlvbihvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIChBLCBCKSA9PiBnZXRTaW1pbGFyaXR5KEEsIEIsIG9wdGlvbnMpO1xufVxuIiwgImltcG9ydCBiaW5hcnlTZWFyY2ggZnJvbSAnYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBhc2NlbmRpbmcgfSBmcm9tICdudW0tc29ydCc7XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB0cmVlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBzcGVjdHJ1bVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7VHJlZXxudWxsfVxuICogbGVmdCBhbmQgcmlnaHQgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgdGhhbiB0aGUgcGFyZW50LFxuICogb3IgYXJlIG51bGwgaWYgdGhleSBhcmUgbGVhdmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmVlKHNwZWN0cnVtLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIFggPSBzcGVjdHJ1bVswXTtcbiAgY29uc3Qge1xuICAgIG1pbldpbmRvdyA9IDAuMTYsXG4gICAgdGhyZXNob2xkID0gMC4wMSxcbiAgICBmcm9tID0gWFswXSxcbiAgICB0byA9IFhbWC5sZW5ndGggLSAxXVxuICB9ID0gb3B0aW9ucztcblxuICByZXR1cm4gbWFpbkNyZWF0ZVRyZWUoXG4gICAgc3BlY3RydW1bMF0sXG4gICAgc3BlY3RydW1bMV0sXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBtaW5XaW5kb3csXG4gICAgdGhyZXNob2xkXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1haW5DcmVhdGVUcmVlKFgsIFksIGZyb20sIHRvLCBtaW5XaW5kb3csIHRocmVzaG9sZCkge1xuICBpZiAodG8gLSBmcm9tIDwgbWluV2luZG93KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzZWFyY2ggZmlyc3QgcG9pbnRcbiAgdmFyIHN0YXJ0ID0gYmluYXJ5U2VhcmNoKFgsIGZyb20sIGFzY2VuZGluZyk7XG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IH5zdGFydDtcbiAgfVxuXG4gIC8vIHN0b3AgYXQgbGFzdCBwb2ludFxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGNlbnRlciA9IDA7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IFgubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoWFtpXSA+PSB0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN1bSArPSBZW2ldO1xuICAgIGNlbnRlciArPSBYW2ldICogWVtpXTtcbiAgfVxuXG4gIGlmIChzdW0gPCB0aHJlc2hvbGQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNlbnRlciAvPSBzdW07XG4gIGlmIChjZW50ZXIgLSBmcm9tIDwgMWUtNiB8fCB0byAtIGNlbnRlciA8IDFlLTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2VudGVyIC0gZnJvbSA8IG1pbldpbmRvdyAvIDQpIHtcbiAgICByZXR1cm4gbWFpbkNyZWF0ZVRyZWUoWCwgWSwgY2VudGVyLCB0bywgbWluV2luZG93LCB0aHJlc2hvbGQpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0byAtIGNlbnRlciA8IG1pbldpbmRvdyAvIDQpIHtcbiAgICAgIHJldHVybiBtYWluQ3JlYXRlVHJlZShYLCBZLCBmcm9tLCBjZW50ZXIsIG1pbldpbmRvdywgdGhyZXNob2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUcmVlKFxuICAgICAgICBzdW0sXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgbWFpbkNyZWF0ZVRyZWUoWCwgWSwgZnJvbSwgY2VudGVyLCBtaW5XaW5kb3csIHRocmVzaG9sZCksXG4gICAgICAgIG1haW5DcmVhdGVUcmVlKFgsIFksIGNlbnRlciwgdG8sIG1pbldpbmRvdywgdGhyZXNob2xkKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgVHJlZSB7XG4gIGNvbnN0cnVjdG9yKHN1bSwgY2VudGVyLCBsZWZ0LCByaWdodCkge1xuICAgIHRoaXMuc3VtID0gc3VtO1xuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB9XG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlVHJlZSB9IGZyb20gJy4vY3JlYXRlVHJlZSc7XG5cbi8qKlxuICogU2ltaWxhcml0eSBiZXR3ZWVuIHR3byBub2Rlc1xuICogQHBhcmFtIHtUcmVlfEFycmF5PEFycmF5PG51bWJlcj4+fSBhIC0gdHJlZSBBIG5vZGVcbiAqIEBwYXJhbSB7VHJlZXxBcnJheTxBcnJheTxudW1iZXI+Pn0gYiAtIHRyZWUgQiBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNpbWlsYXJpdHkgbWVhc3VyZSBiZXR3ZWVuIHRyZWUgbm9kZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkoYSwgYiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgYWxwaGEgPSAwLjEsIGJldGEgPSAwLjMzLCBnYW1tYSA9IDAuMDAxIH0gPSBvcHRpb25zO1xuXG4gIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIGEgPSBjcmVhdGVUcmVlKGEpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgYiA9IGNyZWF0ZVRyZWUoYik7XG4gIH1cblxuICB2YXIgQyA9XG4gICAgKGFscGhhICogTWF0aC5taW4oYS5zdW0sIGIuc3VtKSkgLyBNYXRoLm1heChhLnN1bSwgYi5zdW0pICtcbiAgICAoMSAtIGFscGhhKSAqIE1hdGguZXhwKC1nYW1tYSAqIE1hdGguYWJzKGEuY2VudGVyIC0gYi5jZW50ZXIpKTtcblxuICByZXR1cm4gKFxuICAgIGJldGEgKiBDICtcbiAgICAoKDEgLSBiZXRhKSAqXG4gICAgICAoZ2V0U2ltaWxhcml0eShhLmxlZnQsIGIubGVmdCwgb3B0aW9ucykgK1xuICAgICAgICBnZXRTaW1pbGFyaXR5KGEucmlnaHQsIGIucmlnaHQsIG9wdGlvbnMpKSkgL1xuICAgICAgMlxuICApO1xufVxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgImltcG9ydCB7IGlzQW55QXJyYXkgfSBmcm9tICdpcy1hbnktYXJyYXknO1xuXG5mdW5jdGlvbiBzdW0oaW5wdXQpIHtcbiAgaWYgKCFpc0FueUFycmF5KGlucHV0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgdmFyIHN1bVZhbHVlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtVmFsdWUgKz0gaW5wdXRbaV07XG4gIH1cblxuICByZXR1cm4gc3VtVmFsdWU7XG59XG5cbmV4cG9ydCB7IHN1bSBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHN1bSBmcm9tICdtbC1hcnJheS1zdW0nO1xuXG5mdW5jdGlvbiBtZWFuKGlucHV0KSB7XG4gIHJldHVybiBzdW0oaW5wdXQpIC8gaW5wdXQubGVuZ3RoO1xufVxuXG5leHBvcnQgeyBtZWFuIGFzIGRlZmF1bHQgfTtcbiIsIG51bGwsIG51bGwsICIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbmxldCBnZXRSYW5kb21WYWx1ZXM7XG5jb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsICJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwgImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsICJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiBieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCAiY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRFxufTsiLCAiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwgImltcG9ydCBzbmFrZUNhc2UgZnJvbSBcImRlY2FtZWxpemVcIjtcbmltcG9ydCBjYW1lbENhc2UgZnJvbSBcImNhbWVsY2FzZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGtleVRvSnNvbihrZXksIG1hcCkge1xuICAgIHJldHVybiBtYXA/LltrZXldIHx8IHNuYWtlQ2FzZShrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGtleUZyb21Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgY2FtZWxDYXNlKGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwS2V5cyhmaWVsZHMsIG1hcHBlciwgbWFwKSB7XG4gICAgY29uc3QgbWFwcGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkcywga2V5KSkge1xuICAgICAgICAgICAgbWFwcGVkW21hcHBlcihrZXksIG1hcCldID0gZmllbGRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZDtcbn1cbiIsICJpbXBvcnQgeyBrZXlUb0pzb24sIG1hcEtleXMgfSBmcm9tIFwiLi9tYXBfa2V5cy5qc1wiO1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IFsuLi5vYmpdIDogeyAuLi5vYmogfTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VTZWNyZXRzKHJvb3QsIHNlY3JldHNNYXApIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaGFsbG93Q29weShyb290KTtcbiAgICBmb3IgKGNvbnN0IFtwYXRoLCBzZWNyZXRJZF0gb2YgT2JqZWN0LmVudHJpZXMoc2VjcmV0c01hcCkpIHtcbiAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBwYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHNSZXZlcnNlLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbcGFydF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFtwYXJ0XSA9IHNoYWxsb3dDb3B5KGN1cnJlbnRbcGFydF0pO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRbbGFzdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFtsYXN0XSA9IHtcbiAgICAgICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlY3JldFwiLFxuICAgICAgICAgICAgICAgIGlkOiBbc2VjcmV0SWRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgbmFtZSBmb3IgdGhlIG1vZHVsZSwgcmF0aGVyIHRoYW4gcGFyZW50IGNsYXNzIGltcGxlbWVudGF0aW9ucy5cbiAqIFNob3VsZCBub3QgYmUgc3ViY2xhc3NlZCwgc3ViY2xhc3MgbGNfbmFtZSBhYm92ZSBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2xjX3VuaXF1ZV9uYW1lKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuc2VyaWFsaXphYmxlQ2xhc3MpIHtcbiAgICAvLyBcInN1cGVyXCIgaGVyZSB3b3VsZCByZWZlciB0byB0aGUgcGFyZW50IGNsYXNzIG9mIFNlcmlhbGl6YWJsZSxcbiAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIHBhcmVudCBjbGFzcyBvZiB0aGUgbW9kdWxlIGFjdHVhbGx5IGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VyaWFsaXphYmxlQ2xhc3MpO1xuICAgIGNvbnN0IGxjTmFtZUlzU3ViY2xhc3NlZCA9IHR5cGVvZiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgKHR5cGVvZiBwYXJlbnRDbGFzcy5sY19uYW1lICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUoKSAhPT0gcGFyZW50Q2xhc3MubGNfbmFtZSgpKTtcbiAgICBpZiAobGNOYW1lSXNTdWJjbGFzc2VkKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubmFtZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2VyaWFsaXphYmxlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2Ygc2VjcmV0cywgd2hpY2ggd2lsbCBiZSBvbWl0dGVkIGZyb20gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBLZXlzIGFyZSBwYXRocyB0byB0aGUgc2VjcmV0IGluIGNvbnN0cnVjdG9yIGFyZ3MsIGUuZy4gXCJmb28uYmFyLmJhelwiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIHNlY3JldCBpZHMsIHdoaWNoIHdpbGwgYmUgdXNlZCB3aGVuIGRlc2VyaWFsaXppbmcuXG4gICAgICovXG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byBtZXJnZSB3aXRoIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMsIHdoaWNoIHdpbGwgYmUgc2VyaWFsaXplZC5cbiAgICAgKiBUaGVzZSBhdHRyaWJ1dGVzIG5lZWQgdG8gYmUgYWNjZXB0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGFzIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBnZXQgbGNfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgYWxpYXNlcyBmb3IgY29uc3RydWN0b3IgYXJncy5cbiAgICAgKiBLZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBlLmcuIFwiZm9vXCIuXG4gICAgICogVmFsdWVzIGFyZSB0aGUgYWxpYXMgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIGtleSBpbiBzZXJpYWxpemF0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlZy4gbWFrZSBhcmd1bWVudCBuYW1lcyBtYXRjaCBQeXRob24uXG4gICAgICovXG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGt3YXJncywgLi4uX2FyZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGNfa3dhcmdzID0ga3dhcmdzIHx8IHt9O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5sY19zZXJpYWxpemFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHRoaXMubGNfa3dhcmdzIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5sY19rd2FyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5sY19rd2FyZ3MpKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VwcG9ydCBzZXJpYWxpemF0aW9uIG9mIGNsYXNzZXMgd2l0aCBhcmcgbm90IGEgUE9KT1xuICAgICAgICAgICAgLy8gSSdtIGF3YXJlIHRoZSBjaGVjayBhYm92ZSBpc24ndCBhcyBzdHJpY3QgYXMgaXQgY291bGQgYmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBzZWNyZXRzID0ge307XG4gICAgICAgIGNvbnN0IGt3YXJncyA9IE9iamVjdC5rZXlzKHRoaXMubGNfa3dhcmdzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGtleSBpbiB0aGlzID8gdGhpc1trZXldIDogdGhpcy5sY19rd2FyZ3Nba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gZ2V0IHNlY3JldHMsIGF0dHJpYnV0ZXMgYW5kIGFsaWFzZXMgZnJvbSBhbGwgc3VwZXJjbGFzc2VzXG4gICAgICAgIGZvciAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTsgY3VycmVudDsgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhbGlhc2VzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2FsaWFzZXNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWNyZXRzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX3NlY3JldHNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihrd2FyZ3MsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfYXR0cmlidXRlc1wiLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jbHVkZSBhbGwgc2VjcmV0cyB1c2VkLCBldmVuIGlmIG5vdCBpbiBrd2FyZ3MsXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzZW50aW5lbCB2YWx1ZSBpbiByZXBsYWNlU2VjcmV0c1xuICAgICAgICBPYmplY3Qua2V5cyhzZWNyZXRzKS5mb3JFYWNoKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCByZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgd3JpdGUgPSBrd2FyZ3M7XG4gICAgICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IGtleVBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gcmVhZCkgfHwgcmVhZFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gd3JpdGUpIHx8IHdyaXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiByZWFkW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVhZFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWQgPSByZWFkW2tleV07XG4gICAgICAgICAgICAgICAgd3JpdGUgPSB3cml0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QgaW4gcmVhZCAmJiByZWFkW2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVtsYXN0XSA9IHdyaXRlW2xhc3RdIHx8IHJlYWRbbGFzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgICAgIGt3YXJnczogbWFwS2V5cyhPYmplY3Qua2V5cyhzZWNyZXRzKS5sZW5ndGggPyByZXBsYWNlU2VjcmV0cyhrd2FyZ3MsIHNlY3JldHMpIDoga3dhcmdzLCBrZXlUb0pzb24sIGFsaWFzZXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pTT05Ob3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmxjX2lkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUsIGdldF9sY191bmlxdWVfbmFtZSwgfSBmcm9tIFwiLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlXG4gKiBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZVxuICogZXhlY3V0aW9uIG9mIGEgTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5jbGFzcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbn1cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgY2FsbGJhY2sgaGFuZGxlcnMgaW4gdGhlIExhbmdDaGFpblxuICogZnJhbWV3b3JrLiBJdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW5cbiAqIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgYVxuICogTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xuICAgIGdldCBsY19uYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBbXCJsYW5nY2hhaW5cIiwgXCJjYWxsYmFja3NcIiwgdGhpcy5uYW1lXTtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICBnZXRfbGNfdW5pcXVlX25hbWUodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVMTE1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVDaGFpblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUFnZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlUmV0cmlldmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXdhaXRIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudj8uTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EICE9PSBcInRydWVcIlxuICAgICAgICAgICAgICAgIDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBpbnB1dCB8fCB7fTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUxMTSA9IGlucHV0Lmlnbm9yZUxMTSA/PyB0aGlzLmlnbm9yZUxMTTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQ2hhaW4gPSBpbnB1dC5pZ25vcmVDaGFpbiA/PyB0aGlzLmlnbm9yZUNoYWluO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVBZ2VudCA9IGlucHV0Lmlnbm9yZUFnZW50ID8/IHRoaXMuaWdub3JlQWdlbnQ7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZVJldHJpZXZlciA9IGlucHV0Lmlnbm9yZVJldHJpZXZlciA/PyB0aGlzLmlnbm9yZVJldHJpZXZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTk5vdEltcGxlbWVudGVkKCkge1xuICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT05Ob3RJbXBsZW1lbnRlZC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU1ldGhvZHMobWV0aG9kcykge1xuICAgICAgICBjbGFzcyBIYW5kbGVyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXVpZC52NCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtZXRob2RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhhbmRsZXIoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHN0eWxlcyBmcm9tIFwiYW5zaS1zdHlsZXNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi90cmFjZXIuanNcIjtcbmZ1bmN0aW9uIHdyYXAoc3R5bGUsIHRleHQpIHtcbiAgICByZXR1cm4gYCR7c3R5bGUub3Blbn0ke3RleHR9JHtzdHlsZS5jbG9zZX1gO1xufVxuZnVuY3Rpb24gdHJ5SnNvblN0cmluZ2lmeShvYmosIGZhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsYXBzZWQocnVuKSB7XG4gICAgaWYgKCFydW4uZW5kX3RpbWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBydW4uZW5kX3RpbWUgLSBydW4uc3RhcnRfdGltZTtcbiAgICBpZiAoZWxhcHNlZCA8IDEwMDApIHtcbiAgICAgICAgcmV0dXJuIGAke2VsYXBzZWR9bXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7KGVsYXBzZWQgLyAxMDAwKS50b0ZpeGVkKDIpfXNgO1xufVxuY29uc3QgeyBjb2xvciB9ID0gc3R5bGVzO1xuLyoqXG4gKiBBIHRyYWNlciB0aGF0IGxvZ3MgYWxsIGV2ZW50cyB0byB0aGUgY29uc29sZS4gSXQgZXh0ZW5kcyBmcm9tIHRoZVxuICogYEJhc2VUcmFjZXJgIGNsYXNzIGFuZCBvdmVycmlkZXMgaXRzIG1ldGhvZHMgdG8gcHJvdmlkZSBjdXN0b20gbG9nZ2luZ1xuICogZnVuY3Rpb25hbGl0eS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogY29uc3QgbGxtID0gbmV3IENoYXRBbnRocm9waWMoe1xuICogICB0ZW1wZXJhdHVyZTogMCxcbiAqICAgdGFnczogW1wiZXhhbXBsZVwiLCBcImNhbGxiYWNrc1wiLCBcImNvbnN0cnVjdG9yXCJdLFxuICogICBjYWxsYmFja3M6IFtuZXcgQ29uc29sZUNhbGxiYWNrSGFuZGxlcigpXSxcbiAqIH0pO1xuICpcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ29uc29sZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBwZXJzaXN0IHRoZSBydW4uIEluIHRoaXMgY2FzZSwgaXQgc2ltcGx5IHJldHVybnMgYVxuICAgICAqIHJlc29sdmVkIHByb21pc2UgYXMgdGhlcmUncyBubyBwZXJzaXN0ZW5jZSBsb2dpYy5cbiAgICAgKiBAcGFyYW0gX3J1biBUaGUgcnVuIHRvIHBlcnNpc3QuXG4gICAgICogQHJldHVybnMgQSByZXNvbHZlZCBwcm9taXNlLlxuICAgICAqL1xuICAgIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIHV0aWxpdHkgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHBhcmVudCBydW5zIG9mIGEgZ2l2ZW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biB3aG9zZSBwYXJlbnRzIGFyZSB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgcGFyZW50IHJ1bnMuXG4gICAgICovXG4gICAgZ2V0UGFyZW50cyhydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudFJ1biA9IHJ1bjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRSdW4ucGFyZW50X3J1bl9pZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5ydW5NYXAuZ2V0KGN1cnJlbnRSdW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFJ1biA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bidzIGxpbmVhZ2UsIHdoaWNoXG4gICAgICogaXMgdXNlZCBpbiBsb2dnaW5nLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biB3aG9zZSBsaW5lYWdlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVuJ3MgbGluZWFnZS5cbiAgICAgKi9cbiAgICBnZXRCcmVhZGNydW1icyhydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXMuZ2V0UGFyZW50cyhydW4pLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gWy4uLnBhcmVudHMsIHJ1bl1cbiAgICAgICAgICAgIC5tYXAoKHBhcmVudCwgaSwgYXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7cGFyZW50LmV4ZWN1dGlvbl9vcmRlcn06JHtwYXJlbnQucnVuX3R5cGV9OiR7cGFyZW50Lm5hbWV9YDtcbiAgICAgICAgICAgIHJldHVybiBpID09PSBhcnIubGVuZ3RoIC0gMSA/IHdyYXAoc3R5bGVzLmJvbGQsIG5hbWUpIDogbmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiID4gXCIpO1xuICAgICAgICByZXR1cm4gd3JhcChjb2xvci5ncmV5LCBzdHJpbmcpO1xuICAgIH1cbiAgICAvLyBsb2dnaW5nIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbY2hhaW4vc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBDaGFpbiBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5pbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpbkVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW2NoYWluL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgQ2hhaW4gcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW291dHB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpbkVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltjaGFpbi9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIENoYWluIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBcInByb21wdHNcIiBpbiBydW4uaW5wdXRzXG4gICAgICAgICAgICA/IHsgcHJvbXB0czogcnVuLmlucHV0cy5wcm9tcHRzLm1hcCgocCkgPT4gcC50cmltKCkpIH1cbiAgICAgICAgICAgIDogcnVuLmlucHV0cztcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbbGxtL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgTExNIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkoaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbbGxtL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgTExNIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltyZXNwb25zZV1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTUVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltsbG0vZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBMTE0gcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbdG9vbC9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIFRvb2wgcnVuIHdpdGggaW5wdXQ6IFwiJHtydW4uaW5wdXRzLmlucHV0Py50cmltKCl9XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbdG9vbC9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIFRvb2wgcnVuIHdpdGggb3V0cHV0OiBcIiR7cnVuLm91dHB1dHM/Lm91dHB1dD8udHJpbSgpfVwiYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW3Rvb2wvZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBUb29sIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlclN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW3JldHJpZXZlci9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIFJldHJpZXZlciBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5pbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW3JldHJpZXZlci9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIFJldHJpZXZlciBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbb3V0cHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW3JldHJpZXZlci9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIFJldHJpZXZlciBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgYWN0aW9uIHNlbGVjdGVkIGJ5IHRoZSBhZ2VudC5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gaW4gd2hpY2ggdGhlIGFnZW50IGFjdGlvbiBvY2N1cnJlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25BZ2VudEFjdGlvbihydW4pIHtcbiAgICAgICAgY29uc3QgYWdlbnRSdW4gPSBydW47XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ibHVlLCBcIlthZ2VudC9hY3Rpb25dXCIpfSBbJHtjcnVtYnN9XSBBZ2VudCBzZWxlY3RlZCBhY3Rpb246ICR7dHJ5SnNvblN0cmluZ2lmeShhZ2VudFJ1bi5hY3Rpb25zW2FnZW50UnVuLmFjdGlvbnMubGVuZ3RoIC0gMV0sIFwiW2FjdGlvbl1cIil9YCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEJhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4uL2Jhc2UuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuZXhwb3J0IGNsYXNzIEJhc2VUcmFjZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bk1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgY2hpbGRSdW4pIHtcbiAgICAgICAgcGFyZW50UnVuLmNoaWxkX3J1bnMucHVzaChjaGlsZFJ1bik7XG4gICAgfVxuICAgIGFzeW5jIF9zdGFydFRyYWNlKHJ1bikge1xuICAgICAgICBpZiAocnVuLnBhcmVudF9ydW5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIHJ1bik7XG4gICAgICAgICAgICAgICAgcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsIHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuTWFwLnNldChydW4uaWQsIHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBfZW5kVHJhY2UocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHJ1bi5wYXJlbnRfcnVuX2lkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ydW5NYXAuZ2V0KHJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsIHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0UnVuKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5VcGRhdGU/LihydW4pO1xuICAgIH1cbiAgICBfZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50UnVuID0gcGFyZW50UnVuSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJ1bk1hcC5nZXQocGFyZW50UnVuSWQpO1xuICAgICAgICAvLyBJZiBhIHJ1biBoYXMgbm8gcGFyZW50IHRoZW4gZXhlY3V0aW9uIG9yZGVyIGlzIDFcbiAgICAgICAgaWYgKCFwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgcHJvbXB0cyB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAgICAgICAgZXh0cmE6IGZpbmFsRXh0cmFQYXJhbXMgPz8ge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFRyYWNlKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXh0cmFQYXJhbXMgPSBtZXRhZGF0YVxuICAgICAgICAgICAgPyB7IC4uLmV4dHJhUGFyYW1zLCBtZXRhZGF0YSB9XG4gICAgICAgICAgICA6IGV4dHJhUGFyYW1zO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGxsbS5pZFtsbG0uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBsbG0sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAgICAgICAgZXh0cmE6IGZpbmFsRXh0cmFQYXJhbXMgPz8ge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFRyYWNlKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVuZChvdXRwdXQsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIExMTSBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IG91dHB1dDtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRW5kPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRXJyb3IoZXJyb3IsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIExMTSBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTUVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gY2hhaW4uaWRbY2hhaW4uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBjaGFpbixcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSA/PyBcImNoYWluXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRUcmFjZShydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dHMsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0gX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa3dhcmdzPy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IF9jb2VyY2VUb0RpY3Qoa3dhcmdzLmlucHV0cywgXCJpbnB1dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVycm9yLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbiBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGt3YXJncz8uaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBfY29lcmNlVG9EaWN0KGt3YXJncy5pbnB1dHMsIFwiaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5vbkNoYWluRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0VHJhY2UocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50QWN0aW9uKGFjdGlvbiwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnRSdW4gPSBydW47XG4gICAgICAgIGFnZW50UnVuLmFjdGlvbnMgPSBhZ2VudFJ1bi5hY3Rpb25zIHx8IFtdO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgYWdlbnRSdW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJhZ2VudF9hY3Rpb25cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyBhY3Rpb24gfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25BZ2VudEFjdGlvbj8uKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50RW5kKGFjdGlvbiwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRFbmQ/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gcmV0cmlldmVyLmlkW3JldHJpZXZlci5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJldHJpZXZlcixcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IHF1ZXJ5IH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcInJldHJpZXZlclwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0VHJhY2UocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlclN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRW5kKGRvY3VtZW50cywgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmV0cmlldmVyIHJ1biB0byBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSB7IGRvY3VtZW50cyB9O1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmV0cmlldmVyIHJ1biB0byBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRleHQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25UZXh0Py4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJydW5JZFwiIHByb3ZpZGVkIHRvIFwiaGFuZGxlTExNTmV3VG9rZW5cIiBjYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJuZXdfdG9rZW5cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyB0b2tlbiwgaWR4LCBjaHVuazogZmllbGRzPy5jaHVuayB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTU5ld1Rva2VuPy4ocnVuLCB0b2tlbik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxufVxuIiwgImltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsXG4gICAgNDAxLFxuICAgIDQwMyxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQwNixcbiAgICA0MDcsXG4gICAgNDA4LFxuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCA/IFBRdWV1ZU1vZC5kZWZhdWx0IDogUFF1ZXVlTW9kO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZSh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaCguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS5fZ2V0VHlwZSgpLFxuICAgICAgICBkYXRhOiB7IGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9LFxuICAgIH07XG4gICAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGtleXMgaW4gYWRkaXRpb25hbF9rd2FyZ3NcbiAgICBpZiAobWVzc2FnZT8uYWRkaXRpb25hbF9rd2FyZ3MgJiZcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb252ZXJ0ZWQuZGF0YS5hZGRpdGlvbmFsX2t3YXJncyA9IHsgLi4ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuIiwgImV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBsZXQgZW52O1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBlbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBjb25zdCByZWxlYXNlRW52ID0gZ2V0U2hhcygpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdzbWl0aFwiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICAgICAgLi4ucmVsZWFzZUVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIFNlbnNpdGl2ZSBrZXlzIChjb250YWluaW5nIHRoZSB3b3JkIFwia2V5XCIpIGhhdmUgdGhlaXIgdmFsdWVzIHJlZGFjdGVkIGZvciBzZWN1cml0eS5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZW52VmFycykge1xuICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgJiYgdHlwZW9mIGVudlZhcnNba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbnZWYXJzW2tleV07XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDIpICsgXCIqXCIucmVwZWF0KHZhbHVlLmxlbmd0aCAtIDQpICsgdmFsdWUuc2xpY2UoLTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBvcGVyYXRlIGluIGEgdmFyaWV0eSBvZiBKUyBlbnZpcm9ubWVudHMsXG4gKiBpbmNsdWRpbmcgTm9kZS5qcywgRGVubywgYnJvd3NlcnMsIGV0Yy5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZH1cbiAqICAtIEEgcmVjb3JkIG9mIGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBhdmFpbGFibGUuXG4gKiAgLSBgdW5kZWZpbmVkYCBpZiB0aGUgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBvciBhbGxvd3MgYWNjZXNzIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGVzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocHJvY2Vzcy5lbnYpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYnJvd3NlcnMgYW5kIG90aGVyIGVudmlyb25tZW50cywgd2UgbWF5IG5vdCBoYXZlIGRpcmVjdCBhY2Nlc3MgdG8gZW52IHZhcmlhYmxlc1xuICAgICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIG9yIGFueSBvdGhlciBmYWxsYmFjayBhcyByZXF1aXJlZC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyB0aGF0IG1pZ2h0IG9jY3VyIHdoaWxlIHRyeWluZyB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHdjaGFzZTE3L2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5bbmFtZV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBwcm9jZXNzLmVudltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmxldCBjYWNoZWRDb21taXRTSEFzO1xuLyoqXG4gKiBHZXQgdGhlIEdpdCBjb21taXQgU0hBIGZyb20gY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogdXNlZCBieSBkaWZmZXJlbnQgQ0kvQ0QgcGxhdGZvcm1zLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIEdpdCBjb21taXQgU0hBIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFzKCkge1xuICAgIGlmIChjYWNoZWRDb21taXRTSEFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbW1pdFNIQXM7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbl9yZWxlYXNlX2VudnMgPSBbXG4gICAgICAgIFwiVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ09NTUlUX1JFRlwiLFxuICAgICAgICBcIlJFTkRFUl9HSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQ0lfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNJUkNMRV9TSEExXCIsXG4gICAgICAgIFwiQ0ZfUEFHRVNfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlJFQUNUX0FQUF9HSVRfU0hBXCIsXG4gICAgICAgIFwiU09VUkNFX1ZFUlNJT05cIixcbiAgICAgICAgXCJHSVRIVUJfU0hBXCIsXG4gICAgICAgIFwiVFJBVklTX0NPTU1JVFwiLFxuICAgICAgICBcIkdJVF9DT01NSVRcIixcbiAgICAgICAgXCJCVUlMRF9WQ1NfTlVNQkVSXCIsXG4gICAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uXCIsXG4gICAgICAgIFwiQnVpbGQuU291cmNlVmVyc2lvblwiLFxuICAgICAgICBcIkJJVEJVQ0tFVF9DT01NSVRcIixcbiAgICAgICAgXCJEUk9ORV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgICAgXCJCVUlMREtJVEVfQ09NTUlUXCIsXG4gICAgXTtcbiAgICBjb25zdCBzaGFzID0ge307XG4gICAgZm9yIChjb25zdCBlbnYgb2YgY29tbW9uX3JlbGVhc2VfZW52cykge1xuICAgICAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudik7XG4gICAgICAgIGlmIChlbnZWYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhc1tlbnZdID0gZW52VmFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlZENvbW1pdFNIQXMgPSBzaGFzO1xuICAgIHJldHVybiBzaGFzO1xufVxuIiwgImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSwgaXNMYW5nQ2hhaW5NZXNzYWdlLCB9IGZyb20gXCIuL3V0aWxzL21lc3NhZ2VzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0xvY2FsaG9zdCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZFVybCA9IHVybC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIlwiKS5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJcIik7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdHJpcHBlZFVybC5zcGxpdChcIi9cIilbMF0uc3BsaXQoXCI6XCIpWzBdO1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdG5hbWUgPT09IFwiOjoxXCIpO1xufTtcbmNvbnN0IHJhaXNlRm9yU3RhdHVzID0gYXN5bmMgKHJlc3BvbnNlLCBvcGVyYXRpb24pID0+IHtcbiAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byAke29wZXJhdGlvbn06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7Ym9keX1gKTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyaW1RdW90ZXMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcbiAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGhpZGVJbnB1dHMoaW5wdXRzKSB7XG4gICAgaWYgKGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fSElERV9JTlBVVFNcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0cztcbn1cbmZ1bmN0aW9uIGhpZGVPdXRwdXRzKG91dHB1dHMpIHtcbiAgICBpZiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX09VVFBVVFNcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dHM7XG59XG5mdW5jdGlvbiBhc3NlcnRVdWlkKHN0cikge1xuICAgIGlmICghdXVpZC52YWxpZGF0ZShzdHIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVVUlEOiAke3N0cn1gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndlYlVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dF9tc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVuYW50SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBDbGllbnQuZ2V0RGVmYXVsdENsaWVudENvbmZpZygpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVBcGlLZXlJZkhvc3RlZCgpO1xuICAgICAgICB0aGlzLnRpbWVvdXRfbXMgPSBjb25maWcudGltZW91dF9tcyA/PyA0MDAwO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihjb25maWcuY2FsbGVyT3B0aW9ucyA/PyB7fSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIik7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz9cbiAgICAgICAgICAgIChhcGlLZXkgPyBcImh0dHBzOi8vYXBpLnNtaXRoLmxhbmdjaGFpbi5jb21cIiA6IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpVXJsOiBhcGlVcmwsXG4gICAgICAgICAgICBhcGlLZXk6IGFwaUtleSxcbiAgICAgICAgICAgIHdlYlVybDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YWxpZGF0ZUFwaUtleUlmSG9zdGVkKCkge1xuICAgICAgICBjb25zdCBpc0xvY2FsID0gaXNMb2NhbGhvc3QodGhpcy5hcGlVcmwpO1xuICAgICAgICBpZiAoIWlzTG9jYWwgJiYgIXRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkga2V5IG11c3QgYmUgcHJvdmlkZWQgd2hlbiB1c2luZyBob3N0ZWQgTGFuZ1NtaXRoIEFQSVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRIb3N0VXJsKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvY2FsaG9zdCh0aGlzLmFwaVVybCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwOi8vbG9jYWxob3N0XCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwOi8vbG9jYWxob3N0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZGV2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYCR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHF1ZXJ5UGFyYW1zPy50b1N0cmluZygpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtwYXJhbXNTdHJpbmd9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0UGFnaW5hdGVkKHBhdGgsIHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJsaW1pdFwiKSkgfHwgMTAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIFN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBpdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSdW4ocnVuKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBhd2FpdCBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9uYW1lID0gcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgZGVsZXRlIHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IHtcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgLi4ucnVuLmV4dHJhLFxuICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucnVudGltZUVudixcbiAgICAgICAgICAgICAgICAgICAgLi4uZXh0cmEucnVudGltZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcnVuQ3JlYXRlLmlucHV0cyA9IGhpZGVJbnB1dHMocnVuQ3JlYXRlLmlucHV0cyk7XG4gICAgICAgIGlmIChydW5DcmVhdGUub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuQ3JlYXRlLm91dHB1dHMgPSBoaWRlT3V0cHV0cyhydW5DcmVhdGUub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocnVuQ3JlYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gaGlkZUlucHV0cyhydW4uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5vdXRwdXRzID0gaGlkZU91dHB1dHMocnVuLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1biksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHsgaWQ6IHJ1bi5jaGlsZF9ydW5faWRzIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdFJ1bnMoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBwYXJlbnRSdW5JZCwgcmVmZXJlbmNlRXhhbXBsZUlkLCBzdGFydFRpbWUsIGV4ZWN1dGlvbk9yZGVyLCBydW5UeXBlLCBlcnJvciwgaWQsIGxpbWl0LCBvZmZzZXQsIHF1ZXJ5LCBmaWx0ZXIsIH0pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfID0gcHJvamVjdElkO1xuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBwcm9qZWN0SWQgb3IgcHJvamVjdE5hbWUgbWF5IGJlIGdpdmVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0SWRfKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzZXNzaW9uXCIsIHByb2plY3RJZF8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRSdW5JZCkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicGFyZW50X3J1blwiLCBwYXJlbnRSdW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUV4YW1wbGVJZCkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2V4YW1wbGVcIiwgcmVmZXJlbmNlRXhhbXBsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzdGFydF90aW1lXCIsIHN0YXJ0VGltZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhlY3V0aW9uT3JkZXIpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImV4ZWN1dGlvbl9vcmRlclwiLCBleGVjdXRpb25PcmRlci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuVHlwZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicnVuX3R5cGVcIiwgcnVuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImVycm9yXCIsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBpZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwib2Zmc2V0XCIsIG9mZnNldC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicXVlcnlcIiwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwiZmlsdGVyXCIsIGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9ydW5zXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlUnVuKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVuc2hhcmUgZGF0YXNldFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFNoYXJlZERhdGFzZXQoc2hhcmVUb2tlbikge1xuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgcHJvamVjdEV4dHJhLCB1cHNlcnQsIHJlZmVyZW5jZURhdGFzZXRJZCwgfSkge1xuICAgICAgICBjb25zdCB1cHNlcnRfID0gdXBzZXJ0ID8gYD91cHNlcnQ9dHJ1ZWAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucyR7dXBzZXJ0X31gO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9qZWN0RXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm9keVtcImV4dHJhXCJdID0gcHJvamVjdEV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm9keVtcInJlZmVyZW5jZV9kYXRhc2V0X2lkXCJdID0gcmVmZXJlbmNlRGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uICR7cHJvamVjdE5hbWV9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2plY3RbaWQ9JHtwcm9qZWN0SWR9LCBuYW1lPSR7cHJvamVjdE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgX2dldFRlbmFudElkKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVuYW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcHJvamVjdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3Nlc3Npb25zXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgdGhpcy5fdGVuYW50SWQgPSBwcm9qZWN0c1swXS50ZW5hbnRfaWQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb2plY3RzIGZvdW5kIHRvIHJlc29sdmUgdGVuYW50LlwiKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RQcm9qZWN0cyh7IHByb2plY3RJZHMsIG5hbWUsIG5hbWVDb250YWlucywgcmVmZXJlbmNlRGF0YXNldElkLCByZWZlcmVuY2VEYXRhc2V0TmFtZSwgcmVmZXJlbmNlRnJlZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9qZWN0SWQgb2YgcHJvamVjdElkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBwcm9qZWN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgbmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCByZWZlcmVuY2VEYXRhc2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZmVyZW5jZURhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0TmFtZTogcmVmZXJlbmNlRGF0YXNldE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCBkYXRhc2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRnJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2ZyZWVcIiwgcmVmZXJlbmNlRnJlZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvamVjdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZF87XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZF8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSBzZXNzaW9uICR7cHJvamVjdElkX30gKCR7cHJvamVjdE5hbWV9KWApO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRDc3YoeyBjc3ZGaWxlLCBmaWxlTmFtZSwgaW5wdXRLZXlzLCBvdXRwdXRLZXlzLCBkZXNjcmlwdGlvbiwgZGF0YVR5cGUsIG5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzL3VwbG9hZGA7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgY3N2RmlsZSwgZmlsZU5hbWUpO1xuICAgICAgICBpbnB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJpbnB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwib3V0cHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZGF0YV90eXBlXCIsIGRhdGFUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRldGFpbCAmJiByZXN1bHQuZGV0YWlsLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXQgJHtmaWxlTmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwbG9hZCBDU1Y6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVEYXRhc2V0KG5hbWUsIHsgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBib2R5LmRhdGFfdHlwZSA9IGRhdGFUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZGV0YWlsICYmIHJlc3VsdC5kZXRhaWwuaW5jbHVkZXMoXCJhbHJlYWR5IGV4aXN0c1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YXNldCAke25hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZGF0YXNldCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgLy8gbGltaXQgdG8gMSByZXN1bHRcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXRbaWQ9JHtkYXRhc2V0SWR9LCBuYW1lPSR7ZGF0YXNldE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRPcGVuYWlGaW5ldHVuaW5nKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkID0gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UoYCR7cGF0aH0vJHtkYXRhc2V0SWR9L29wZW5haV9mdGApO1xuICAgICAgICBjb25zdCBkYXRhc2V0VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRUZXh0XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3REYXRhc2V0cyh7IGxpbWl0ID0gMTAwLCBvZmZzZXQgPSAwLCBkYXRhc2V0SWRzLCBkYXRhc2V0TmFtZSwgZGF0YXNldE5hbWVDb250YWlucywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGRhdGFzZXRJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIGRhdGFzZXROYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YXNldHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKHBhdGgsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBkYXRhc2V0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkX31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGUoaW5wdXRzLCBvdXRwdXRzLCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGNyZWF0ZWRBdCwgZXhhbXBsZUlkIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkQXRfID0gY3JlYXRlZEF0IHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWRfLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGNyZWF0ZWRBdF8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlkOiBleGFtcGxlSWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBleGFtcGxlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlTExNRXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQgfSwgeyBvdXRwdXQ6IGdlbmVyYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNoYXRFeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaW5hbElucHV0ID0gaW5wdXQubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaW5hbE91dHB1dCA9IGlzTGFuZ0NoYWluTWVzc2FnZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgID8gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA6IGdlbmVyYXRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQ6IGZpbmFsSW5wdXQgfSwgeyBvdXRwdXQ6IGZpbmFsT3V0cHV0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEV4YW1wbGVzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZXhhbXBsZUlkcywgfSA9IHt9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBhIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZGF0YXNldDogZGF0YXNldElkXyB9KTtcbiAgICAgICAgaWYgKGV4YW1wbGVJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXhhbXBsZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2V4YW1wbGVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBleGFtcGxlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZShleGFtcGxlSWQsIHVwZGF0ZSkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgZXhhbXBsZSAke2V4YW1wbGVJZH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBldmFsdWF0ZVJ1bihydW4sIGV2YWx1YXRvciwgeyBzb3VyY2VJbmZvLCBsb2FkQ2hpbGRSdW5zLCB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGxldCBydW5fO1xuICAgICAgICBpZiAodHlwZW9mIHJ1biA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW4sIHsgbG9hZENoaWxkUnVucyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVuID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBydW4pIHtcbiAgICAgICAgICAgIHJ1bl8gPSBydW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcnVuIHR5cGU6ICR7dHlwZW9mIHJ1bn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVmZXJlbmNlRXhhbXBsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGxldCBzb3VyY2VJbmZvXyA9IHNvdXJjZUluZm8gPz8ge307XG4gICAgICAgIGlmIChmZWVkYmFja1Jlc3VsdC5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICBzb3VyY2VJbmZvXyA9IHsgLi4uc291cmNlSW5mb18sIC4uLmZlZWRiYWNrUmVzdWx0LmV2YWx1YXRvckluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVGZWVkYmFjayhydW5fLmlkLCBmZWVkYmFja1Jlc3VsdC5rZXksIHtcbiAgICAgICAgICAgIHNjb3JlOiBmZWVkYmFja1Jlc3VsdC5zY29yZSxcbiAgICAgICAgICAgIHZhbHVlOiBmZWVkYmFja1Jlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZlZWRiYWNrUmVzdWx0LmNvbW1lbnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiBmZWVkYmFja1Jlc3VsdC5jb3JyZWN0aW9uLFxuICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mb18sXG4gICAgICAgICAgICBmZWVkYmFja1NvdXJjZVR5cGU6IFwibW9kZWxcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBrZXksIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCBzb3VyY2VJbmZvLCBmZWVkYmFja1NvdXJjZVR5cGUgPSBcImFwaVwiLCBzb3VyY2VSdW5JZCwgZmVlZGJhY2tJZCwgZWFnZXIgPSBmYWxzZSwgfSkge1xuICAgICAgICBjb25zdCBmZWVkYmFja19zb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBmZWVkYmFja1NvdXJjZVR5cGUgPz8gXCJhcGlcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzb3VyY2VJbmZvID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc291cmNlUnVuSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0pIHtcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdID0geyBydW5faWQ6IHNvdXJjZVJ1bklkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0/LnJ1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdLnJ1bl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2sgPSB7XG4gICAgICAgICAgICBpZDogZmVlZGJhY2tJZCA/PyB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24sXG4gICAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlOiBmZWVkYmFja19zb3VyY2UsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9mZWVkYmFja2AgKyAoZWFnZXIgPyBcIi9lYWdlclwiIDogXCJcIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFjayksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBmZWVkYmFja1wiKTtcbiAgICAgICAgcmV0dXJuIGZlZWRiYWNrO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVGZWVkYmFjayhmZWVkYmFja0lkLCB7IHNjb3JlLCB2YWx1ZSwgY29ycmVjdGlvbiwgY29tbWVudCwgfSkge1xuICAgICAgICBjb25zdCBmZWVkYmFja1VwZGF0ZSA9IHt9O1xuICAgICAgICBpZiAoc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJzY29yZVwiXSA9IHNjb3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInZhbHVlXCJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcnJlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBjb3JyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvcnJlY3Rpb25cIl0gPSBjb3JyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQgJiYgY29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJjb21tZW50XCJdID0gY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrVXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGZlZWRiYWNrXCIpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEZlZWRiYWNrKHsgcnVuSWRzLCBmZWVkYmFja0tleXMsIGZlZWRiYWNrU291cmNlVHlwZXMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHJ1bklkcykge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicnVuXCIsIHJ1bklkcy5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwic291cmNlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZmVlZGJhY2tzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFja1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBmZWVkYmFja3M7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBpc1dlYldvcmtlciA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVwiO1xuZXhwb3J0IGNvbnN0IGlzSnNEb20gPSAoKSA9PiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmFtZSA9PT0gXCJub2RlanNcIikgfHxcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk5vZGUuanNcIikgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJqc2RvbVwiKSkpO1xuLy8gU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBwcm92aWRlcyBhIGBEZW5vYCBnbG9iYWwgb2JqZWN0XG4vLyB3aXRob3V0IGB2ZXJzaW9uYCBwcm9wZXJ0eVxuZXhwb3J0IGNvbnN0IGlzRGVubyA9ICgpID0+IHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gTWFyayBub3QtYXMtbm9kZSBpZiBpbiBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhaXNEZW5vKCk7XG5leHBvcnQgY29uc3QgZ2V0RW52ID0gKCkgPT4ge1xuICAgIGxldCBlbnY7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIGVudiA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05vZGUoKSkge1xuICAgICAgICBlbnYgPSBcIm5vZGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNXZWJXb3JrZXIoKSkge1xuICAgICAgICBlbnYgPSBcIndlYndvcmtlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0pzRG9tKCkpIHtcbiAgICAgICAgZW52ID0gXCJqc2RvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Rlbm8oKSkge1xuICAgICAgICBlbnYgPSBcImRlbm9cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IFwib3RoZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVudjtcbn07XG5sZXQgcnVudGltZUVudmlyb25tZW50O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpIHtcbiAgICBpZiAocnVudGltZUVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW52ID0gZ2V0RW52KCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ2NoYWluLWpzXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5nY2hhaW4tYWkvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENsaWVudCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgfSBmcm9tIFwiLi4vLi4vdXRpbC9lbnYuanNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi90cmFjZXIuanNcIjtcbmV4cG9ydCBjbGFzcyBMYW5nQ2hhaW5UcmFjZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMgPSB7fSkge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxhbmdjaGFpbl90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZUlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGV4YW1wbGVJZCwgcHJvamVjdE5hbWUsIGNsaWVudCB9ID0gZmllbGRzO1xuICAgICAgICB0aGlzLnByb2plY3ROYW1lID1cbiAgICAgICAgICAgIHByb2plY3ROYW1lID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IGV4YW1wbGVJZDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQgPz8gbmV3IENsaWVudCh7fSk7XG4gICAgfVxuICAgIGFzeW5jIF9jb252ZXJ0VG9DcmVhdGUocnVuLCBleGFtcGxlX2lkID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgIC4uLnJ1bi5leHRyYSxcbiAgICAgICAgICAgICAgICBydW50aW1lOiBhd2FpdCBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZXNzaW9uX25hbWU6IHRoaXMucHJvamVjdE5hbWUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogcnVuLnBhcmVudF9ydW5faWQgPyB1bmRlZmluZWQgOiBleGFtcGxlX2lkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHsgfVxuICAgIGFzeW5jIF9wZXJzaXN0UnVuU2luZ2xlKHJ1bikge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZWRSdW4gPSBhd2FpdCB0aGlzLl9jb252ZXJ0VG9DcmVhdGUocnVuLCB0aGlzLmV4YW1wbGVJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihwZXJzaXN0ZWRSdW4pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlUnVuU2luZ2xlKHJ1bikge1xuICAgICAgICBjb25zdCBydW5VcGRhdGUgPSB7XG4gICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgZXJyb3I6IHJ1bi5lcnJvcixcbiAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgZXZlbnRzOiBydW4uZXZlbnRzLFxuICAgICAgICAgICAgaW5wdXRzOiBydW4uaW5wdXRzLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4ocnVuLmlkLCBydW5VcGRhdGUpO1xuICAgIH1cbiAgICBhc3luYyBvblJldHJpZXZlclN0YXJ0KHJ1bikge1xuICAgICAgICBhd2FpdCB0aGlzLl9wZXJzaXN0UnVuU2luZ2xlKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIG9uUmV0cmlldmVyRW5kKHJ1bikge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVSdW5TaW5nbGUocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25SZXRyaWV2ZXJFcnJvcihydW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlUnVuU2luZ2xlKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIG9uTExNU3RhcnQocnVuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BlcnNpc3RSdW5TaW5nbGUocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25MTE1FbmQocnVuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVJ1blNpbmdsZShydW4pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTUVycm9yKHJ1bikge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVSdW5TaW5nbGUocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25DaGFpblN0YXJ0KHJ1bikge1xuICAgICAgICBhd2FpdCB0aGlzLl9wZXJzaXN0UnVuU2luZ2xlKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIG9uQ2hhaW5FbmQocnVuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVJ1blNpbmdsZShydW4pO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYWluRXJyb3IocnVuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVJ1blNpbmdsZShydW4pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xTdGFydChydW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGVyc2lzdFJ1blNpbmdsZShydW4pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVJ1blNpbmdsZShydW4pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xFcnJvcihydW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlUnVuU2luZ2xlKHJ1bik7XG4gICAgfVxufVxuIiwgIi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgbWVtb3J5IGluIExhbmdDaGFpbidzIENoYWlucy4gTWVtb3J5IHJlZmVycyB0b1xuICogdGhlIHN0YXRlIGluIENoYWlucy4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgcGFzdFxuICogZXhlY3V0aW9ucyBvZiBhIENoYWluIGFuZCBpbmplY3QgdGhhdCBpbmZvcm1hdGlvbiBpbnRvIHRoZSBpbnB1dHMgb2ZcbiAqIGZ1dHVyZSBleGVjdXRpb25zIG9mIHRoZSBDaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNZW1vcnkge1xufVxuY29uc3QgZ2V0VmFsdWUgPSAodmFsdWVzLCBrZXkpID0+IHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1trZXldO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1trZXlzWzBdXTtcbiAgICB9XG59O1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgbWVtb3J5IGNsYXNzZXMgdG8gc2VsZWN0IHRoZSBpbnB1dCB2YWx1ZVxuICogdG8gdXNlIGZvciB0aGUgbWVtb3J5LiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBpbnB1dCB2YWx1ZSwgaXQgaXMgdXNlZC5cbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBpbnB1dCB2YWx1ZXMsIHRoZSBpbnB1dEtleSBtdXN0IGJlIHNwZWNpZmllZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldElucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZXMsIGlucHV0S2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShpbnB1dFZhbHVlcywgaW5wdXRLZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0VmFsdWVzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB2YWx1ZXMgaGF2ZSAke2tleXMubGVuZ3RofSBrZXlzLCB5b3UgbXVzdCBzcGVjaWZ5IGFuIGlucHV0IGtleSBvciBwYXNzIG9ubHkgMSBrZXkgYXMgaW5wdXRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG1lbW9yeSBjbGFzc2VzIHRvIHNlbGVjdCB0aGUgb3V0cHV0IHZhbHVlXG4gKiB0byB1c2UgZm9yIHRoZSBtZW1vcnkuIElmIHRoZXJlIGlzIG9ubHkgb25lIG91dHB1dCB2YWx1ZSwgaXQgaXMgdXNlZC5cbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBvdXRwdXQgdmFsdWVzLCB0aGUgb3V0cHV0S2V5IG11c3QgYmUgc3BlY2lmaWVkLlxuICogSWYgbm8gb3V0cHV0S2V5IGlzIHNwZWNpZmllZCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZ2V0T3V0cHV0VmFsdWUgPSAob3V0cHV0VmFsdWVzLCBvdXRwdXRLZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKG91dHB1dFZhbHVlcywgb3V0cHV0S2V5KTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvdXRwdXRWYWx1ZXMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCB2YWx1ZXMgaGF2ZSAke2tleXMubGVuZ3RofSBrZXlzLCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dCBrZXkgb3IgcGFzcyBvbmx5IDEga2V5IGFzIG91dHB1dGApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgbWVtb3J5IGNsYXNzZXMgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgY2hhdCBtZXNzYWdlIGhpc3RvcnksIGJhc2VkIG9uIHRoZSBtZXNzYWdlIGNvbnRlbnQgYW5kIHJvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXJTdHJpbmcobWVzc2FnZXMsIGh1bWFuUHJlZml4ID0gXCJIdW1hblwiLCBhaVByZWZpeCA9IFwiQUlcIikge1xuICAgIGNvbnN0IHN0cmluZ19tZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbSBvZiBtZXNzYWdlcykge1xuICAgICAgICBsZXQgcm9sZTtcbiAgICAgICAgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgICAgICByb2xlID0gaHVtYW5QcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBhaVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJGdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBtLnJvbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7bX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lU3RyID0gbS5uYW1lID8gYCR7bS5uYW1lfSwgYCA6IFwiXCI7XG4gICAgICAgIHN0cmluZ19tZXNzYWdlcy5wdXNoKGAke3JvbGV9OiAke25hbWVTdHJ9JHttLmNvbnRlbnR9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdfbWVzc2FnZXMuam9pbihcIlxcblwiKTtcbn1cbi8qKlxuICogRnVuY3Rpb24gdXNlZCBieSBtZW1vcnkgY2xhc3NlcyB0byBnZXQgdGhlIGtleSBvZiB0aGUgcHJvbXB0IGlucHV0LFxuICogZXhjbHVkaW5nIGFueSBrZXlzIHRoYXQgYXJlIG1lbW9yeSB2YXJpYWJsZXMgb3IgdGhlIFwic3RvcFwiIGtleS4gSWZcbiAqIHRoZXJlIGlzIG5vdCBleGFjdGx5IG9uZSBwcm9tcHQgaW5wdXQga2V5LCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9tcHRJbnB1dEtleShpbnB1dHMsIG1lbW9yeVZhcmlhYmxlcykge1xuICAgIGNvbnN0IHByb21wdElucHV0S2V5cyA9IE9iamVjdC5rZXlzKGlucHV0cykuZmlsdGVyKChrZXkpID0+ICFtZW1vcnlWYXJpYWJsZXMuaW5jbHVkZXMoa2V5KSAmJiBrZXkgIT09IFwic3RvcFwiKTtcbiAgICBpZiAocHJvbXB0SW5wdXRLZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9uZSBpbnB1dCBrZXkgZXhwZWN0ZWQsIGJ1dCBnb3QgJHtwcm9tcHRJbnB1dEtleXMubGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbXB0SW5wdXRLZXlzWzBdO1xufVxuIiwgImltcG9ydCB7IGdldEJ1ZmZlclN0cmluZyB9IGZyb20gXCIuLi8uLi9tZW1vcnkvYmFzZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi8uLi91dGlsL2Vudi5qc1wiO1xuaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuL3RyYWNlci5qc1wiO1xuZXhwb3J0IGNsYXNzIExhbmdDaGFpblRyYWNlclYxIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibGFuZ2NoYWluX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRwb2ludFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9FTkRQT0lOVFwiKSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MTk4NFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWFkZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXNzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYXBpS2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5ld1Nlc3Npb24oc2Vzc2lvbk5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkNyZWF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBuYW1lOiBzZXNzaW9uTmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMucGVyc2lzdFNlc3Npb24oc2Vzc2lvbkNyZWF0ZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH1cbiAgICBhc3luYyBsb2FkU2Vzc2lvbihzZXNzaW9uTmFtZSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuZW5kcG9pbnR9L3Nlc3Npb25zP25hbWU9JHtzZXNzaW9uTmFtZX1gO1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU2Vzc2lvblJlc3BvbnNlKGVuZHBvaW50KTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZERlZmF1bHRTZXNzaW9uKCkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuZW5kcG9pbnR9L3Nlc3Npb25zP25hbWU9ZGVmYXVsdGA7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTZXNzaW9uUmVzcG9uc2UoZW5kcG9pbnQpO1xuICAgIH1cbiAgICBhc3luYyBjb252ZXJ0VjJSdW5Ub1J1bihydW4pIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbiA/PyAoYXdhaXQgdGhpcy5sb2FkRGVmYXVsdFNlc3Npb24oKSk7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBydW4uc2VyaWFsaXplZDtcbiAgICAgICAgbGV0IHJ1blJlc3VsdDtcbiAgICAgICAgaWYgKHJ1bi5ydW5fdHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0cyA9IHJ1bi5pbnB1dHMucHJvbXB0c1xuICAgICAgICAgICAgICAgID8gcnVuLmlucHV0cy5wcm9tcHRzXG4gICAgICAgICAgICAgICAgOiBydW4uaW5wdXRzLm1lc3NhZ2VzLm1hcCgoeCkgPT4gZ2V0QnVmZmVyU3RyaW5nKHgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxsbVJ1biA9IHtcbiAgICAgICAgICAgICAgICB1dWlkOiBydW4uaWQsXG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bi5lbmRfdGltZSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IHJ1bi5leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHNlc3Npb24uaWQsXG4gICAgICAgICAgICAgICAgcHJvbXB0cyxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuUmVzdWx0ID0gbGxtUnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bi5ydW5fdHlwZSA9PT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZF9ydW5zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuLmNoaWxkX3J1bnMubWFwKChjaGlsZF9ydW4pID0+IHRoaXMuY29udmVydFYyUnVuVG9SdW4oY2hpbGRfcnVuKSkpO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5SdW4gPSB7XG4gICAgICAgICAgICAgICAgdXVpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lLFxuICAgICAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBydW4uZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogcnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uLmlkLFxuICAgICAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgICAgICBjaGlsZF9sbG1fcnVuczogY2hpbGRfcnVucy5maWx0ZXIoKGNoaWxkX3J1bikgPT4gY2hpbGRfcnVuLnR5cGUgPT09IFwibGxtXCIpLFxuICAgICAgICAgICAgICAgIGNoaWxkX2NoYWluX3J1bnM6IGNoaWxkX3J1bnMuZmlsdGVyKChjaGlsZF9ydW4pID0+IGNoaWxkX3J1bi50eXBlID09PSBcImNoYWluXCIpLFxuICAgICAgICAgICAgICAgIGNoaWxkX3Rvb2xfcnVuczogY2hpbGRfcnVucy5maWx0ZXIoKGNoaWxkX3J1bikgPT4gY2hpbGRfcnVuLnR5cGUgPT09IFwidG9vbFwiKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBydW5SZXN1bHQgPSBjaGFpblJ1bjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW4ucnVuX3R5cGUgPT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZF9ydW5zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuLmNoaWxkX3J1bnMubWFwKChjaGlsZF9ydW4pID0+IHRoaXMuY29udmVydFYyUnVuVG9SdW4oY2hpbGRfcnVuKSkpO1xuICAgICAgICAgICAgY29uc3QgdG9vbFJ1biA9IHtcbiAgICAgICAgICAgICAgICB1dWlkOiBydW4uaWQsXG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bi5lbmRfdGltZSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IHJ1bi5leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHNlc3Npb24uaWQsXG4gICAgICAgICAgICAgICAgdG9vbF9pbnB1dDogcnVuLmlucHV0cy5pbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJ1bi5vdXRwdXRzPy5vdXRwdXQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBKU09OLnN0cmluZ2lmeShzZXJpYWxpemVkKSxcbiAgICAgICAgICAgICAgICBjaGlsZF9sbG1fcnVuczogY2hpbGRfcnVucy5maWx0ZXIoKGNoaWxkX3J1bikgPT4gY2hpbGRfcnVuLnR5cGUgPT09IFwibGxtXCIpLFxuICAgICAgICAgICAgICAgIGNoaWxkX2NoYWluX3J1bnM6IGNoaWxkX3J1bnMuZmlsdGVyKChjaGlsZF9ydW4pID0+IGNoaWxkX3J1bi50eXBlID09PSBcImNoYWluXCIpLFxuICAgICAgICAgICAgICAgIGNoaWxkX3Rvb2xfcnVuczogY2hpbGRfcnVucy5maWx0ZXIoKGNoaWxkX3J1bikgPT4gY2hpbGRfcnVuLnR5cGUgPT09IFwidG9vbFwiKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBydW5SZXN1bHQgPSB0b29sUnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJ1biB0eXBlOiAke3J1bi5ydW5fdHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuUmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKHJ1bikge1xuICAgICAgICBsZXQgZW5kcG9pbnQ7XG4gICAgICAgIGxldCB2MVJ1bjtcbiAgICAgICAgaWYgKHJ1bi5ydW5fdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2MVJ1biA9IGF3YWl0IHRoaXMuY29udmVydFYyUnVuVG9SdW4ocnVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYxUnVuID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2MVJ1bi50eXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBlbmRwb2ludCA9IGAke3RoaXMuZW5kcG9pbnR9L2xsbS1ydW5zYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2MVJ1bi50eXBlID09PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIGVuZHBvaW50ID0gYCR7dGhpcy5lbmRwb2ludH0vY2hhaW4tcnVuc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRwb2ludCA9IGAke3RoaXMuZW5kcG9pbnR9L3Rvb2wtcnVuc2A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHYxUnVuKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwZXJzaXN0IHJ1bjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0U2Vzc2lvbihzZXNzaW9uQ3JlYXRlKSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5lbmRwb2ludH0vc2Vzc2lvbnNgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkNyZWF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcGVyc2lzdCBzZXNzaW9uOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSwgdXNpbmcgZGVmYXVsdCBzZXNzaW9uLmApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICAuLi5zZXNzaW9uQ3JlYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IChhd2FpdCByZXNwb25zZS5qc29uKCkpLmlkLFxuICAgICAgICAgICAgLi4uc2Vzc2lvbkNyZWF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZVNlc3Npb25SZXNwb25zZShlbmRwb2ludCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdHJhY2VyU2Vzc2lvbjtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgc2Vzc2lvbjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIHRyYWNlclNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSB0cmFjZXJTZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlclNlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICBpZiAocmVzcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRyYWNlclNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSB0cmFjZXJTZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlclNlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgW3RyYWNlclNlc3Npb25dID0gcmVzcDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gdHJhY2VyU2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRyYWNlclNlc3Npb247XG4gICAgfVxufVxuIiwgImltcG9ydCB7IExhbmdDaGFpblRyYWNlciB9IGZyb20gXCIuL3RyYWNlcl9sYW5nY2hhaW4uanNcIjtcbmltcG9ydCB7IExhbmdDaGFpblRyYWNlclYxIH0gZnJvbSBcIi4vdHJhY2VyX2xhbmdjaGFpbl92MS5qc1wiO1xuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYExhbmdDaGFpblRyYWNlclYxYC4gSWYgYSBzZXNzaW9uXG4gKiBpcyBwcm92aWRlZCwgaXQgbG9hZHMgdGhhdCBzZXNzaW9uIGludG8gdGhlIHRyYWNlcjsgb3RoZXJ3aXNlLCBpdCBsb2Fkc1xuICogYSBkZWZhdWx0IHNlc3Npb24uXG4gKiBAcGFyYW0gc2Vzc2lvbiBPcHRpb25hbCBzZXNzaW9uIHRvIGxvYWQgaW50byB0aGUgdHJhY2VyLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYExhbmdDaGFpblRyYWNlclYxYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYWNpbmdDYWxsYmFja0hhbmRsZXIoc2Vzc2lvbikge1xuICAgIGNvbnN0IHRyYWNlciA9IG5ldyBMYW5nQ2hhaW5UcmFjZXJWMSgpO1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRyYWNlci5sb2FkU2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF3YWl0IHRyYWNlci5sb2FkRGVmYXVsdFNlc3Npb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNlcjtcbn1cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJgLiBJdCBkb2VzIG5vdFxuICogbG9hZCBhbnkgc2Vzc2lvbiBkYXRhLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYExhbmdDaGFpblRyYWNlcmAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmFjaW5nVjJDYWxsYmFja0hhbmRsZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBMYW5nQ2hhaW5UcmFjZXIoKTtcbn1cbiIsICJpbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5sZXQgcXVldWU7XG4vKipcbiAqIENyZWF0ZXMgYSBxdWV1ZSB1c2luZyB0aGUgcC1xdWV1ZSBsaWJyYXJ5LiBUaGUgcXVldWUgaXMgY29uZmlndXJlZCB0b1xuICogYXV0by1zdGFydCBhbmQgaGFzIGEgY29uY3VycmVuY3kgb2YgMSwgbWVhbmluZyBpdCB3aWxsIHByb2Nlc3MgdGFza3NcbiAqIG9uZSBhdCBhIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXVlKCkge1xuICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCA/IFBRdWV1ZU1vZC5kZWZhdWx0IDogUFF1ZXVlTW9kO1xuICAgIHJldHVybiBuZXcgUFF1ZXVlKHtcbiAgICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgICBjb25jdXJyZW5jeTogMSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ29uc3VtZSBhIHByb21pc2UsIGVpdGhlciBhZGRpbmcgaXQgdG8gdGhlIHF1ZXVlIG9yIHdhaXRpbmcgZm9yIGl0IHRvIHJlc29sdmVcbiAqIEBwYXJhbSBwcm9taXNlIFByb21pc2UgdG8gY29uc3VtZVxuICogQHBhcmFtIHdhaXQgV2hldGhlciB0byB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIG9yIHJlc29sdmUgaW1tZWRpYXRlbHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVDYWxsYmFjayhwcm9taXNlRm4sIHdhaXQpIHtcbiAgICBpZiAod2FpdCA9PT0gdHJ1ZSkge1xuICAgICAgICBhd2FpdCBwcm9taXNlRm4oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcXVldWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHF1ZXVlID0gY3JlYXRlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIHF1ZXVlLmFkZChwcm9taXNlRm4pO1xuICAgIH1cbn1cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgcXVldWUgdG8gcmVzb2x2ZS4gSWYgdGhlIHF1ZXVlIGlzXG4gKiB1bmRlZmluZWQsIGl0IGltbWVkaWF0ZWx5IHJlc29sdmVzIGEgcHJvbWlzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0QWxsQ2FsbGJhY2tzKCkge1xuICAgIHJldHVybiB0eXBlb2YgcXVldWUgIT09IFwidW5kZWZpbmVkXCIgPyBxdWV1ZS5vbklkbGUoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xufVxuIiwgImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBCYXNlQ2FsbGJhY2tIYW5kbGVyLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IENvbnNvbGVDYWxsYmFja0hhbmRsZXIgfSBmcm9tIFwiLi9oYW5kbGVycy9jb25zb2xlLmpzXCI7XG5pbXBvcnQgeyBnZXRUcmFjaW5nQ2FsbGJhY2tIYW5kbGVyLCBnZXRUcmFjaW5nVjJDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4vaGFuZGxlcnMvaW5pdGlhbGl6ZS5qc1wiO1xuaW1wb3J0IHsgZ2V0QnVmZmVyU3RyaW5nIH0gZnJvbSBcIi4uL21lbW9yeS9iYXNlLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWwvZW52LmpzXCI7XG5pbXBvcnQgeyBMYW5nQ2hhaW5UcmFjZXIsIH0gZnJvbSBcIi4vaGFuZGxlcnMvdHJhY2VyX2xhbmdjaGFpbi5qc1wiO1xuaW1wb3J0IHsgY29uc3VtZUNhbGxiYWNrIH0gZnJvbSBcIi4vcHJvbWlzZXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGFyZykge1xuICAgIGlmICghYXJnKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8IFwibmFtZVwiIGluIGFyZykge1xuICAgICAgICByZXR1cm4geyBjYWxsYmFja3M6IGFyZyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59XG4vKipcbiAqIE1hbmFnZSBjYWxsYmFja3MgZnJvbSBkaWZmZXJlbnQgY29tcG9uZW50cyBvZiBMYW5nQ2hhaW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ2FsbGJhY2tNYW5hZ2VyIHtcbiAgICBzZXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0SGFuZGxlcnMoW2hhbmRsZXJdKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJ1biBtYW5hZ2VyIGluIExhbmdDaGFpbi5cbiAqL1xuY2xhc3MgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1bklkLCBoYW5kbGVycywgaW5oZXJpdGFibGVIYW5kbGVycywgdGFncywgaW5oZXJpdGFibGVUYWdzLCBtZXRhZGF0YSwgaW5oZXJpdGFibGVNZXRhZGF0YSwgX3BhcmVudFJ1bklkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBydW5JZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZUhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZUhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0YWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlVGFnc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZU1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZU1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFyZW50UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9wYXJlbnRSdW5JZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVGV4dCh0ZXh0KSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRleHQ/Lih0ZXh0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVGV4dDogJHtlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIE1hbmFnZXMgY2FsbGJhY2tzIGZvciByZXRyaWV2ZXIgcnVucy5cbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyRW5kPy4oZG9jdW1lbnRzLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlckVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJFcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGFzeW5jIGhhbmRsZUxMTU5ld1Rva2VuKHRva2VuLCBpZHgsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZmllbGRzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNTmV3VG9rZW4/Lih0b2tlbiwgaWR4ID8/IHsgcHJvbXB0OiAwLCBjb21wbGV0aW9uOiAwIH0sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTU5ld1Rva2VuOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1FbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVyciwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUNoYWluRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVuZChvdXRwdXQsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpbkVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50QWN0aW9uPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQWdlbnRBY3Rpb246ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50RW5kPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQWdlbnRFbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xFcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0KSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUb29sRW5kPy4ob3V0cHV0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0ID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiV2hhdCBpcyB0aGUgYW5zd2VyIHRvIHtxdWVzdGlvbn0/XCIpO1xuICpcbiAqIC8vIEV4YW1wbGUgb2YgdXNpbmcgTExNQ2hhaW4gd2l0aCBPcGVuQUkgYW5kIGEgc2ltcGxlIHByb21wdFxuICogY29uc3QgY2hhaW4gPSBuZXcgTExNQ2hhaW4oe1xuICogICBsbG06IG5ldyBDaGF0T3BlbkFJKHsgdGVtcGVyYXR1cmU6IDAuOSB9KSxcbiAqICAgcHJvbXB0LFxuICogfSk7XG4gKlxuICogLy8gUnVubmluZyB0aGUgY2hhaW4gd2l0aCBhIHNpbmdsZSBxdWVzdGlvblxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uY2FsbCh7XG4gKiAgIHF1ZXN0aW9uOiBcIldoYXQgaXMgdGhlIGFpcnNwZWVkIHZlbG9jaXR5IG9mIGFuIHVubGFkZW4gc3dhbGxvdz9cIixcbiAqIH0pO1xuICogY29uc29sZS5sb2coXCJUaGUgYW5zd2VyIGlzOlwiLCByZXN1bHQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRSdW5JZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZUhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuX3BhcmVudFJ1bklkID0gcGFyZW50UnVuSWQ7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgX3J1bklkID0gdW5kZWZpbmVkLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIGV4dHJhUGFyYW1zID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcHRzLm1hcChhc3luYyAocHJvbXB0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydW5JZCA9IHV1aWR2NCgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1TdGFydD8uKGxsbSwgW3Byb21wdF0sIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTVN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIF9ydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gdXVpZHY0KCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQ/LihsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlci5oYW5kbGVMTE1TdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHJpbmcgPSBnZXRCdWZmZXJTdHJpbmcobWVzc2FnZUdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0Py4obGxtLCBbbWVzc2FnZVN0cmluZ10sIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTVN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQgPSB1dWlkdjQoKSwgcnVuVHlwZSA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5TdGFydD8uKGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yQ2hhaW5SdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQgPSB1dWlkdjQoKSwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUb29sU3RhcnQ/Lih0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkID0gdXVpZHY0KCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlclN0YXJ0Py4ocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5maWx0ZXIoKF9oYW5kbGVyKSA9PiBfaGFuZGxlciAhPT0gaGFuZGxlcik7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyA9IHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5maWx0ZXIoKF9oYW5kbGVyKSA9PiBfaGFuZGxlciAhPT0gaGFuZGxlcik7XG4gICAgfVxuICAgIHNldEhhbmRsZXJzKGhhbmRsZXJzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUYWdzKHRhZ3MsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGFncyh0YWdzKTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgdGhpcy50YWdzLnB1c2goLi4udGFncyk7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVRhZ3ModGFncykge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+ICF0YWdzLmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IHRoaXMuaW5oZXJpdGFibGVUYWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICB9XG4gICAgYWRkTWV0YWRhdGEobWV0YWRhdGEsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB7IC4uLnRoaXMubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEgPSB7IC4uLnRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgLi4ubWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1ldGFkYXRhW2tleV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShhZGRpdGlvbmFsSGFuZGxlcnMgPSBbXSwgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5fcGFyZW50UnVuSWQpO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuaW5jbHVkZXMoaGFuZGxlcik7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5pbmNsdWRlcyh0YWcpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBpbmhlcml0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gT2JqZWN0LmtleXModGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKS5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh7IFtrZXldOiB0aGlzLm1ldGFkYXRhW2tleV0gfSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBhZGRpdGlvbmFsSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgY29waWVzIG9mIGNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclxuICAgICAgICAgICAgbWFuYWdlci5oYW5kbGVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGgpID0+IGgubmFtZSA9PT0gXCJjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcIilcbiAgICAgICAgICAgICAgICAuc29tZSgoaCkgPT4gaC5uYW1lID09PSBoYW5kbGVyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgY2xhc3MgSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHV1aWR2NCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBoYW5kbGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyB0aGlzKCk7XG4gICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihuZXcgSGFuZGxlcigpKTtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjb25maWd1cmUoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrTWFuYWdlcjtcbiAgICAgICAgaWYgKGluaGVyaXRhYmxlSGFuZGxlcnMgfHwgbG9jYWxIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5oZXJpdGFibGVIYW5kbGVycykgfHwgIWluaGVyaXRhYmxlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLnNldEhhbmRsZXJzKGluaGVyaXRhYmxlSGFuZGxlcnM/Lm1hcChlbnN1cmVIYW5kbGVyKSA/PyBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBpbmhlcml0YWJsZUhhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gY2FsbGJhY2tNYW5hZ2VyLmNvcHkoQXJyYXkuaXNBcnJheShsb2NhbEhhbmRsZXJzKVxuICAgICAgICAgICAgICAgID8gbG9jYWxIYW5kbGVycy5tYXAoZW5zdXJlSGFuZGxlcilcbiAgICAgICAgICAgICAgICA6IGxvY2FsSGFuZGxlcnM/LmhhbmRsZXJzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZUVuYWJsZWQgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1ZFUkJPU0VcIikgPT09IFwidHJ1ZVwiIHx8XG4gICAgICAgICAgICBvcHRpb25zPy52ZXJib3NlO1xuICAgICAgICBjb25zdCB0cmFjaW5nVjJFbmFibGVkID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgY29uc3QgdHJhY2luZ0VuYWJsZWQgPSB0cmFjaW5nVjJFbmFibGVkIHx8XG4gICAgICAgICAgICAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9UUkFDSU5HXCIpID8/IGZhbHNlKTtcbiAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkIHx8IHRyYWNpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyLnByb3RvdHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnNvbGVIYW5kbGVyID0gbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihjb25zb2xlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ0VuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNpbmdWMkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZEhhbmRsZXIoYXdhaXQgZ2V0VHJhY2luZ1YyQ2FsbGJhY2tIYW5kbGVyKCksIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fUFJPSkVDVFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihhd2FpdCBnZXRUcmFjaW5nQ2FsbGJhY2tIYW5kbGVyKHNlc3Npb24pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaGVyaXRhYmxlVGFncyB8fCBsb2NhbFRhZ3MpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhpbmhlcml0YWJsZVRhZ3MgPz8gW10pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRUYWdzKGxvY2FsVGFncyA/PyBbXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZU1ldGFkYXRhIHx8IGxvY2FsTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkTWV0YWRhdGEoaW5oZXJpdGFibGVNZXRhZGF0YSA/PyB7fSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGxvY2FsTWV0YWRhdGEgPz8ge30sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tNYW5hZ2VyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmIChcIm5hbWVcIiBpbiBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gQmFzZUNhbGxiYWNrSGFuZGxlci5mcm9tTWV0aG9kcyhoYW5kbGVyKTtcbn1cbi8qKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHByb21wdCA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShgV2hhdCBpcyB0aGUgYW5zd2VyIHRvIHtxdWVzdGlvbn0/YCk7XG4gKlxuICogLy8gRXhhbXBsZSBvZiB1c2luZyBMTE1DaGFpbiB0byBwcm9jZXNzIGEgc2VyaWVzIG9mIHF1ZXN0aW9uc1xuICogY29uc3QgY2hhaW4gPSBuZXcgTExNQ2hhaW4oe1xuICogICBsbG06IG5ldyBDaGF0T3BlbkFJKHsgdGVtcGVyYXR1cmU6IDAuOSB9KSxcbiAqICAgcHJvbXB0LFxuICogfSk7XG4gKlxuICogLy8gUHJvY2VzcyBxdWVzdGlvbnMgdXNpbmcgdGhlIGNoYWluXG4gKiBjb25zdCBwcm9jZXNzUXVlc3Rpb25zID0gYXN5bmMgKHF1ZXN0aW9ucykgPT4ge1xuICogICBmb3IgKGNvbnN0IHF1ZXN0aW9uIG9mIHF1ZXN0aW9ucykge1xuICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmNhbGwoeyBxdWVzdGlvbiB9KTtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICB9XG4gKiB9O1xuICpcbiAqIC8vIEV4YW1wbGUgcXVlc3Rpb25zXG4gKiBjb25zdCBxdWVzdGlvbnMgPSBbXG4gKiAgIFwiV2hhdCBpcyB5b3VyIG5hbWU/XCIsXG4gKiAgIFwiV2hhdCBpcyB5b3VyIHF1ZXN0P1wiLFxuICogICBcIldoYXQgaXMgeW91ciBmYXZvcml0ZSBjb2xvcj9cIixcbiAqIF07XG4gKlxuICogLy8gUnVuIHRoZSBleGFtcGxlXG4gKiBwcm9jZXNzUXVlc3Rpb25zKHF1ZXN0aW9ucykuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFjZUdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcihncm91cE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3JvdXBOYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBncm91cE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bk1hbmFnZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhY2VHcm91cENhbGxiYWNrTWFuYWdlcihncm91cF9uYW1lLCBpbnB1dHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2IgPSBuZXcgTGFuZ0NoYWluVHJhY2VyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjbSA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoW2NiXSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjbT8uaGFuZGxlQ2hhaW5TdGFydCh7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICBpZDogW1wibGFuZ2NoYWluXCIsIFwiY2FsbGJhY2tzXCIsIFwiZ3JvdXBzXCIsIGdyb3VwX25hbWVdLFxuICAgICAgICB9LCBpbnB1dHMgPz8ge30pO1xuICAgICAgICBpZiAoIXJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcnVuIGdyb3VwIGNhbGxiYWNrIG1hbmFnZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5NYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBzdGFydChpbnB1dHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0VHJhY2VHcm91cENhbGxiYWNrTWFuYWdlcih0aGlzLmdyb3VwTmFtZSwgaW5wdXRzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bk1hbmFnZXIuZ2V0Q2hpbGQoKTtcbiAgICB9XG4gICAgYXN5bmMgZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTWFuYWdlci5oYW5kbGVDaGFpbkVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dCkge1xuICAgICAgICBpZiAodGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1hbmFnZXIuaGFuZGxlQ2hhaW5FbmQob3V0cHV0ID8/IHt9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFjZUFzR3JvdXAoZ3JvdXBPcHRpb25zLCBlbmNsb3NlZENvZGUsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0cmFjZUdyb3VwID0gbmV3IFRyYWNlR3JvdXAoZ3JvdXBPcHRpb25zLm5hbWUsIGdyb3VwT3B0aW9ucyk7XG4gICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gYXdhaXQgdHJhY2VHcm91cC5zdGFydCh7IC4uLmFyZ3MgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW5jbG9zZWRDb2RlKGNhbGxiYWNrTWFuYWdlciwgLi4uYXJncyk7XG4gICAgICAgIGF3YWl0IHRyYWNlR3JvdXAuZW5kKF9jb2VyY2VUb0RpY3QocmVzdWx0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdHJhY2VHcm91cC5lcnJvcihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuIiwgImltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCB7IENhbGxiYWNrTWFuYWdlciwgfSBmcm9tIFwiLi4vLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmltcG9ydCB7IExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgUnVuTG9nUGF0Y2gsIH0gZnJvbSBcIi4uLy4uL2NhbGxiYWNrcy9oYW5kbGVycy9sb2dfc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUgfSBmcm9tIFwiLi4vLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbmltcG9ydCB7IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gfSBmcm9tIFwiLi4vLi4vdXRpbC9zdHJlYW0uanNcIjtcbmltcG9ydCB7IGdldENhbGxiYWNrTWFuZ2VyRm9yQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuLi8uLi91dGlsL2FzeW5jX2NhbGxlci5qc1wiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG4vKipcbiAqIEEgUnVubmFibGUgaXMgYSBnZW5lcmljIHVuaXQgb2Ygd29yayB0aGF0IGNhbiBiZSBpbnZva2VkLCBiYXRjaGVkLCBzdHJlYW1lZCwgYW5kL29yXG4gKiB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYXJndW1lbnRzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ga3dhcmdzXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBhcHBseSB0aGUgYm91bmQgYXJncy5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHsgYm91bmQ6IHRoaXMsIGt3YXJncywgY29uZmlnOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IFJ1bm5hYmxlIHRoYXQgbWFwcyBhIGxpc3Qgb2YgaW5wdXRzIHRvIGEgbGlzdCBvZiBvdXRwdXRzLFxuICAgICAqIGJ5IGNhbGxpbmcgaW52b2tlKCkgd2l0aCBlYWNoIGlucHV0LlxuICAgICAqL1xuICAgIG1hcCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7IGJvdW5kOiB0aGlzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcmV0cnkgbG9naWMgdG8gYW4gZXhpc3RpbmcgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGt3YXJnc1xuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlUmV0cnkgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIHJldHJ5IGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVJldHJ5KHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBtYXhBdHRlbXB0TnVtYmVyOiBmaWVsZHM/LnN0b3BBZnRlckF0dGVtcHQsXG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGNvbmZpZyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBOZXcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIHRvIGF0dGFjaCB0byB0aGUgbmV3IHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlQmluZGluZyB3aXRoIGEgY29uZmlnIG1hdGNoaW5nIHdoYXQncyBwYXNzZWQuXG4gICAgICovXG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGt3YXJnczoge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcnVubmFibGUgZnJvbSB0aGUgY3VycmVudCBvbmUgdGhhdCB3aWxsIHRyeSBpbnZva2luZ1xuICAgICAqIG90aGVyIHBhc3NlZCBmYWxsYmFjayBydW5uYWJsZXMgaWYgdGhlIGluaXRpYWwgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKiBAcGFyYW0gZmllbGRzLmZhbGxiYWNrcyBPdGhlciBydW5uYWJsZXMgdG8gY2FsbCBpZiB0aGUgcnVubmFibGUgZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcy5cbiAgICAgKi9cbiAgICB3aXRoRmFsbGJhY2tzKGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIHJ1bm5hYmxlOiB0aGlzLFxuICAgICAgICAgICAgZmFsbGJhY2tzOiBmaWVsZHMuZmFsbGJhY2tzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXNzZWQgXCJvcHRpb25zXCIgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgaW5wdXRzLCBidXQgZ290ICR7b3B0aW9ucy5sZW5ndGh9IG9wdGlvbnMgZm9yICR7bGVuZ3RofSBpbnB1dHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWdMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogYmF0Y2hPcHRpb25zPy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJhdGNoQ2FsbHMgPSBpbnB1dHMubWFwKChpbnB1dCwgaSkgPT4gY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmludm9rZShpbnB1dCwgY29uZmlnTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYmF0Y2hDYWxscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RyZWFtaW5nIGltcGxlbWVudGF0aW9uLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgc3VwcG9ydCBzdHJlYW1pbmcgb3V0cHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvdXRwdXQgaW4gY2h1bmtzLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnMgQSByZWFkYWJsZSBzdHJlYW0gdGhhdCBpcyBhbHNvIGFuIGl0ZXJhYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3IodGhpcy5fc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlQ29uZmlnID0ge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBvcHRpb25zLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICAgICAgcnVuTmFtZTogb3B0aW9ucy5ydW5OYW1lLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuY2FsbGJhY2tzO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMudGFncztcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLm1ldGFkYXRhO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucnVuTmFtZTtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyBfY2FsbFdpdGhDb25maWcoZnVuYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuZ2VyRm9yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCB1bmRlZmluZWQsIG9wdGlvbnM/LnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IGZ1bmMuYmluZCh0aGlzKShpbnB1dCwgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IGhhbmRsZXMgYmF0Y2hpbmcgYW5kIGNvbmZpZ3VyYXRpb24gZm9yIGEgcnVubmFibGVcbiAgICAgKiBJdCB0YWtlcyBhIGZ1bmN0aW9uLCBpbnB1dCB2YWx1ZXMsIGFuZCBvcHRpb25hbCBjb25maWd1cmF0aW9uLCBhbmRcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCBpbnB1dCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHZhbHVlcyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgdmFsdWVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9iYXRjaFdpdGhDb25maWcoZnVuYywgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnNMaXN0Lm1hcChnZXRDYWxsYmFja01hbmdlckZvckNvbmZpZykpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKChjYWxsYmFja01hbmFnZXIsIGkpID0+IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgdW5kZWZpbmVkLCBvcHRpb25zTGlzdFtpXS5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9uc0xpc3RbaV0ucnVuTmFtZSkpKTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRwdXRzID0gYXdhaXQgZnVuYyhpbnB1dHMsIG9wdGlvbnNMaXN0LCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGFuIEl0ZXJhdG9yIG9mIElucHV0IHZhbHVlcyBpbnRvIGFuIEl0ZXJhdG9yIG9mXG4gICAgICogT3V0cHV0IHZhbHVlcywgd2l0aCBjYWxsYmFja3MuXG4gICAgICogVXNlIHRoaXMgdG8gaW1wbGVtZW50IGBzdHJlYW0oKWAgb3IgYHRyYW5zZm9ybSgpYCBpbiBSdW5uYWJsZSBzdWJjbGFzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jICpfdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhpbnB1dEdlbmVyYXRvciwgdHJhbnNmb3JtZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZpbmFsSW5wdXQ7XG4gICAgICAgIGxldCBmaW5hbElucHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5nZXJGb3JDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGxldCBydW5NYW5hZ2VyO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvSlNPTigpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogd3JhcElucHV0Rm9yVHJhY2luZygpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJ1biBtYW5hZ2VyIEFGVEVSIHRoZSBpdGVyYXRvciBzdGFydHMgdG8gcHJlc2VydmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhY2luZyBvcmRlclxuICAgICAgICAgICAgICAgICAgICBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydChzZXJpYWxpemVkUmVwcmVzZW50YXRpb24sIHsgaW5wdXQ6IFwiXCIgfSwgdW5kZWZpbmVkLCBvcHRpb25zPy5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gZmluYWxJbnB1dC5jb25jYXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRJbnB1dEdlbmVyYXRvciA9IHdyYXBJbnB1dEZvclRyYWNpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEl0ZXJhdG9yID0gdHJhbnNmb3JtZXIod3JhcHBlZElucHV0R2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0SXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBmaW5hbE91dHB1dC5jb25jYXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpIH0pO1xuICAgIH1cbiAgICBfcGF0Y2hDb25maWcoY29uZmlnID0ge30sIGNhbGxiYWNrTWFuYWdlciA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXdDb25maWcgPSB7IC4uLmNvbmZpZyB9O1xuICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgcmVwbGFjaW5nIGNhbGxiYWNrcyB3ZSBuZWVkIHRvIHVuc2V0IHJ1bk5hbWVcbiAgICAgICAgICAgICAqIHNpbmNlIHRoYXQgc2hvdWxkIGFwcGx5IG9ubHkgdG8gdGhlIHNhbWUgcnVuIGFzIHRoZSBvcmlnaW5hbCBjYWxsYmFja3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5ydW5OYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubmV3Q29uZmlnLCBjYWxsYmFja3M6IGNhbGxiYWNrTWFuYWdlciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBzZXF1ZW5jZSB0aGF0IHJ1bnMgZWFjaCBpbmRpdmlkdWFsIHJ1bm5hYmxlIGluIHNlcmllcyxcbiAgICAgKiBwaXBpbmcgdGhlIG91dHB1dCBvZiBvbmUgcnVubmFibGUgaW50byBhbm90aGVyIHJ1bm5hYmxlIG9yIHJ1bm5hYmxlLWxpa2UuXG4gICAgICogQHBhcmFtIGNvZXJjZWFibGUgQSBydW5uYWJsZSwgZnVuY3Rpb24sIG9yIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGZ1bmN0aW9ucyBvciBydW5uYWJsZXMuXG4gICAgICogQHJldHVybnMgQSBuZXcgcnVubmFibGUgc2VxdWVuY2UuXG4gICAgICovXG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLFxuICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRyYW5zZm9ybSwgd2hpY2ggYnVmZmVycyBpbnB1dCBhbmQgdGhlbiBjYWxscyBzdHJlYW0uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBjYW4gc3RhcnQgcHJvZHVjaW5nIG91dHB1dCB3aGlsZVxuICAgICAqIGlucHV0IGlzIHN0aWxsIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIGdhdGhlcmluZyBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBmaW5hbENodW5rLmNvbmNhdChjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUl0ZXJhdG9yKGZpbmFsQ2h1bmssIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYWxsIG91dHB1dCBmcm9tIGEgcnVubmFibGUsIGFzIHJlcG9ydGVkIHRvIHRoZSBjYWxsYmFjayBzeXN0ZW0uXG4gICAgICogVGhpcyBpbmNsdWRlcyBhbGwgaW5uZXIgcnVucyBvZiBMTE1zLCBSZXRyaWV2ZXJzLCBUb29scywgZXRjLlxuICAgICAqIE91dHB1dCBpcyBzdHJlYW1lZCBhcyBMb2cgb2JqZWN0cywgd2hpY2ggaW5jbHVkZSBhIGxpc3Qgb2ZcbiAgICAgKiBqc29ucGF0Y2ggb3BzIHRoYXQgZGVzY3JpYmUgaG93IHRoZSBzdGF0ZSBvZiB0aGUgcnVuIGhhcyBjaGFuZ2VkIGluIGVhY2hcbiAgICAgKiBzdGVwLCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBydW4uXG4gICAgICogVGhlIGpzb25wYXRjaCBvcHMgY2FuIGJlIGFwcGxpZWQgaW4gb3JkZXIgdG8gY29uc3RydWN0IHN0YXRlLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN0cmVhbU9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqc3RyZWFtTG9nKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBbc3RyZWFtXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3MuY29uY2F0KFtzdHJlYW1dKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gYXdhaXQgdGhpcy5zdHJlYW0oaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBydW5uYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9zdHJlYW1lZF9vdXRwdXQvLVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdHJlYW0ud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdHJlYW0ud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Qcm9taXNlID0gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBsb2c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBydW5uYWJsZVN0cmVhbVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZSh0aGluZykge1xuICAgICAgICByZXR1cm4gdGhpbmcgPyB0aGluZy5sY19ydW5uYWJsZSA6IGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGRlbGVnYXRlcyBjYWxscyB0byBhbm90aGVyIHJ1bm5hYmxlIHdpdGggYSBzZXQgb2Yga3dhcmdzLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVCaW5kaW5nIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUJpbmRpbmdcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwic2NoZW1hXCIsIFwicnVubmFibGVcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYm91bmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImt3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmllbGRzLmJvdW5kO1xuICAgICAgICB0aGlzLmt3YXJncyA9IGZpZWxkcy5rd2FyZ3M7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZmllbGRzLmNvbmZpZztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfbWVyZ2VDb25maWcob3B0aW9ucykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjb3B5ID0geyAuLi50aGlzLmNvbmZpZyB9O1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIm1ldGFkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwidGFnc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IChjb3B5W2tleV0gPz8gW10pLmNvbmNhdChvcHRpb25zW2tleV0gPz8gW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gb3B0aW9uc1trZXldID8/IGNvcHlba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB7IC4uLnRoaXMua3dhcmdzLCAuLi5rd2FyZ3MgfSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aFJldHJ5KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC53aXRoUmV0cnkoZmllbGRzKSxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmludm9rZShpbnB1dCwgdGhpcy5fbWVyZ2VDb25maWcoeyAuLi5vcHRpb25zLCAuLi50aGlzLmt3YXJncyB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMpXG4gICAgICAgICAgICA/IG9wdGlvbnMubWFwKChpbmRpdmlkdWFsT3B0aW9uKSA9PiB0aGlzLl9tZXJnZUNvbmZpZyh7XG4gICAgICAgICAgICAgICAgLi4uaW5kaXZpZHVhbE9wdGlvbixcbiAgICAgICAgICAgICAgICAuLi50aGlzLmt3YXJncyxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgOiB0aGlzLl9tZXJnZUNvbmZpZyh7IC4uLm9wdGlvbnMsIC4uLnRoaXMua3dhcmdzIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5iYXRjaChpbnB1dHMsIG1lcmdlZE9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCB0aGlzLl9tZXJnZUNvbmZpZyh7IC4uLm9wdGlvbnMsIC4uLnRoaXMua3dhcmdzIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLnN0cmVhbShpbnB1dCwgdGhpcy5fbWVyZ2VDb25maWcoeyAuLi5vcHRpb25zLCAuLi50aGlzLmt3YXJncyB9KSk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQudHJhbnNmb3JtKGdlbmVyYXRvciwgdGhpcy5fbWVyZ2VDb25maWcoeyAuLi5vcHRpb25zLCAuLi50aGlzLmt3YXJncyB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlQmluZGluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRoaW5nXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nLmJvdW5kICYmIFJ1bm5hYmxlLmlzUnVubmFibGUodGhpbmcuYm91bmQpO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGRlbGVnYXRlcyBjYWxscyB0byBhbm90aGVyIHJ1bm5hYmxlXG4gKiB3aXRoIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUVhY2ggZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlRWFjaFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInNjaGVtYVwiLCBcInJ1bm5hYmxlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmllbGRzLmJvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGJpbmQgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBSdW5uYWJsZUVhY2hgIGNsYXNzIHRoYXQgaXMgYm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC5iaW5kKGt3YXJncyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UsIGlucHV0cywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBfaW52b2tlKGlucHV0cywgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmJhdGNoKGlucHV0cywgdGhpcy5fcGF0Y2hDb25maWcoY29uZmlnLCBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW5uYWJsZXMgdGhhdCBjYW4gYmUgcmV0cmllZCBhXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVSZXRyeSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlUmV0cnlcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwic2NoZW1hXCIsIFwicnVubmFibGVcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heEF0dGVtcHROdW1iZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkQXR0ZW1wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4geyB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heEF0dGVtcHROdW1iZXIgPSBmaWVsZHMubWF4QXR0ZW1wdE51bWJlciA/PyB0aGlzLm1heEF0dGVtcHROdW1iZXI7XG4gICAgICAgIHRoaXMub25GYWlsZWRBdHRlbXB0ID0gZmllbGRzLm9uRmFpbGVkQXR0ZW1wdCA/PyB0aGlzLm9uRmFpbGVkQXR0ZW1wdDtcbiAgICB9XG4gICAgX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGF0dGVtcHQgPiAxID8gYHJldHJ5OmF0dGVtcHQ6JHthdHRlbXB0fWAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRjaENvbmZpZyhjb25maWcsIHJ1bk1hbmFnZXI/LmdldENoaWxkKHRhZykpO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIHBSZXRyeSgoYXR0ZW1wdE51bWJlcikgPT4gc3VwZXIuaW52b2tlKGlucHV0LCB0aGlzLl9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHROdW1iZXIsIGNvbmZpZywgcnVuTWFuYWdlcikpLCB7XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IHRoaXMub25GYWlsZWRBdHRlbXB0LFxuICAgICAgICAgICAgcmV0cmllczogTWF0aC5tYXgodGhpcy5tYXhBdHRlbXB0TnVtYmVyIC0gMSwgMCksXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBpbnZva2VzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQsIHJ1biBtYW5hZ2VyLFxuICAgICAqIGFuZCBjb25maWcuIEl0IGhhbmRsZXMgdGhlIHJldHJ5IGxvZ2ljIGJ5IGNhdGNoaW5nIGFueSBlcnJvcnMgYW5kXG4gICAgICogcmVjdXJzaXZlbHkgaW52b2tpbmcgaXRzZWxmIHdpdGggdGhlIHVwZGF0ZWQgY29uZmlnIGZvciB0aGUgbmV4dCByZXRyeVxuICAgICAqIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBydW5NYW5hZ2VyIFRoZSBydW4gbWFuYWdlciBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZyBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBjb25maWdzLCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHNNYXAgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBSZXRyeShhc3luYyAoYXR0ZW1wdE51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0luZGV4ZXMgPSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gaSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaSkgPT4gcmVzdWx0c01hcFtpLnRvU3RyaW5nKCldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gaW5zdGFuY2VvZiBFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXRzID0gcmVtYWluaW5nSW5kZXhlcy5tYXAoKGkpID0+IGlucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZENvbmZpZ3MgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWdzPy5baV0sIHJ1bk1hbmFnZXJzPy5baV0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIuYmF0Y2gocmVtYWluaW5nSW5wdXRzLCBwYXRjaGVkQ29uZmlncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5iYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkV4Y2VwdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRNYXBJbmRleCA9IHJlbWFpbmluZ0luZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNNYXBbcmVzdWx0TWFwSW5kZXgudG9TdHJpbmcoKV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmaXJzdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiB0aGlzLm9uRmFpbGVkQXR0ZW1wdCxcbiAgICAgICAgICAgICAgICByZXRyaWVzOiBNYXRoLm1heCh0aGlzLm1heEF0dGVtcHROdW1iZXIgLSAxLCAwKSxcbiAgICAgICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdHNNYXApXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYSwgMTApIC0gcGFyc2VJbnQoYiwgMTApKVxuICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiByZXN1bHRzTWFwW3BhcnNlSW50KGtleSwgMTApXSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXRjaFdpdGhDb25maWcodGhpcy5fYmF0Y2guYmluZCh0aGlzKSwgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbn1cbi8qKlxuICogQSBzZXF1ZW5jZSBvZiBydW5uYWJsZXMsIHdoZXJlIHRoZSBvdXRwdXQgb2YgZWFjaCBpcyB0aGUgaW5wdXQgb2YgdGhlIG5leHQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0VGVtcGxhdGUgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgIFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiLFxuICogKTtcbiAqIGNvbnN0IGNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtwcm9tcHRUZW1wbGF0ZSwgbmV3IENoYXRPcGVuQUkoe30pXSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5pbnZva2UoeyB0b3BpYzogXCJiZWFyc1wiIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVNlcXVlbmNlIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVNlcXVlbmNlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtaWRkbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzY2hlbWFcIiwgXCJydW5uYWJsZVwiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpZWxkcy5maXJzdDtcbiAgICAgICAgdGhpcy5taWRkbGUgPSBmaWVsZHMubWlkZGxlID8/IHRoaXMubWlkZGxlO1xuICAgICAgICB0aGlzLmxhc3QgPSBmaWVsZHMubGFzdDtcbiAgICB9XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuZ2VyRm9yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICBsZXQgbmV4dFN0ZXBJbnB1dCA9IGlucHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsU3RlcHMgPSBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGVdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsU3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gaW5pdGlhbFN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXQgPSBhd2FpdCBzdGVwLmludm9rZShuZXh0U3RlcElucHV0LCB0aGlzLl9wYXRjaENvbmZpZyhvcHRpb25zLCBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc2VxOnN0ZXA6JHtpICsgMX1gKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBjYW4ndCBkZXRlY3QgdGhhdCB0aGUgbGFzdCBvdXRwdXQgb2YgdGhlIHNlcXVlbmNlIHJldHVybnMgUnVuT3V0cHV0LCBzbyBjYWxsIGl0IG91dCBvZiB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICBmaW5hbE91dHB1dCA9IGF3YWl0IHRoaXMubGFzdC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgdGhpcy5fcGF0Y2hDb25maWcob3B0aW9ucywgcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7dGhpcy5zdGVwcy5sZW5ndGh9YCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChmaW5hbE91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gZmluYWxPdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKGdldENhbGxiYWNrTWFuZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSkpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXRzID0gaW5wdXRzO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGluaXRpYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0cyA9IGF3YWl0IHN0ZXAuYmF0Y2gobmV4dFN0ZXBJbnB1dHMsIHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaikgPT4gdGhpcy5fcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwgcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCkpKSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsT3V0cHV0cyA9IGF3YWl0IHRoaXMubGFzdC5iYXRjaChuZXh0U3RlcElucHV0cywgcnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiB0aGlzLl9wYXRjaENvbmZpZyhjb25maWdMaXN0W3RoaXMuc3RlcHMubGVuZ3RoIC0gMV0sIHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzZXE6c3RlcDoke3RoaXMuc3RlcHMubGVuZ3RofWApKSksIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGkpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXRzW2ldLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsT3V0cHV0cztcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5nZXJGb3JDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBuZXh0U3RlcElucHV0ID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBydW5uYWJsZSBpbiB0aGUgc2VxdWVuY2UgdGhhdCBkb2Vzbid0IGhhdmUgYW4gb3ZlcnJpZGRlbiAudHJhbnNmb3JtKCkgbWV0aG9kXG4gICAgICAgIC8vIGFuZCBzdGFydCBzdHJlYW1pbmcgZnJvbSB0aGVyZVxuICAgICAgICBjb25zdCBzdHJlYW1pbmdTdGFydFN0ZXBJbmRleCA9IE1hdGgubWluKHN0ZXBzLmxlbmd0aCAtIDEsIHN0ZXBzLmxlbmd0aCAtXG4gICAgICAgICAgICBbLi4uc3RlcHNdLnJldmVyc2UoKS5maW5kSW5kZXgoKHN0ZXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0RlZmF1bHRJbXBsZW1lbnRhdGlvbiA9IHN0ZXAudHJhbnNmb3JtID09PSBSdW5uYWJsZS5wcm90b3R5cGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kUnVubmFibGVJc0RlZmF1bHRJbXBsZW1lbnRhdGlvbiA9IFJ1bm5hYmxlQmluZGluZy5pc1J1bm5hYmxlQmluZGluZyhzdGVwKSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGVwLmJvdW5kPy50cmFuc2Zvcm0gPT09IFJ1bm5hYmxlLnByb3RvdHlwZS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc0RlZmF1bHRJbXBsZW1lbnRhdGlvbiB8fCBib3VuZFJ1bm5hYmxlSXNEZWZhdWx0SW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgICAgfSkgLVxuICAgICAgICAgICAgMSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbnZva2VTdGVwcyA9IHN0ZXBzLnNsaWNlKDAsIHN0cmVhbWluZ1N0YXJ0U3RlcEluZGV4KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW52b2tlU3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gaW52b2tlU3RlcHNbaV07XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBJbnB1dCA9IGF3YWl0IHN0ZXAuaW52b2tlKG5leHRTdGVwSW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnKG9wdGlvbnMsIHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzZXE6c3RlcDoke2kgKyAxfWApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb25jYXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmluYWxHZW5lcmF0b3IgPSBhd2FpdCBzdGVwc1tzdHJlYW1pbmdTdGFydFN0ZXBJbmRleF0uX3N0cmVhbUl0ZXJhdG9yKG5leHRTdGVwSW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnKG9wdGlvbnMsIHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzZXE6c3RlcDoke3N0cmVhbWluZ1N0YXJ0U3RlcEluZGV4ICsgMX1gKSkpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTdGVwcyA9IHN0ZXBzLnNsaWNlKHN0cmVhbWluZ1N0YXJ0U3RlcEluZGV4ICsgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbmFsU3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gZmluYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBmaW5hbEdlbmVyYXRvciA9IGF3YWl0IHN0ZXAudHJhbnNmb3JtKGZpbmFsR2VuZXJhdG9yLCB0aGlzLl9wYXRjaENvbmZpZyhvcHRpb25zLCBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc2VxOnN0ZXA6JHtzdHJlYW1pbmdTdGFydFN0ZXBJbmRleCArIGkgKyAyfWApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZpbmFsR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmNhdFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGZpbmFsT3V0cHV0LmNvbmNhdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KGZpbmFsT3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgfVxuICAgIHBpcGUoY29lcmNlYWJsZSkge1xuICAgICAgICBpZiAoUnVubmFibGVTZXF1ZW5jZS5pc1J1bm5hYmxlU2VxdWVuY2UoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiB0aGlzLm1pZGRsZS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZWFibGUuZmlyc3QsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvZXJjZWFibGUubWlkZGxlLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGxhc3Q6IGNvZXJjZWFibGUubGFzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IFsuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XSxcbiAgICAgICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzUnVubmFibGVTZXF1ZW5jZSh0aGluZykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZy5taWRkbGUpICYmIFJ1bm5hYmxlLmlzUnVubmFibGUodGhpbmcpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBmcm9tKFtmaXJzdCwgLi4ucnVubmFibGVzXSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZmlyc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKGZpcnN0KSxcbiAgICAgICAgICAgIG1pZGRsZTogcnVubmFibGVzLnNsaWNlKDAsIC0xKS5tYXAoX2NvZXJjZVRvUnVubmFibGUpLFxuICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUocnVubmFibGVzW3J1bm5hYmxlcy5sZW5ndGggLSAxXSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1hcENoYWluID0gUnVubmFibGVNYXAuZnJvbSh7XG4gKiAgIGpva2U6IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIikucGlwZShcbiAqICAgICBuZXcgQ2hhdEFudGhyb3BpYyh7fSksXG4gKiAgICksXG4gKiAgIHBvZW06IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIndyaXRlIGEgMi1saW5lIHBvZW0gYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqIH0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFwQ2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhclwiIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZU1hcCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVNYXBcIjtcbiAgICB9XG4gICAgZ2V0U3RlcHNLZXlzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInNjaGVtYVwiLCBcInJ1bm5hYmxlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RlcHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzLnN0ZXBzKSkge1xuICAgICAgICAgICAgdGhpcy5zdGVwc1trZXldID0gX2NvZXJjZVRvUnVubmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVNYXAoeyBzdGVwcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuZ2VyRm9yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyh0aGlzLnN0ZXBzKS5tYXAoYXN5bmMgKFtrZXksIHJ1bm5hYmxlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCB0aGlzLl9wYXRjaENvbmZpZyhvcHRpb25zLCBydW5NYW5hZ2VyPy5nZXRDaGlsZChrZXkpKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIGNhbGxhYmxlLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVMYW1iZGEgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTGFtYmRhXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInNjaGVtYVwiLCBcInJ1bm5hYmxlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShmdW5jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVMYW1iZGEoe1xuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5mdW5jKGlucHV0KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IG91dHB1dC5pbnZva2UoaW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnKGNvbmZpZywgcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIFJ1bm5hYmxlIHRoYXQgY2FuIGZhbGxiYWNrIHRvIG90aGVyIFJ1bm5hYmxlcyBpZiBpdCBmYWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVXaXRoRmFsbGJhY2tzXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInNjaGVtYVwiLCBcInJ1bm5hYmxlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5hYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZhbGxiYWNrc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bm5hYmxlID0gZmllbGRzLnJ1bm5hYmxlO1xuICAgICAgICB0aGlzLmZhbGxiYWNrcyA9IGZpZWxkcy5mYWxsYmFja3M7XG4gICAgfVxuICAgICpydW5uYWJsZXMoKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucnVubmFibGU7XG4gICAgICAgIGZvciAoY29uc3QgZmFsbGJhY2sgb2YgdGhpcy5mYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShvcHRpb25zPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgb3B0aW9ucz8udGFncywgdW5kZWZpbmVkLCBvcHRpb25zPy5tZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCB0aGlzLl9wYXRjaENvbmZpZyhvcHRpb25zLCBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpKSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpO1xuICAgICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKChjb25maWcpID0+IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoY29uZmlnPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgY29uZmlnPy50YWdzLCB1bmRlZmluZWQsIGNvbmZpZz8ubWV0YWRhdGEpKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSkpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gYXdhaXQgcnVubmFibGUuYmF0Y2goaW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+IHRoaXMuX3BhdGNoQ29uZmlnKGNvbmZpZ0xpc3Rbal0sIHJ1bk1hbmFnZXI/LmdldENoaWxkKCkpKSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGkpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0c1tpXSwgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmlyc3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFja3MuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihmaXJzdEVycm9yKSkpO1xuICAgICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cbn1cbi8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSBjb21waWxlciBuZWVkcyBoZWxwIGVsaW1pbmF0aW5nIEVycm9yIGFzIGEgUnVuT3V0cHV0IHR5cGVcbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBjb2VyY2VhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUxhbWJkYSh7IGZ1bmM6IGNvZXJjZWFibGUgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFJ1bm5hYmxlLmlzUnVubmFibGUoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWFibGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvZXJjZWFibGUpICYmIHR5cGVvZiBjb2VyY2VhYmxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcnVubmFibGVzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7XG4gICAgICAgICAgICBzdGVwczogcnVubmFibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBSdW5uYWJsZSwgZnVuY3Rpb24gb3Igb2JqZWN0Llxcbkluc3RlYWQgZ290IGFuIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgfVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBQYXRjaEVycm9yLCBfZGVlcENsb25lLCBpc0ludGVnZXIsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgaGFzVW5kZWZpbmVkLCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBjb25zdCBKc29uUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG5leHBvcnQgY29uc3QgZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xuY29uc3Qgb2JqT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgcmV0dXJuIHRoZSByZW1vdmVkIHZhbHVlLCB0aGlzIGNhbiBiZSB0YXhpbmcgcGVyZm9ybWFuY2Utd2lzZSxcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXG4gICAgICAgIGxldCByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5mcm9tLFxuICAgICAgICB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCB0ZXN0OiBfYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNJbnRlZ2VyKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXQsXG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cbiAqIFJldHVybnMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxuICogQHJldHVybiBUaGUgcmV0cmlldmVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZSwgbXV0YXRlRG9jdW1lbnQgPSB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZSwgaW5kZXggPSAwKSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikge1xuICAgICAgICAgICAgLy8gaXQncyBhIG1vdmUgb3IgY29weSB0byByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBvcGVyYXRpb24uZnJvbSk7IC8vIGdldCB0aGUgdmFsdWUgYnkganNvbi1wb2ludGVyIGluIGBmcm9tYCBmaWVsZFxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgcmVtb3ZlZCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnRlc3QgPSBfYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAvLyBhIHJlbW92ZSBvbiByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIl9nZXRcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBiYWQgb3BlcmF0aW9uICovXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IF9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgbGV0IHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICBsZXQgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IHZhbGlkYXRlRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZihcIn5cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PSBcIl9fcHJvdG9fX1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gXCJwcm90b3R5cGVcIiAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkV4cGVjdGVkIGFuIHVuc2lnbmVkIGJhc2UtMTAgaW50ZWdlciB2YWx1ZSwgbWFraW5nIHRoZSBuZXcgcmVmZXJlbmNlZCB2YWx1ZSB0aGUgYXJyYXkgZWxlbWVudCB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4XCIsIFwiT1BFUkFUSU9OX1BBVEhfSUxMRUdBTF9BUlJBWV9JTkRFWFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gb25seSBwYXJzZSBrZXkgd2hlbiBpdCdzIGFuIGludGVnZXIgZm9yIGBhcnIucHJvcGAgdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gfn5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGhlIHNwZWNpZmllZCBpbmRleCBNVVNUIE5PVCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcIiwgXCJPUEVSQVRJT05fVkFMVUVfT1VUX09GX0JPVU5EU1wiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIG9iamVjdCBhbmQgYHBhdGNoYCAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdG9yKG9wZXJhdGlvbiwgaW5kZXgsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3RcIiwgXCJPUEVSQVRJT05fTk9UX0FOX09CSkVDVFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgaXMgbm90IGEgc3RyaW5nXCIsIFwiT1BFUkFUSU9OX1BBVEhfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoXCIvXCIpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSAmJlxuICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9GUk9NX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9WQUxVRV9SRVFVSVJFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSAmJlxuICAgICAgICBoYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBvcDogXCJfZ2V0XCIsXG4gICAgICAgICAgICAgICAgcGF0aDogb3BlcmF0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy9jbG9uZSBkb2N1bWVudCBhbmQgc2VxdWVuY2Ugc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHRyeSBhcHBseWluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICBhcHBseVBhdGNoKF9kZWVwQ2xvbmUoZG9jdW1lbnQpLCBfZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5leHBvcnQgZnVuY3Rpb24gX2FyZUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4iLCAiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgYmVjYXVzZSBvZiBFU00gaW1wb3J0IGlzc3Vlc1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNy0yMDIyIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZWRcbiAqL1xuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGtleXNba10gPSBcIlwiICsgaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuICogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiAqIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXG4gICAgfVxufVxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4gKiBAcmV0dXJuIHRoZSBFc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoXCIvXCIpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoXCJ+XCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuLyoqXG4gKiBVbmVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIGVzY2FwZWQgcG9pbnRlclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZm9yIChsZXQga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCIgKyBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcbiAgICBpZiAocm9vdCA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBcIi9cIjtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYC8ke3BhdGh9YDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgICAgICAgICAgY29uc3Qgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbbWVzc2FnZV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChgJHtrZXl9OiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbihcIlxcblwiKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgc3VwZXIocGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVyYXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJlZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJlZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTMtMjAyMSBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX2RlZXBDbG9uZSwgX29iamVjdEtleXMsIGVzY2FwZVBhdGhDb21wb25lbnQsIGhhc093blByb3BlcnR5LCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG52YXIgYmVmb3JlRGljdCA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBNaXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYmpcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbn1cbmNsYXNzIE9ic2VydmVySW5mbyB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9ic2VydmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1pcnJvcihvYmopIHtcbiAgICByZXR1cm4gYmVmb3JlRGljdC5nZXQob2JqKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1pcnJvci5vYnNlcnZlcnMuZ2V0KGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKSB7XG4gICAgbWlycm9yLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIuY2FsbGJhY2spO1xufVxuLyoqXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVub2JzZXJ2ZShyb290LCBvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSgpO1xufVxuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3Iob2JqKTtcbiAgICBpZiAoIW1pcnJvcikge1xuICAgICAgICBtaXJyb3IgPSBuZXcgTWlycm9yKG9iaik7XG4gICAgICAgIGJlZm9yZURpY3Quc2V0KG9iaiwgbWlycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9IF9kZWVwQ2xvbmUob2JqKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG51bGw7XG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmFzdENoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IHNldFRpbWVvdXQoZGlydHlDaGVjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvL25vdCBOb2RlXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9ICgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gYW4gb2JzZXJ2ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBhcHBseVBhdGNoKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIucGF0Y2hlcyk7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gb2JzZXJ2ZXIucGF0Y2hlcztcbiAgICBpZiAodGVtcC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLnBhdGNoZXMgPSBbXTtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jYWxsYmFjayh0ZW1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcDtcbn1cbi8vIERpcnR5IGNoZWNrIGlmIG9iaiBpcyBkaWZmZXJlbnQgZnJvbSBtaXJyb3IsIGdlbmVyYXRlIHBhdGNoZXMgYW5kIHVwZGF0ZSBtaXJyb3JcbmZ1bmN0aW9uIF9nZW5lcmF0ZShtaXJyb3IsIG9iaiwgcGF0Y2hlcywgcGF0aCwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChvYmogPT09IG1pcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgdmFyIG5ld0tleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgIHZhciBvbGRLZXlzID0gX29iamVjdEtleXMobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkgJiZcbiAgICAgICAgICAgICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBvbGRWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZXdWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG5ld1ZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvbGRWYWwpID09PSBBcnJheS5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgaW52ZXJ0aWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUob2xkVmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShuZXdWYWwpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKG9sZFZhbCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShvYmpba2V5XSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUodHJlZTEsIHRyZWUyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIF9nZW5lcmF0ZSh0cmVlMSwgdHJlZTIsIHBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIHJldHVybiBwYXRjaGVzO1xufVxuIiwgImV4cG9ydCAqIGZyb20gXCIuL3NyYy9jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zcmMvZHVwbGV4LmpzXCI7XG5leHBvcnQgeyBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLCBfZGVlcENsb25lIGFzIGRlZXBDbG9uZSwgZXNjYXBlUGF0aENvbXBvbmVudCwgdW5lc2NhcGVQYXRoQ29tcG9uZW50LCB9IGZyb20gXCIuL3NyYy9oZWxwZXJzLmpzXCI7XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vc3JjL2NvcmUuanNcIjtcbmltcG9ydCB7IFBhdGNoRXJyb3IgYXMgSnNvblBhdGNoRXJyb3IsIF9kZWVwQ2xvbmUgYXMgZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50LCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIH0gZnJvbSBcIi4vc3JjL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAuLi5jb3JlLFxuICAgIC8vIC4uLmR1cGxleCxcbiAgICBKc29uUGF0Y2hFcnJvcixcbiAgICBkZWVwQ2xvbmUsXG4gICAgZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQsXG59O1xuIiwgIi8qXG4gKiBTdXBwb3J0IGFzeW5jIGl0ZXJhdG9yIHN5bnRheCBmb3IgUmVhZGFibGVTdHJlYW1zIGluIGFsbCBlbnZpcm9ubWVudHMuXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5leHBvcnQgY2xhc3MgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSBleHRlbmRzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVhZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuc3VyZVJlYWRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRvbmU6IHJlc3VsdC5kb25lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsIC8vIENsb3VkZmxhcmUgV29ya2VycyB0eXBpbmcgZml4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07IC8vIFRoaXMgY2FzdCBmaXhlcyBUUyB0eXBpbmcsIGFuZCBjb252ZW50aW9uIGlzIHRvIGlnbm9yZSBmaW5hbCBjaHVuayB2YWx1ZSBhbnl3YXlcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N0cmVhbXNfQVBJL1VzaW5nX3JlYWRhYmxlX3N0cmVhbXMjcmVhZGluZ190aGVfc3RyZWFtXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVucXVldWUgdGhlIG5leHQgZGF0YSBjaHVuayBpbnRvIG91ciB0YXJnZXQgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFzeW5jR2VuZXJhdG9yKGdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgZ2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRml4OiBgZWxzZSBpZiAodmFsdWUpYCB3aWxsIGhhbmcgdGhlIHN0cmVhbWluZyB3aGVuIG51bGxpc2ggdmFsdWUgKGUuZy4gZW1wdHkgc3RyaW5nKSBpcyBwdWxsZWRcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGFwcGx5UGF0Y2gsIH0gZnJvbSBcIi4uLy4uL3V0aWwvZmFzdC1qc29uLXBhdGNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vdHJhY2VyLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uLy4uL3V0aWwvc3RyZWFtLmpzXCI7XG4vKipcbiAqIExpc3Qgb2YganNvbnBhdGNoIEpTT05QYXRjaE9wZXJhdGlvbnMsIHdoaWNoIGRlc2NyaWJlIGhvdyB0byBjcmVhdGUgdGhlIHJ1biBzdGF0ZVxuICogZnJvbSBhbiBlbXB0eSBkaWN0LiBUaGlzIGlzIHRoZSBtaW5pbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsb2csIGRlc2lnbmVkIHRvXG4gKiBiZSBzZXJpYWxpemVkIGFzIEpTT04gYW5kIHNlbnQgb3ZlciB0aGUgd2lyZSB0byByZWNvbnN0cnVjdCB0aGUgbG9nIG9uIHRoZSBvdGhlclxuICogc2lkZS4gUmVjb25zdHJ1Y3Rpb24gb2YgdGhlIHN0YXRlIGNhbiBiZSBkb25lIHdpdGggYW55IGpzb25wYXRjaC1jb21wbGlhbnQgbGlicmFyeSxcbiAqIHNlZSBodHRwczovL2pzb25wYXRjaC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5Mb2dQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wcyA9IGZpZWxkcy5vcHM7XG4gICAgfVxuICAgIGNvbmNhdChvdGhlcikge1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcy5jb25jYXQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gYXBwbHlQYXRjaCh7fSwgb3BzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bkxvZyh7XG4gICAgICAgICAgICBvcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bkxvZyBleHRlbmRzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGZpZWxkcy5zdGF0ZTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHRoaXMuc3RhdGUsIG90aGVyLm9wcyk7XG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHsgb3BzLCBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCB9KTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlNYXBCeVJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY291bnRlck1hcEJ5UnVuTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxvZ19zdHJlYW1fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0b0Nsb3NlID0gZmllbGRzPy5hdXRvQ2xvc2UgPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHM/LmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHM/LmluY2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9IGZpZWxkcz8uaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzPy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzPy5leGNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhZ3MgPSBmaWVsZHM/LmV4Y2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB0aGlzLnRyYW5zZm9ybVN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlU3RyZWFtID0gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0odGhpcy50cmFuc2Zvcm1TdHJlYW0ucmVhZGFibGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlU3RyZWFtO1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBtZXRob2Qgb25seSBjYWxsZWQgb25jZSBmb3IgYW4gZW50aXJlIHJ1biB0cmVlXG4gICAgICAgIC8vIGFuZCBpcyB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgfVxuICAgIF9pbmNsdWRlUnVuKHJ1bikge1xuICAgICAgICBpZiAocnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fFxuICAgICAgICAgICAgICAgICAgICBydW5UYWdzLmZpbmQoKHRhZykgPT4gdGhpcy5pbmNsdWRlVGFncz8uaW5jbHVkZXModGFnKSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBydW5UYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5DcmVhdGUocnVuKSB7XG4gICAgICAgIGlmIChydW4ucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxfb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbmNsdWRlUnVuKHJ1bikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdICs9IDE7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXTtcbiAgICAgICAgdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF0gPVxuICAgICAgICAgICAgY291bnQgPT09IDEgPyBydW4ubmFtZSA6IGAke3J1bi5uYW1lfToke2NvdW50fWA7XG4gICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKHJ1bi5zdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0X3N0cjogW10sXG4gICAgICAgICAgICBmaW5hbF9vdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZF90aW1lOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHt0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXX1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9nRW50cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2ZpbmFsX291dHB1dGAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChydW4uZW5kX3RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2VuZF90aW1lYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHsgb3BzIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHJ1bi5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9maW5hbF9vdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1OZXdUb2tlbihydW4sIHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXTtcbiAgICAgICAgaWYgKHJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dF9zdHIvLWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyLCB9IGZyb20gXCIuLi8uLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxiYWNrTWFuZ2VyRm9yQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGNvbmZpZz8uY2FsbGJhY2tzLCB1bmRlZmluZWQsIGNvbmZpZz8udGFncywgdW5kZWZpbmVkLCBjb25maWc/Lm1ldGFkYXRhKTtcbn1cbiIsICJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLFxuICAgIDQwMSxcbiAgICA0MDIsXG4gICAgNDAzLFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDA2LFxuICAgIDQwNyxcbiAgICA0MDgsXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXIgPSAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlRpbWVvdXRFcnJvclwiKSB8fFxuICAgICAgICBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikgfHxcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVycm9yPy5yZXNwb25zZT8uc3RhdHVzID8/IGVycm9yPy5zdGF0dXM7XG4gICAgaWYgKHN0YXR1cyAmJiBTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5lcnJvcj8uY29kZSA9PT0gXCJpbnN1ZmZpY2llbnRfcXVvdGFcIikge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgICBlcnIubmFtZSA9IFwiSW5zdWZmaWNpZW50UXVvdGFFcnJvclwiO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRBdHRlbXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIHRoaXMub25GYWlsZWRBdHRlbXB0ID1cbiAgICAgICAgICAgIHBhcmFtcy5vbkZhaWxlZEF0dGVtcHQgPz8gZGVmYXVsdEZhaWxlZEF0dGVtcHRIYW5kbGVyO1xuICAgICAgICBjb25zdCBQUXVldWUgPSBcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QgPyBQUXVldWVNb2QuZGVmYXVsdCA6IFBRdWV1ZU1vZDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogdGhpcy5vbkZhaWxlZEF0dGVtcHQsXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2goLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyLCBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGUgfSBmcm9tIFwiLi9ydW5uYWJsZS9pbmRleC5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhIERvY3VtZW50IHJldHJpZXZhbCBzeXN0ZW0uIEEgcmV0cmlldmFsIHN5c3RlbVxuICogaXMgZGVmaW5lZCBhcyBzb21ldGhpbmcgdGhhdCBjYW4gdGFrZSBzdHJpbmcgcXVlcmllcyBhbmQgcmV0dXJuIHRoZVxuICogbW9zdCAncmVsZXZhbnQnIERvY3VtZW50cyBmcm9tIHNvbWUgc291cmNlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVJldHJpZXZlciBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGZpZWxkcz8uY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnRhZ3MgPSBmaWVsZHM/LnRhZ3MgPz8gW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHM/Lm1ldGFkYXRhID8/IHt9O1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBmaWVsZHM/LnZlcmJvc2UgPz8gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgc2hvdWxkIGJlIGFuIGFic3RyYWN0IG1ldGhvZCwgYnV0IHdlJ2QgbGlrZSB0byBhdm9pZCBicmVha2luZ1xuICAgICAqIGNoYW5nZXMgdG8gcGVvcGxlIGN1cnJlbnRseSB1c2luZyBzdWJjbGFzc2VkIGN1c3RvbSByZXRyaWV2ZXJzLlxuICAgICAqIENoYW5nZSBpdCBvbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICovXG4gICAgX2dldFJlbGV2YW50RG9jdW1lbnRzKF9xdWVyeSwgX2NhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQhXCIpO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVsZXZhbnREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIG1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHJlbGV2YW50IGRvY3VtZW50cy4gSXQgdGFrZXMgYSBxdWVyeVxuICAgICAqIHN0cmluZyBhbmQgYW4gb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYERvY3VtZW50YCBvYmplY3RzLiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZVxuICAgICAqIHJldHJpZXZhbCBwcm9jZXNzLCBpbmNsdWRpbmcgc3RhcnRpbmcgYW5kIGVuZGluZyBjYWxsYmFja3MsIGFuZCBlcnJvclxuICAgICAqIGhhbmRsaW5nLlxuICAgICAqIEBwYXJhbSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRvIHJldHJpZXZlIHJlbGV2YW50IGRvY3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHJldHJpZXZhbCBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudGAgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZWxldmFudERvY3VtZW50cyhxdWVyeSwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZENvbmZpZyA9IHBhcnNlQ2FsbGJhY2tDb25maWdBcmcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUocGFyc2VkQ29uZmlnLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIHBhcnNlZENvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIHBhcnNlZENvbmZpZy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVSZXRyaWV2ZXJTdGFydCh0aGlzLnRvSlNPTigpLCBxdWVyeSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwYXJzZWRDb25maWcucnVuTmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2V0UmVsZXZhbnREb2N1bWVudHMocXVlcnksIHJ1bk1hbmFnZXIpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlUmV0cmlldmVyRW5kKHJlc3VsdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBCYXNlUmV0cmlldmVyIH0gZnJvbSBcIi4uL3NjaGVtYS9yZXRyaWV2ZXIuanNcIjtcbmltcG9ydCB7IFNlcmlhbGl6YWJsZSB9IGZyb20gXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuLyoqXG4gKiBDbGFzcyBmb3IgcGVyZm9ybWluZyBkb2N1bWVudCByZXRyaWV2YWwgZnJvbSBhIFZlY3RvclN0b3JlLiBDYW4gcGVyZm9ybVxuICogc2ltaWxhcml0eSBzZWFyY2ggb3IgbWF4aW1hbCBtYXJnaW5hbCByZWxldmFuY2Ugc2VhcmNoLlxuICovXG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVSZXRyaWV2ZXIgZXh0ZW5kcyBCYXNlUmV0cmlldmVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVmVjdG9yU3RvcmVSZXRyaWV2ZXJcIjtcbiAgICB9XG4gICAgZ2V0IGxjX25hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcImxhbmdjaGFpblwiLCBcInJldHJpZXZlcnNcIiwgXCJiYXNlXCJdO1xuICAgIH1cbiAgICBfdmVjdG9yc3RvcmVUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JTdG9yZS5fdmVjdG9yc3RvcmVUeXBlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZWN0b3JTdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA0XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWFyY2hUeXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInNpbWlsYXJpdHlcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VhcmNoS3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZlY3RvclN0b3JlID0gZmllbGRzLnZlY3RvclN0b3JlO1xuICAgICAgICB0aGlzLmsgPSBmaWVsZHMuayA/PyB0aGlzLms7XG4gICAgICAgIHRoaXMuc2VhcmNoVHlwZSA9IGZpZWxkcy5zZWFyY2hUeXBlID8/IHRoaXMuc2VhcmNoVHlwZTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWVsZHMuZmlsdGVyO1xuICAgICAgICBpZiAoZmllbGRzLnNlYXJjaFR5cGUgPT09IFwibW1yXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoS3dhcmdzID0gZmllbGRzLnNlYXJjaEt3YXJncztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVsZXZhbnREb2N1bWVudHMocXVlcnksIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VhcmNoVHlwZSA9PT0gXCJtbXJcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZlY3RvclN0b3JlLm1heE1hcmdpbmFsUmVsZXZhbmNlU2VhcmNoICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2ZWN0b3Igc3RvcmUgYmFja2luZyB0aGlzIHJldHJpZXZlciwgJHt0aGlzLl92ZWN0b3JzdG9yZVR5cGUoKX0gZG9lcyBub3Qgc3VwcG9ydCBtYXggbWFyZ2luYWwgcmVsZXZhbmNlIHNlYXJjaC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlY3RvclN0b3JlLm1heE1hcmdpbmFsUmVsZXZhbmNlU2VhcmNoKHF1ZXJ5LCB7XG4gICAgICAgICAgICAgICAgazogdGhpcy5rLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5zZWFyY2hLd2FyZ3MsXG4gICAgICAgICAgICB9LCBydW5NYW5hZ2VyPy5nZXRDaGlsZChcInZlY3RvcnN0b3JlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JTdG9yZS5zaW1pbGFyaXR5U2VhcmNoKHF1ZXJ5LCB0aGlzLmssIHRoaXMuZmlsdGVyLCBydW5NYW5hZ2VyPy5nZXRDaGlsZChcInZlY3RvcnN0b3JlXCIpKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkRG9jdW1lbnRzKGRvY3VtZW50cywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JTdG9yZS5hZGREb2N1bWVudHMoZG9jdW1lbnRzLCBvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHJlcHJlc2VudGluZyBhIHN0b3JlIG9mIHZlY3RvcnMuIFByb3ZpZGVzIG1ldGhvZHMgZm9yXG4gKiBhZGRpbmcgdmVjdG9ycyBhbmQgZG9jdW1lbnRzLCBkZWxldGluZyBmcm9tIHRoZSBzdG9yZSwgYW5kIHNlYXJjaGluZ1xuICogdGhlIHN0b3JlLlxuICovXG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmUgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoZW1iZWRkaW5ncywgZGJDb25maWcpIHtcbiAgICAgICAgc3VwZXIoZGJDb25maWcpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInZlY3RvcnN0b3Jlc1wiLCB0aGlzLl92ZWN0b3JzdG9yZVR5cGUoKV1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVtYmVkZGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdzID0gZW1iZWRkaW5ncztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBkZWxldGUoX3BhcmFtcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaW1pbGFyaXR5U2VhcmNoKHF1ZXJ5LCBrID0gNCwgZmlsdGVyID0gdW5kZWZpbmVkLCBfY2FsbGJhY2tzID0gdW5kZWZpbmVkIC8vIGltcGxlbWVudCBwYXNzaW5nIHRvIGVtYmVkUXVlcnkgbGF0ZXJcbiAgICApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2ltaWxhcml0eVNlYXJjaFZlY3RvcldpdGhTY29yZShhd2FpdCB0aGlzLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShxdWVyeSksIGssIGZpbHRlcik7XG4gICAgICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHRbMF0pO1xuICAgIH1cbiAgICBhc3luYyBzaW1pbGFyaXR5U2VhcmNoV2l0aFNjb3JlKHF1ZXJ5LCBrID0gNCwgZmlsdGVyID0gdW5kZWZpbmVkLCBfY2FsbGJhY2tzID0gdW5kZWZpbmVkIC8vIGltcGxlbWVudCBwYXNzaW5nIHRvIGVtYmVkUXVlcnkgbGF0ZXJcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltaWxhcml0eVNlYXJjaFZlY3RvcldpdGhTY29yZShhd2FpdCB0aGlzLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShxdWVyeSksIGssIGZpbHRlcik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVGV4dHMoX3RleHRzLCBfbWV0YWRhdGFzLCBfZW1iZWRkaW5ncywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfZGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhlIExhbmdjaGFpbiB2ZWN0b3JzdG9yZSBpbXBsZW1lbnRhdGlvbiB5b3UgYXJlIHVzaW5nIGZvcmdvdCB0byBvdmVycmlkZSB0aGlzLCBwbGVhc2UgcmVwb3J0IGEgYnVnXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURvY3VtZW50cyhfZG9jcywgX2VtYmVkZGluZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2RiQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoZSBMYW5nY2hhaW4gdmVjdG9yc3RvcmUgaW1wbGVtZW50YXRpb24geW91IGFyZSB1c2luZyBmb3Jnb3QgdG8gb3ZlcnJpZGUgdGhpcywgcGxlYXNlIHJlcG9ydCBhIGJ1Z1wiKTtcbiAgICB9XG4gICAgYXNSZXRyaWV2ZXIoa09yRmllbGRzLCBmaWx0ZXIsIGNhbGxiYWNrcywgdGFncywgbWV0YWRhdGEsIHZlcmJvc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrT3JGaWVsZHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yU3RvcmVSZXRyaWV2ZXIoe1xuICAgICAgICAgICAgICAgIHZlY3RvclN0b3JlOiB0aGlzLFxuICAgICAgICAgICAgICAgIGs6IGtPckZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgdGFnczogWy4uLih0YWdzID8/IFtdKSwgdGhpcy5fdmVjdG9yc3RvcmVUeXBlKCldLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHZlcmJvc2UsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdmVjdG9yU3RvcmU6IHRoaXMsXG4gICAgICAgICAgICAgICAgazoga09yRmllbGRzPy5rLFxuICAgICAgICAgICAgICAgIGZpbHRlcjoga09yRmllbGRzPy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgdGFnczogWy4uLihrT3JGaWVsZHM/LnRhZ3MgPz8gW10pLCB0aGlzLl92ZWN0b3JzdG9yZVR5cGUoKV0sXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IGtPckZpZWxkcz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgdmVyYm9zZToga09yRmllbGRzPy52ZXJib3NlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrczoga09yRmllbGRzPy5jYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgc2VhcmNoVHlwZToga09yRmllbGRzPy5zZWFyY2hUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChrT3JGaWVsZHM/LnNlYXJjaFR5cGUgPT09IFwibW1yXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvclN0b3JlUmV0cmlldmVyKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hLd2FyZ3M6IGtPckZpZWxkcy5zZWFyY2hLd2FyZ3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvclN0b3JlUmV0cmlldmVyKHsgLi4ucGFyYW1zIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBleHRlbmRpbmcgVmVjdG9yU3RvcmUgd2l0aCBmdW5jdGlvbmFsaXR5IGZvciBzYXZpbmcgYW5kXG4gKiBsb2FkaW5nIHRoZSB2ZWN0b3Igc3RvcmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYXZlYWJsZVZlY3RvclN0b3JlIGV4dGVuZHMgVmVjdG9yU3RvcmUge1xuICAgIHN0YXRpYyBsb2FkKF9kaXJlY3RvcnksIF9lbWJlZGRpbmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggYSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIERvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFnZUNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYWdlQ29udGVudCA9IGZpZWxkcy5wYWdlQ29udGVudFxuICAgICAgICAgICAgPyBmaWVsZHMucGFnZUNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgOiB0aGlzLnBhZ2VDb250ZW50O1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gZmllbGRzLm1ldGFkYXRhID8/IHt9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBzaW1pbGFyaXR5IGFzIG1sX2Rpc3RhbmNlX3NpbWlsYXJpdHkgfSBmcm9tIFwibWwtZGlzdGFuY2VcIjtcbmltcG9ydCB7IFZlY3RvclN0b3JlIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tIFwiLi4vZG9jdW1lbnQuanNcIjtcbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIGBWZWN0b3JTdG9yZWAgdG8gc3RvcmUgdmVjdG9ycyBpbiBtZW1vcnkuIFByb3ZpZGVzXG4gKiBtZXRob2RzIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBwZXJmb3JtaW5nIHNpbWlsYXJpdHkgc2VhcmNoZXMsIGFuZFxuICogY3JlYXRpbmcgaW5zdGFuY2VzIGZyb20gdGV4dHMsIGRvY3VtZW50cywgb3IgYW4gZXhpc3RpbmcgaW5kZXguXG4gKi9cbmV4cG9ydCBjbGFzcyBNZW1vcnlWZWN0b3JTdG9yZSBleHRlbmRzIFZlY3RvclN0b3JlIHtcbiAgICBfdmVjdG9yc3RvcmVUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJtZW1vcnlcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZW1iZWRkaW5ncywgeyBzaW1pbGFyaXR5LCAuLi5yZXN0IH0gPSB7fSkge1xuICAgICAgICBzdXBlcihlbWJlZGRpbmdzLCByZXN0KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVtb3J5VmVjdG9yc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpbWlsYXJpdHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaW1pbGFyaXR5ID0gc2ltaWxhcml0eSA/PyBtbF9kaXN0YW5jZV9zaW1pbGFyaXR5LmNvc2luZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGFkZCBkb2N1bWVudHMgdG8gdGhlIG1lbW9yeSB2ZWN0b3Igc3RvcmUuIEl0IGV4dHJhY3RzIHRoZVxuICAgICAqIHRleHQgZnJvbSBlYWNoIGRvY3VtZW50LCBnZW5lcmF0ZXMgZW1iZWRkaW5ncyBmb3IgdGhlbSwgYW5kIGFkZHMgdGhlXG4gICAgICogcmVzdWx0aW5nIHZlY3RvcnMgdG8gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgQXJyYXkgb2YgYERvY3VtZW50YCBpbnN0YW5jZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHN0b3JlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBkb2N1bWVudHMgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZERvY3VtZW50cyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgdGV4dHMgPSBkb2N1bWVudHMubWFwKCh7IHBhZ2VDb250ZW50IH0pID0+IHBhZ2VDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyhhd2FpdCB0aGlzLmVtYmVkZGluZ3MuZW1iZWREb2N1bWVudHModGV4dHMpLCBkb2N1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYWRkIHZlY3RvcnMgdG8gdGhlIG1lbW9yeSB2ZWN0b3Igc3RvcmUuIEl0IGNyZWF0ZXNcbiAgICAgKiBgTWVtb3J5VmVjdG9yYCBpbnN0YW5jZXMgZm9yIGVhY2ggdmVjdG9yIGFuZCBkb2N1bWVudCBwYWlyIGFuZCBhZGRzXG4gICAgICogdGhlbSB0byB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIHZlY3RvcnMgQXJyYXkgb2YgdmVjdG9ycyB0byBiZSBhZGRlZCB0byB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBBcnJheSBvZiBgRG9jdW1lbnRgIGluc3RhbmNlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2ZWN0b3JzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCB2ZWN0b3JzIGhhdmUgYmVlbiBhZGRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRWZWN0b3JzKHZlY3RvcnMsIGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCBtZW1vcnlWZWN0b3JzID0gdmVjdG9ycy5tYXAoKGVtYmVkZGluZywgaWR4KSA9PiAoe1xuICAgICAgICAgICAgY29udGVudDogZG9jdW1lbnRzW2lkeF0ucGFnZUNvbnRlbnQsXG4gICAgICAgICAgICBlbWJlZGRpbmcsXG4gICAgICAgICAgICBtZXRhZGF0YTogZG9jdW1lbnRzW2lkeF0ubWV0YWRhdGEsXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5tZW1vcnlWZWN0b3JzID0gdGhpcy5tZW1vcnlWZWN0b3JzLmNvbmNhdChtZW1vcnlWZWN0b3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHBlcmZvcm0gYSBzaW1pbGFyaXR5IHNlYXJjaCBpbiB0aGUgbWVtb3J5IHZlY3RvciBzdG9yZS4gSXRcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gdGhlIHF1ZXJ5IHZlY3RvciBhbmQgZWFjaCB2ZWN0b3IgaW5cbiAgICAgKiB0aGUgc3RvcmUsIHNvcnRzIHRoZSByZXN1bHRzIGJ5IHNpbWlsYXJpdHksIGFuZCByZXR1cm5zIHRoZSB0b3AgYGtgXG4gICAgICogcmVzdWx0cyBhbG9uZyB3aXRoIHRoZWlyIHNjb3Jlcy5cbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgdmVjdG9yIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgdmVjdG9ycyBpbiB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGsgTnVtYmVyIG9mIHRvcCByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIE9wdGlvbmFsIGZpbHRlciBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmVjdG9ycyBiZWZvcmUgcGVyZm9ybWluZyB0aGUgc2VhcmNoLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIHR1cGxlcywgZWFjaCBjb250YWluaW5nIGEgYERvY3VtZW50YCBhbmQgaXRzIHNpbWlsYXJpdHkgc2NvcmUuXG4gICAgICovXG4gICAgYXN5bmMgc2ltaWxhcml0eVNlYXJjaFZlY3RvcldpdGhTY29yZShxdWVyeSwgaywgZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlckZ1bmN0aW9uID0gKG1lbW9yeVZlY3RvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1lbW9yeVZlY3Rvci5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBwYWdlQ29udGVudDogbWVtb3J5VmVjdG9yLmNvbnRlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoZG9jKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNZW1vcnlWZWN0b3JzID0gdGhpcy5tZW1vcnlWZWN0b3JzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVzID0gZmlsdGVyZWRNZW1vcnlWZWN0b3JzXG4gICAgICAgICAgICAubWFwKCh2ZWN0b3IsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgc2ltaWxhcml0eTogdGhpcy5zaW1pbGFyaXR5KHF1ZXJ5LCB2ZWN0b3IuZW1iZWRkaW5nKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiAoYS5zaW1pbGFyaXR5ID4gYi5zaW1pbGFyaXR5ID8gLTEgOiAwKSlcbiAgICAgICAgICAgIC5zbGljZSgwLCBrKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VhcmNoZXMubWFwKChzZWFyY2gpID0+IFtcbiAgICAgICAgICAgIG5ldyBEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IGZpbHRlcmVkTWVtb3J5VmVjdG9yc1tzZWFyY2guaW5kZXhdLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiBmaWx0ZXJlZE1lbW9yeVZlY3RvcnNbc2VhcmNoLmluZGV4XS5jb250ZW50LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzZWFyY2guc2ltaWxhcml0eSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gY3JlYXRlIGEgYE1lbW9yeVZlY3RvclN0b3JlYCBpbnN0YW5jZSBmcm9tIGFuIGFycmF5IG9mXG4gICAgICogdGV4dHMuIEl0IGNyZWF0ZXMgYSBgRG9jdW1lbnRgIGZvciBlYWNoIHRleHQgYW5kIG1ldGFkYXRhIHBhaXIsIGFuZFxuICAgICAqIGFkZHMgdGhlbSB0byB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIHRleHRzIEFycmF5IG9mIHRleHRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFzIEFycmF5IG9yIHNpbmdsZSBvYmplY3Qgb2YgbWV0YWRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgdGV4dHMuXG4gICAgICogQHBhcmFtIGVtYmVkZGluZ3MgYEVtYmVkZGluZ3NgIGluc3RhbmNlIHVzZWQgdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgdGhlIHRleHRzLlxuICAgICAqIEBwYXJhbSBkYkNvbmZpZyBPcHRpb25hbCBgTWVtb3J5VmVjdG9yU3RvcmVBcmdzYCB0byBjb25maWd1cmUgdGhlIGBNZW1vcnlWZWN0b3JTdG9yZWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBuZXcgYE1lbW9yeVZlY3RvclN0b3JlYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVRleHRzKHRleHRzLCBtZXRhZGF0YXMsIGVtYmVkZGluZ3MsIGRiQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBBcnJheS5pc0FycmF5KG1ldGFkYXRhcykgPyBtZXRhZGF0YXNbaV0gOiBtZXRhZGF0YXM7XG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBuZXcgRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiB0ZXh0c1tpXSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jcy5wdXNoKG5ld0RvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1lbW9yeVZlY3RvclN0b3JlLmZyb21Eb2N1bWVudHMoZG9jcywgZW1iZWRkaW5ncywgZGJDb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGNyZWF0ZSBhIGBNZW1vcnlWZWN0b3JTdG9yZWAgaW5zdGFuY2UgZnJvbSBhbiBhcnJheSBvZlxuICAgICAqIGBEb2N1bWVudGAgaW5zdGFuY2VzLiBJdCBhZGRzIHRoZSBkb2N1bWVudHMgdG8gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBkb2NzIEFycmF5IG9mIGBEb2N1bWVudGAgaW5zdGFuY2VzIHRvIGJlIGFkZGVkIHRvIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gZW1iZWRkaW5ncyBgRW1iZWRkaW5nc2AgaW5zdGFuY2UgdXNlZCB0byBnZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBkYkNvbmZpZyBPcHRpb25hbCBgTWVtb3J5VmVjdG9yU3RvcmVBcmdzYCB0byBjb25maWd1cmUgdGhlIGBNZW1vcnlWZWN0b3JTdG9yZWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBuZXcgYE1lbW9yeVZlY3RvclN0b3JlYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbURvY3VtZW50cyhkb2NzLCBlbWJlZGRpbmdzLCBkYkNvbmZpZykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyB0aGlzKGVtYmVkZGluZ3MsIGRiQ29uZmlnKTtcbiAgICAgICAgYXdhaXQgaW5zdGFuY2UuYWRkRG9jdW1lbnRzKGRvY3MpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gY3JlYXRlIGEgYE1lbW9yeVZlY3RvclN0b3JlYCBpbnN0YW5jZSBmcm9tIGFuIGV4aXN0aW5nXG4gICAgICogaW5kZXguIEl0IGNyZWF0ZXMgYSBuZXcgYE1lbW9yeVZlY3RvclN0b3JlYCBpbnN0YW5jZSB3aXRob3V0IGFkZGluZyBhbnlcbiAgICAgKiBkb2N1bWVudHMgb3IgdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gZW1iZWRkaW5ncyBgRW1iZWRkaW5nc2AgaW5zdGFuY2UgdXNlZCB0byBnZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBkYkNvbmZpZyBPcHRpb25hbCBgTWVtb3J5VmVjdG9yU3RvcmVBcmdzYCB0byBjb25maWd1cmUgdGhlIGBNZW1vcnlWZWN0b3JTdG9yZWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBuZXcgYE1lbW9yeVZlY3RvclN0b3JlYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUV4aXN0aW5nSW5kZXgoZW1iZWRkaW5ncywgZGJDb25maWcpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgdGhpcyhlbWJlZGRpbmdzLCBkYkNvbmZpZyk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgKiBhcyBzaGltcyBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG5pbXBvcnQgKiBhcyBhdXRvIGZyb20gJ29wZW5haS9fc2hpbXMvYXV0by9ydW50aW1lJztcbmlmICghc2hpbXMua2luZCkgc2hpbXMuc2V0U2hpbXMoYXV0by5nZXRSdW50aW1lKCksIHsgYXV0bzogdHJ1ZSB9KTtcbmV4cG9ydCAqIGZyb20gJy4vcmVnaXN0cnkubWpzJztcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJleHBvcnQgY29uc3QgY2h1bmtBcnJheSA9IChhcnIsIGNodW5rU2l6ZSkgPT4gYXJyLnJlZHVjZSgoY2h1bmtzLCBlbGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gY2h1bmtTaXplKTtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tjaHVua0luZGV4XSB8fCBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBjaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5jb25jYXQoW2VsZW1dKTtcbiAgICByZXR1cm4gY2h1bmtzO1xufSwgW10pO1xuIiwgImltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4uL3V0aWwvYXN5bmNfY2FsbGVyLmpzXCI7XG4vKipcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW1iZWRkaW5nIGRvY3VtZW50cyBhbmRcbiAqIHF1ZXJpZXMgdXNpbmcgTGFuZ0NoYWluLlxuICovXG5leHBvcnQgY2xhc3MgRW1iZWRkaW5ncyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXN5bmMgY2FsbGVyIHNob3VsZCBiZSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gbWFrZSBhbnkgYXN5bmMgY2FsbHMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgdGh1cyBiZW5lZml0IGZyb20gdGhlIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihwYXJhbXMgPz8ge30pO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGFuIGVuZHBvaW50IFVSTCBmb3IgKEF6dXJlKSBPcGVuQUlcbiAqIGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIHtPcGVuQUlFbmRwb2ludENvbmZpZ30gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgKEF6dXJlKSBlbmRwb2ludC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29uZmlnLmF6dXJlT3BlbkFJQXBpRGVwbG95bWVudE5hbWUgLSBUaGUgZGVwbG95bWVudCBuYW1lIG9mIEF6dXJlIE9wZW5BSS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb25maWcuYXp1cmVPcGVuQUlBcGlJbnN0YW5jZU5hbWUgLSBUaGUgaW5zdGFuY2UgbmFtZSBvZiBBenVyZSBPcGVuQUkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29uZmlnLmF6dXJlT3BlbkFJQXBpS2V5IC0gVGhlIEFQSSBLZXkgZm9yIEF6dXJlIE9wZW5BSS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb25maWcuYXp1cmVPcGVuQUlCYXNlUGF0aCAtIFRoZSBiYXNlIHBhdGggZm9yIEF6dXJlIE9wZW5BSS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb25maWcuYmFzZVVSTCAtIFNvbWUgb3RoZXIgY3VzdG9tIGJhc2UgcGF0aCBVUkwuXG4gKlxuICogVGhlIGZ1bmN0aW9uIG9wZXJhdGVzIGFzIGZvbGxvd3M6XG4gKiAtIElmIGJvdGggYGF6dXJlT3BlbkFJQmFzZVBhdGhgIGFuZCBgYXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZWAgKHBsdXMgYGF6dXJlT3BlbkFJQXBpS2V5YCkgYXJlIHByb3ZpZGVkLCBpdCByZXR1cm5zIGFuIFVSTCBjb21iaW5pbmcgdGhlc2UgdHdvIHBhcmFtZXRlcnMgKGAke2F6dXJlT3BlbkFJQmFzZVBhdGh9LyR7YXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZX1gKS5cbiAqIC0gSWYgYGF6dXJlT3BlbkFJQXBpS2V5YCBpcyBwcm92aWRlZCwgaXQgY2hlY2tzIGZvciBgYXp1cmVPcGVuQUlBcGlJbnN0YW5jZU5hbWVgIGFuZCBgYXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZWAgYW5kIHRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlc2UgaXMgbWlzc2luZy4gSWYgYm90aCBhcmUgcHJvdmlkZWQsIGl0IGdlbmVyYXRlcyBhbiBVUkwgaW5jb3Jwb3JhdGluZyB0aGVzZSBwYXJhbWV0ZXJzLlxuICogLSBJZiBub25lIG9mIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZSBtZXQsIHJldHVybiBhbnkgY3VzdG9tIGBiYXNlVVJMYC5cbiAqIC0gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIGdlbmVyYXRlZCBVUkwgYXMgYSBzdHJpbmcsIG9yIHVuZGVmaW5lZCBpZiBubyBjdXN0b20gcGF0aHMgYXJlIHNwZWNpZmllZC5cbiAqXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHRoZSBVUkwgYXJlIG1pc3NpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIGdlbmVyYXRlZCAoQXp1cmUpIE9wZW5BSSBlbmRwb2ludCBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmRwb2ludChjb25maWcpIHtcbiAgICBjb25zdCB7IGF6dXJlT3BlbkFJQXBpRGVwbG95bWVudE5hbWUsIGF6dXJlT3BlbkFJQXBpSW5zdGFuY2VOYW1lLCBhenVyZU9wZW5BSUFwaUtleSwgYXp1cmVPcGVuQUlCYXNlUGF0aCwgYmFzZVVSTCwgfSA9IGNvbmZpZztcbiAgICBpZiAoYXp1cmVPcGVuQUlBcGlLZXkgJiZcbiAgICAgICAgYXp1cmVPcGVuQUlCYXNlUGF0aCAmJlxuICAgICAgICBhenVyZU9wZW5BSUFwaURlcGxveW1lbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHthenVyZU9wZW5BSUJhc2VQYXRofS8ke2F6dXJlT3BlbkFJQXBpRGVwbG95bWVudE5hbWV9YDtcbiAgICB9XG4gICAgaWYgKGF6dXJlT3BlbkFJQXBpS2V5KSB7XG4gICAgICAgIGlmICghYXp1cmVPcGVuQUlBcGlJbnN0YW5jZU5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF6dXJlT3BlbkFJQXBpSW5zdGFuY2VOYW1lIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgYXp1cmVPcGVuQUlBcGlLZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhenVyZU9wZW5BSUFwaURlcGxveW1lbnROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhenVyZU9wZW5BSUFwaURlcGxveW1lbnROYW1lIGlzIGEgcmVxdWlyZWQgcGFyYW1ldGVyIHdoZW4gdXNpbmcgYXp1cmVPcGVuQUlBcGlLZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBodHRwczovLyR7YXp1cmVPcGVuQUlBcGlJbnN0YW5jZU5hbWV9Lm9wZW5haS5henVyZS5jb20vb3BlbmFpL2RlcGxveW1lbnRzLyR7YXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZX1gO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVVSTDtcbn1cbiIsICJpbXBvcnQgeyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLCBBUElVc2VyQWJvcnRFcnJvciB9IGZyb20gXCJvcGVuYWlcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gd3JhcE9wZW5BSUNsaWVudEVycm9yKGUpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgaWYgKGUuY29uc3RydWN0b3IubmFtZSA9PT0gQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvci5uYW1lKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLm5hbWUgPSBcIlRpbWVvdXRFcnJvclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFQSVVzZXJBYm9ydEVycm9yLm5hbWUpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4iLCAiaW1wb3J0IHsgT3BlbkFJIGFzIE9wZW5BSUNsaWVudCB9IGZyb20gXCJvcGVuYWlcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vdXRpbC9lbnYuanNcIjtcbmltcG9ydCB7IGNodW5rQXJyYXkgfSBmcm9tIFwiLi4vdXRpbC9jaHVuay5qc1wiO1xuaW1wb3J0IHsgRW1iZWRkaW5ncyB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IGdldEVuZHBvaW50IH0gZnJvbSBcIi4uL3V0aWwvYXp1cmUuanNcIjtcbmltcG9ydCB7IHdyYXBPcGVuQUlDbGllbnRFcnJvciB9IGZyb20gXCIuLi91dGlsL29wZW5haS5qc1wiO1xuLyoqXG4gKiBDbGFzcyBmb3IgZ2VuZXJhdGluZyBlbWJlZGRpbmdzIHVzaW5nIHRoZSBPcGVuQUkgQVBJLiBFeHRlbmRzIHRoZVxuICogRW1iZWRkaW5ncyBjbGFzcyBhbmQgaW1wbGVtZW50cyBPcGVuQUlFbWJlZGRpbmdzUGFyYW1zIGFuZFxuICogQXp1cmVPcGVuQUlJbnB1dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBFbWJlZCBhIHF1ZXJ5IHVzaW5nIE9wZW5BSUVtYmVkZGluZ3MgdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgYSBnaXZlbiB0ZXh0XG4gKiBjb25zdCBtb2RlbCA9IG5ldyBPcGVuQUlFbWJlZGRpbmdzKCk7XG4gKiBjb25zdCByZXMgPSBhd2FpdCBtb2RlbC5lbWJlZFF1ZXJ5KFxuICogICBcIldoYXQgd291bGQgYmUgYSBnb29kIGNvbXBhbnkgbmFtZSBmb3IgYSBjb21wYW55IHRoYXQgbWFrZXMgY29sb3JmdWwgc29ja3M/XCIsXG4gKiApO1xuICogY29uc29sZS5sb2coeyByZXMgfSk7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQUlFbWJlZGRpbmdzIGV4dGVuZHMgRW1iZWRkaW5ncyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkc1dpdGhEZWZhdWx0cyA9IHsgbWF4Q29uY3VycmVuY3k6IDIsIC4uLmZpZWxkcyB9O1xuICAgICAgICBzdXBlcihmaWVsZHNXaXRoRGVmYXVsdHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDUxMlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyaXBOZXdMaW5lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhenVyZU9wZW5BSUFwaVZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXp1cmVPcGVuQUlBcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXp1cmVPcGVuQUlBcGlJbnN0YW5jZU5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhenVyZU9wZW5BSUJhc2VQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yZ2FuaXphdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50Q29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBhcGlLZXkgPSBmaWVsZHNXaXRoRGVmYXVsdHM/Lm9wZW5BSUFwaUtleSA/P1xuICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIk9QRU5BSV9BUElfS0VZXCIpO1xuICAgICAgICBjb25zdCBhenVyZUFwaUtleSA9IGZpZWxkc1dpdGhEZWZhdWx0cz8uYXp1cmVPcGVuQUlBcGlLZXkgPz9cbiAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJBWlVSRV9PUEVOQUlfQVBJX0tFWVwiKTtcbiAgICAgICAgaWYgKCFhenVyZUFwaUtleSAmJiAhYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVuQUkgb3IgQXp1cmUgT3BlbkFJIEFQSSBrZXkgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF6dXJlQXBpSW5zdGFuY2VOYW1lID0gZmllbGRzV2l0aERlZmF1bHRzPy5henVyZU9wZW5BSUFwaUluc3RhbmNlTmFtZSA/P1xuICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkFaVVJFX09QRU5BSV9BUElfSU5TVEFOQ0VfTkFNRVwiKTtcbiAgICAgICAgY29uc3QgYXp1cmVBcGlEZXBsb3ltZW50TmFtZSA9IChmaWVsZHNXaXRoRGVmYXVsdHM/LmF6dXJlT3BlbkFJQXBpRW1iZWRkaW5nc0RlcGxveW1lbnROYW1lIHx8XG4gICAgICAgICAgICBmaWVsZHNXaXRoRGVmYXVsdHM/LmF6dXJlT3BlbkFJQXBpRGVwbG95bWVudE5hbWUpID8/XG4gICAgICAgICAgICAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkFaVVJFX09QRU5BSV9BUElfRU1CRURESU5HU19ERVBMT1lNRU5UX05BTUVcIikgfHxcbiAgICAgICAgICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiQVpVUkVfT1BFTkFJX0FQSV9ERVBMT1lNRU5UX05BTUVcIikpO1xuICAgICAgICBjb25zdCBhenVyZUFwaVZlcnNpb24gPSBmaWVsZHNXaXRoRGVmYXVsdHM/LmF6dXJlT3BlbkFJQXBpVmVyc2lvbiA/P1xuICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkFaVVJFX09QRU5BSV9BUElfVkVSU0lPTlwiKTtcbiAgICAgICAgdGhpcy5henVyZU9wZW5BSUJhc2VQYXRoID1cbiAgICAgICAgICAgIGZpZWxkc1dpdGhEZWZhdWx0cz8uYXp1cmVPcGVuQUlCYXNlUGF0aCA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJBWlVSRV9PUEVOQUlfQkFTRV9QQVRIXCIpO1xuICAgICAgICB0aGlzLm9yZ2FuaXphdGlvbiA9XG4gICAgICAgICAgICBmaWVsZHNXaXRoRGVmYXVsdHM/LmNvbmZpZ3VyYXRpb24/Lm9yZ2FuaXphdGlvbiA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJPUEVOQUlfT1JHQU5JWkFUSU9OXCIpO1xuICAgICAgICB0aGlzLm1vZGVsTmFtZSA9IGZpZWxkc1dpdGhEZWZhdWx0cz8ubW9kZWxOYW1lID8/IHRoaXMubW9kZWxOYW1lO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9XG4gICAgICAgICAgICBmaWVsZHNXaXRoRGVmYXVsdHM/LmJhdGNoU2l6ZSA/PyAoYXp1cmVBcGlLZXkgPyAxIDogdGhpcy5iYXRjaFNpemUpO1xuICAgICAgICB0aGlzLnN0cmlwTmV3TGluZXMgPVxuICAgICAgICAgICAgZmllbGRzV2l0aERlZmF1bHRzPy5zdHJpcE5ld0xpbmVzID8/IHRoaXMuc3RyaXBOZXdMaW5lcztcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gZmllbGRzV2l0aERlZmF1bHRzPy50aW1lb3V0O1xuICAgICAgICB0aGlzLmF6dXJlT3BlbkFJQXBpVmVyc2lvbiA9IGF6dXJlQXBpVmVyc2lvbjtcbiAgICAgICAgdGhpcy5henVyZU9wZW5BSUFwaUtleSA9IGF6dXJlQXBpS2V5O1xuICAgICAgICB0aGlzLmF6dXJlT3BlbkFJQXBpSW5zdGFuY2VOYW1lID0gYXp1cmVBcGlJbnN0YW5jZU5hbWU7XG4gICAgICAgIHRoaXMuYXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZSA9IGF6dXJlQXBpRGVwbG95bWVudE5hbWU7XG4gICAgICAgIGlmICh0aGlzLmF6dXJlT3BlbkFJQXBpS2V5KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXp1cmVPcGVuQUlBcGlJbnN0YW5jZU5hbWUgJiYgIXRoaXMuYXp1cmVPcGVuQUlCYXNlUGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF6dXJlIE9wZW5BSSBBUEkgaW5zdGFuY2UgbmFtZSBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF6dXJlIE9wZW5BSSBBUEkgZGVwbG95bWVudCBuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5henVyZU9wZW5BSUFwaVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBenVyZSBPcGVuQUkgQVBJIHZlcnNpb24gbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBpS2V5ID0gYXBpS2V5ID8/IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRDb25maWcgPSB7XG4gICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICBvcmdhbml6YXRpb246IHRoaXMub3JnYW5pemF0aW9uLFxuICAgICAgICAgICAgYmFzZVVSTDogY29uZmlndXJhdGlvbj8uYmFzZVBhdGgsXG4gICAgICAgICAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRIZWFkZXJzOiBjb25maWd1cmF0aW9uPy5iYXNlT3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIGRlZmF1bHRRdWVyeTogY29uZmlndXJhdGlvbj8uYmFzZU9wdGlvbnM/LnBhcmFtcyxcbiAgICAgICAgICAgIC4uLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICAuLi5maWVsZHM/LmNvbmZpZ3VyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciBhbiBhcnJheSBvZiBkb2N1bWVudHMuIFNwbGl0cyB0aGVcbiAgICAgKiBkb2N1bWVudHMgaW50byBiYXRjaGVzIGFuZCBtYWtlcyByZXF1ZXN0cyB0byB0aGUgT3BlbkFJIEFQSSB0byBnZW5lcmF0ZVxuICAgICAqIGVtYmVkZGluZ3MuXG4gICAgICogQHBhcmFtIHRleHRzIEFycmF5IG9mIGRvY3VtZW50cyB0byBnZW5lcmF0ZSBlbWJlZGRpbmdzIGZvci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSAyRCBhcnJheSBvZiBlbWJlZGRpbmdzIGZvciBlYWNoIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkRG9jdW1lbnRzKHRleHRzKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSBjaHVua0FycmF5KHRoaXMuc3RyaXBOZXdMaW5lcyA/IHRleHRzLm1hcCgodCkgPT4gdC5yZXBsYWNlKC9cXG4vZywgXCIgXCIpKSA6IHRleHRzLCB0aGlzLmJhdGNoU2l6ZSk7XG4gICAgICAgIGNvbnN0IGJhdGNoUmVxdWVzdHMgPSBiYXRjaGVzLm1hcCgoYmF0Y2gpID0+IHRoaXMuZW1iZWRkaW5nV2l0aFJldHJ5KHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiBiYXRjaCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBiYXRjaFJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGJhdGNoUmVxdWVzdHMpO1xuICAgICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hSZXNwb25zZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogYmF0Y2hSZXNwb25zZSB9ID0gYmF0Y2hSZXNwb25zZXNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJhdGNoLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5ncy5wdXNoKGJhdGNoUmVzcG9uc2Vbal0uZW1iZWRkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1iZWRkaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdlbmVyYXRlIGFuIGVtYmVkZGluZyBmb3IgYSBzaW5nbGUgZG9jdW1lbnQuIENhbGxzIHRoZVxuICAgICAqIGVtYmVkZGluZ1dpdGhSZXRyeSBtZXRob2Qgd2l0aCB0aGUgZG9jdW1lbnQgYXMgdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSB0ZXh0IERvY3VtZW50IHRvIGdlbmVyYXRlIGFuIGVtYmVkZGluZyBmb3IuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGVtYmVkZGluZyBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkUXVlcnkodGV4dCkge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuZW1iZWRkaW5nV2l0aFJldHJ5KHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLnN0cmlwTmV3TGluZXMgPyB0ZXh0LnJlcGxhY2UoL1xcbi9nLCBcIiBcIikgOiB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGFbMF0uZW1iZWRkaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCB0byBtYWtlIGEgcmVxdWVzdCB0byB0aGUgT3BlbkFJIEFQSSB0byBnZW5lcmF0ZVxuICAgICAqIGVtYmVkZGluZ3MuIEhhbmRsZXMgdGhlIHJldHJ5IGxvZ2ljIGFuZCByZXR1cm5zIHRoZSByZXNwb25zZSBmcm9tIHRoZVxuICAgICAqIEFQSS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBSZXF1ZXN0IHRvIHNlbmQgdG8gdGhlIE9wZW5BSSBBUEkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWRkaW5nV2l0aFJldHJ5KHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlbkFJRW5kcG9pbnRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXp1cmVPcGVuQUlBcGlEZXBsb3ltZW50TmFtZTogdGhpcy5henVyZU9wZW5BSUFwaURlcGxveW1lbnROYW1lLFxuICAgICAgICAgICAgICAgIGF6dXJlT3BlbkFJQXBpSW5zdGFuY2VOYW1lOiB0aGlzLmF6dXJlT3BlbkFJQXBpSW5zdGFuY2VOYW1lLFxuICAgICAgICAgICAgICAgIGF6dXJlT3BlbkFJQXBpS2V5OiB0aGlzLmF6dXJlT3BlbkFJQXBpS2V5LFxuICAgICAgICAgICAgICAgIGF6dXJlT3BlbkFJQmFzZVBhdGg6IHRoaXMuYXp1cmVPcGVuQUlCYXNlUGF0aCxcbiAgICAgICAgICAgICAgICBiYXNlVVJMOiB0aGlzLmNsaWVudENvbmZpZy5iYXNlVVJMLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0RW5kcG9pbnQob3BlbkFJRW5kcG9pbnRDb25maWcpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY2xpZW50Q29uZmlnLFxuICAgICAgICAgICAgICAgIGJhc2VVUkw6IGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgICAgICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmJhc2VVUkwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLmJhc2VVUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyBPcGVuQUlDbGllbnQocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5henVyZU9wZW5BSUFwaUtleSkge1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBcImFwaS1rZXlcIjogdGhpcy5henVyZU9wZW5BSUFwaUtleSxcbiAgICAgICAgICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIFwiYXBpLXZlcnNpb25cIjogdGhpcy5henVyZU9wZW5BSUFwaVZlcnNpb24sXG4gICAgICAgICAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZW1iZWRkaW5ncy5jcmVhdGUocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gd3JhcE9wZW5BSUNsaWVudEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgcmVxdWVzdCwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgT3BlbkFJIGZyb20gXCJvcGVuYWlcIjtcblxubGV0IHVybF9hZmZpbml0eV9vcmdhbml6YXRpb25zID0gXCJodHRwczovL2FwaS5hZmZpbml0eS5jby9vcmdhbml6YXRpb25zXCI7XG5sZXQgdXJsX2FmZmluaXR5X25vdGUgPSBcImh0dHBzOi8vYXBpLmFmZmluaXR5LmNvL25vdGVzXCI7XG5sZXQgdXJsX2FmZmluaXR5X3BlcnNvbnMgPSBcImh0dHBzOi8vYXBpLmFmZmluaXR5LmNvL3BlcnNvbnNcIjtcbmxldCB1cmxfYWZmaW5pdHlfZmllbGRfdmFsdWVzID0gXCJodHRwczovL2FwaS5hZmZpbml0eS5jby9maWVsZC12YWx1ZXNcIjtcbmxldCB1cmxfYWZmaW5pdHlfbGlzdCA9IFwiaHR0cHM6Ly9hcGkuYWZmaW5pdHkuY28vbGlzdHNcIjtcblxuZnVuY3Rpb24gYWZmaW5pdHlfYXV0aG9yaXphdGlvbihhZmZpbml0eUFQSUtleTogc3RyaW5nKSB7XG4gIGxldCB1c2VybmFtZSA9IFwiXCI7XG4gIGxldCBwd2QgPSBhZmZpbml0eUFQSUtleTtcbiAgbGV0IGF1dGggPSBcIkJhc2ljIFwiICsgQnVmZmVyLmZyb20odXNlcm5hbWUgKyBcIjpcIiArIHB3ZCkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGxldCBoZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBhdXRoLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZF9ub3Rlc190b19jb21wYW55KFxuICBzdGFydHVwOiBhbnksXG4gIG5vdGU6IHN0cmluZyxcbiAgYWZmaW5pdHlBUElLZXk6IHN0cmluZ1xuKSB7XG4gIGxldCBoZWFkZXJzID0gYWZmaW5pdHlfYXV0aG9yaXphdGlvbihhZmZpbml0eUFQSUtleSk7XG4gIC8vaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgbGV0IG9yZ2FuaXphdGlvbl9pZHMgPSBbc3RhcnR1cFtcImlkXCJdXTtcbiAgY29uc29sZS5sb2cob3JnYW5pemF0aW9uX2lkcyk7XG4gIGNvbnNvbGUubG9nKG5vdGUpO1xuICBsZXQgbm90ZV9kYXRhID0geyBvcmdhbml6YXRpb25faWRzOiBbc3RhcnR1cFtcImlkXCJdXSwgY29udGVudDogbm90ZSB9O1xuICBsZXQgcjogYW55ID0gYXdhaXQgcmVxdWVzdCh7XG4gICAgdXJsOiB1cmxfYWZmaW5pdHlfbm90ZSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkobm90ZV9kYXRhKSxcbiAgfSlcbiAgICAudGhlbigoZGF0YSkgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBcIlN1Y2Nlc3NcIjtcbiAgLy9jb25zb2xlLmxvZyhyKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0X3N0YXJ0dXBfYnlfbmFtZShcbiAgYWZmaW5pdHlBUElLZXk6IHN0cmluZyxcbiAgb3duZXJfdmFsdWU6IHN0cmluZyxcbiAgc3RhcnR1cF9uYW1lOiBzdHJpbmdcbikge1xuICAvL2xldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zICh7dGVybTogJ0Jsb2JyJywgd2l0aF9pbnRlcmFjdGlvbl9kYXRlczondHJ1ZScsIHdpdGhfaW50ZXJhY3Rpb25fcGVyc29uczondHJ1ZScsIHBhZ2VfdG9rZW46ICcnfSlcblxuICAvL2xldCBjb21wYW55X25hbWUgPSAnQmxvYnInXG4gIGxldCBzdWJuYW1lcyA9IHN0YXJ0dXBfbmFtZS5zcGxpdChcIiBcIik7XG4gIGxldCBzZWFyY2hfdGVybSA9IHN1Ym5hbWVzWzBdO1xuICBpZiAoc3VibmFtZXMubGVuZ3RoID4gMSkge1xuICAgIGZvciAobGV0IG5hbWUgb2Ygc3VibmFtZXMuc2xpY2UoMSkpIHtcbiAgICAgIHNlYXJjaF90ZXJtID0gc2VhcmNoX3Rlcm0gKyBcIitcIiArIG5hbWU7XG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKHNlYXJjaF90ZXJtKTtcblxuICBsZXQgbmV4dF9wYWdlX3Rva2VuID0gbnVsbDtcbiAgbGV0IGhlYWRlcnMgPSBhZmZpbml0eV9hdXRob3JpemF0aW9uKGFmZmluaXR5QVBJS2V5KTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBmdWxsX3VybCA9XG4gICAgICB1cmxfYWZmaW5pdHlfb3JnYW5pemF0aW9ucyArXG4gICAgICBcIj90ZXJtPVwiICtcbiAgICAgIHNlYXJjaF90ZXJtICtcbiAgICAgIFwiJndpdGhfaW50ZXJhY3Rpb25fZGF0ZXM9dHJ1ZSZ3aXRoX2ludGVyYWN0aW9uX3BlcnNvbnM9dHJ1ZVwiO1xuICAgIGlmIChuZXh0X3BhZ2VfdG9rZW4gIT0gbnVsbCkge1xuICAgICAgZnVsbF91cmwgKz0gXCImcGFnZV90b2tlbj1cIiArIG5leHRfcGFnZV90b2tlbjtcbiAgICB9XG5cbiAgICBsZXQgcjogYW55ID0gYXdhaXQgcmVxdWVzdCh7XG4gICAgICB1cmw6IGZ1bGxfdXJsLFxuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICB9KTtcblxuICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2Uocik7XG4gICAgLy9jb25zb2xlLmxvZyhyZXNwb25zZSlcbiAgICBsZXQgb3JnYW5pemF0aW9ucyA9IHJlc3BvbnNlW1wib3JnYW5pemF0aW9uc1wiXTtcbiAgICBuZXh0X3BhZ2VfdG9rZW4gPSByZXNwb25zZVtcIm5leHRfcGFnZV90b2tlblwiXTtcbiAgICBmb3IgKGxldCBvcmdhbml6YXRpb24gb2Ygb3JnYW5pemF0aW9ucykge1xuICAgICAgaWYgKG9yZ2FuaXphdGlvbltcImludGVyYWN0aW9uc1wiXSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKG9yZ2FuaXphdGlvbilcbiAgICAgICAgZm9yIChsZXQgW2ludGVyYWN0aW9uX25hbWUsIGludGVyYWN0aW9uX2RhdGFdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICAgIG9yZ2FuaXphdGlvbltcImludGVyYWN0aW9uc1wiXVxuICAgICAgICApKSB7XG4gICAgICAgICAgaWYgKGludGVyYWN0aW9uX2RhdGEpIHtcbiAgICAgICAgICAgIGxldCBwZW9wbGVfaW52b2x2ZWQ6IGFueSA9XG4gICAgICAgICAgICAgIGludGVyYWN0aW9uX2RhdGFbXCJwZXJzb25faWRzXCJdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocGVvcGxlX2ludm9sdmVkLmluY2x1ZGVzKG93bmVyX3ZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JnYW5pemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhuZXh0X3BhZ2VfdG9rZW4pXG4gICAgaWYgKG5leHRfcGFnZV90b2tlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldF9wZXJzb25fYnlfbmFtZShcbiAgYWZmaW5pdHlBUElLZXk6IHN0cmluZyxcbiAgcGVyc29uX25hbWU6IHN0cmluZ1xuKSB7XG4gIGxldCBuYW1lcyA9IHBlcnNvbl9uYW1lLnNwbGl0KFwiIFwiKTtcbiAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICBsZXQgbmV4dF9wYWdlX3Rva2VuID0gbnVsbDtcbiAgICBsZXQgaGVhZGVycyA9IGFmZmluaXR5X2F1dGhvcml6YXRpb24oYWZmaW5pdHlBUElLZXkpO1xuICAgIGxldCBmaXJzdF9uYW1lID0gbmFtZXNbMF07XG4gICAgbGV0IGxhc3RfbmFtZSA9IG5hbWVzWzFdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgZnVsbF91cmwgPSB1cmxfYWZmaW5pdHlfcGVyc29ucyArIFwiP3Rlcm09XCIgKyBsYXN0X25hbWU7XG4gICAgICBpZiAobmV4dF9wYWdlX3Rva2VuICE9IG51bGwpIHtcbiAgICAgICAgZnVsbF91cmwgKz0gXCImcGFnZV90b2tlbj1cIiArIG5leHRfcGFnZV90b2tlbjtcbiAgICAgIH1cbiAgICAgIGxldCByOiBhbnkgPSBhd2FpdCByZXF1ZXN0KHtcbiAgICAgICAgdXJsOiBmdWxsX3VybCxcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2Uocik7XG4gICAgICBsZXQgcGVvcGxlID0gcmVzcG9uc2VbXCJwZXJzb25zXCJdO1xuICAgICAgbmV4dF9wYWdlX3Rva2VuID0gcmVzcG9uc2VbXCJuZXh0X3BhZ2VfdG9rZW5cIl07XG5cbiAgICAgIGZvciAobGV0IHBlcnNvbiBvZiBwZW9wbGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBlcnNvbltcImZpcnN0X25hbWVcIl0gPT0gZmlyc3RfbmFtZSAmJlxuICAgICAgICAgIHBlcnNvbltcImxhc3RfbmFtZVwiXSA9PSBsYXN0X25hbWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHBlcnNvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dF9wYWdlX3Rva2VuID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vV2Ugb25seSBoYXZlIGZpcnN0IG5hbWUsIHdlIGNhbiBub3QgZmluZCBhIHBlcnNvbiBsaWtlIHRoaXNcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldF9wZXJzb25fZGV0YWlscyhcbiAgYWZmaW5pdHlBUElLZXk6IHN0cmluZyxcbiAgcGVyc29uX2lkOiBudW1iZXJcbikge1xuICBsZXQgZnVsbF91cmwgPSB1cmxfYWZmaW5pdHlfcGVyc29ucyArIFwiL1wiICsgcGVyc29uX2lkLnRvU3RyaW5nKCk7XG4gIGxldCBoZWFkZXJzID0gYWZmaW5pdHlfYXV0aG9yaXphdGlvbihhZmZpbml0eUFQSUtleSk7XG5cbiAgbGV0IHI6IGFueSA9IGF3YWl0IHJlcXVlc3Qoe1xuICAgIHVybDogZnVsbF91cmwsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gIH0pO1xuICBsZXQgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHIpO1xuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzX3BlcnNvbl9pbl92ZW50dXJlX25ldHdvcmsoXG4gIGFmZmluaXR5QVBJS2V5OiBzdHJpbmcsXG4gIHBlcnNvbl9kZXRhaWxzOiBhbnksXG4gIHZlbnR1cmVfbmV0d29ya19saXN0X2lkOiBzdHJpbmdcbikge1xuICBsZXQgbGlzdF9lbnRyaWVzID0gcGVyc29uX2RldGFpbHNbXCJsaXN0X2VudHJpZXNcIl07XG4gIGZvciAobGV0IGVudHJ5IG9mIGxpc3RfZW50cmllcykge1xuICAgIGlmIChlbnRyeVtcImxpc3RfaWRcIl0udG9TdHJpbmcoKSA9PSB2ZW50dXJlX25ldHdvcmtfbGlzdF9pZC50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gZW50cnlbXCJpZFwiXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRfZmllbGRfdmFsdWVzKFxuICBhZmZpbml0eUFQSUtleTogc3RyaW5nLFxuICB0eXBlX2lkOiBzdHJpbmcsXG4gIGlkOiBzdHJpbmdcbikge1xuICBsZXQgZnVsbF91cmwgPSB1cmxfYWZmaW5pdHlfZmllbGRfdmFsdWVzICsgXCI/XCIgKyB0eXBlX2lkICsgXCI9XCIgKyBpZDtcbiAgbGV0IGhlYWRlcnMgPSBhZmZpbml0eV9hdXRob3JpemF0aW9uKGFmZmluaXR5QVBJS2V5KTtcbiAgbGV0IHI6IGFueSA9IGF3YWl0IHJlcXVlc3Qoe1xuICAgIHVybDogZnVsbF91cmwsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gIH0pO1xuICBsZXQgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHIpO1xuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZF9lbnRyeV90b19saXN0KFxuICBhZmZpbml0eUFQSUtleTogc3RyaW5nLFxuICBsaXN0X2lkOiBzdHJpbmcsXG4gIGVudGl0eV9pZDogbnVtYmVyXG4pIHtcbiAgbGV0IGhlYWRlcnMgPSBhZmZpbml0eV9hdXRob3JpemF0aW9uKGFmZmluaXR5QVBJS2V5KTtcbiAgbGV0IGZ1bGxfdXJsID0gdXJsX2FmZmluaXR5X2xpc3QgKyBcIi9cIiArIGxpc3RfaWQgKyBcIi9saXN0LWVudHJpZXNcIjtcbiAgbGV0IGRhdGEgPSB7IGVudGl0eV9pZDogZW50aXR5X2lkIH07XG5cbiAgbGV0IHI6IGFueSA9IGF3YWl0IHJlcXVlc3Qoe1xuICAgIHVybDogZnVsbF91cmwsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICB9KVxuICAgIC50aGVuKChkYXRhKSA9PiBjb25zb2xlLmxvZyhkYXRhKSlcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICByZXR1cm4gXCJTdWNjZXNzXCI7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkX2ZpZWxkX3ZhbHVlKFxuICBhZmZpbml0eUFQSUtleTogc3RyaW5nLFxuICBmaWVsZF9pZDogYW55LFxuICBlbnRpdHlfaWQ6IG51bWJlcixcbiAgdmFsdWU6IGFueSxcbiAgbGlzdF9lbnRyeV9pZDogYW55XG4pIHtcbiAgbGV0IGhlYWRlcnMgPSBhZmZpbml0eV9hdXRob3JpemF0aW9uKGFmZmluaXR5QVBJS2V5KTtcbiAgbGV0IGZ1bGxfdXJsID0gdXJsX2FmZmluaXR5X2ZpZWxkX3ZhbHVlcztcbiAgbGV0IGRhdGEgPSB7XG4gICAgZmllbGRfaWQ6IGZpZWxkX2lkLFxuICAgIGVudGl0eV9pZDogZW50aXR5X2lkLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsaXN0X2VudHJ5X2lkOiBsaXN0X2VudHJ5X2lkLFxuICB9O1xuXG4gIGxldCByOiBhbnkgPSBhd2FpdCByZXF1ZXN0KHtcbiAgICB1cmw6IGZ1bGxfdXJsLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgfSlcbiAgICAudGhlbigoZGF0YSkgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgcmV0dXJuIFwiU3VjY2Vzc1wiO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkX25vdGVzX3RvX3BlcnNvbihcbiAgYWZmaW5pdHlBUElLZXk6IHN0cmluZyxcbiAgcGVyc29uX2lkOiBhbnksXG4gIG5vdGVzOiBzdHJpbmdcbikge1xuICBsZXQgZnVsbF91cmwgPSB1cmxfYWZmaW5pdHlfbm90ZTtcbiAgbGV0IGhlYWRlcnMgPSBhZmZpbml0eV9hdXRob3JpemF0aW9uKGFmZmluaXR5QVBJS2V5KTtcbiAgbGV0IGRhdGEgPSB7IHBlcnNvbl9pZHM6IFtwZXJzb25faWRdLCBjb250ZW50OiBub3RlcyB9O1xuXG4gIGxldCByOiBhbnkgPSBhd2FpdCByZXF1ZXN0KHtcbiAgICB1cmw6IGZ1bGxfdXJsLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgfSlcbiAgICAudGhlbigoZGF0YSkgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgcmV0dXJuIFwiU3VjY2Vzc1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnR1cF9yZWFkeV9mb3JfYWZmaW5pdHkoZmlsZV9jb250ZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoXCIjc3RhcnR1cHMvc2NyZWVuZWRcIikgJiZcbiAgICBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoXCIjQWZmaW5pdHlcIilcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RfdGl0bGVfYW5kX25vdGUodGV4dDogc3RyaW5nKSB7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFsbCB0aGUgdGV4dCBpbiB0aGUgZmlsZSBhbmQgcmV0dXJucyB0aGUgdGl0bGUgYW5kIHRoZSBib2R5IG9mIHRoZSBub3RlLlxuICAgKiBUaGUgc3BsaXQgaGFwcGVucyBiYXNlZCBvbiBoMSBoZWFkZXIuXG4gICAqIFRoaXMgbWVhbnMgc3Vic3RyaW5nc1swXSBpcyB1c3VhbGx5IHRoZSBkYXRhIGJlZm9yZSB0aGUgdGl0bGUuXG4gICAqIHN1YnN0cmluZ3NbMV0gaXMgdXN1YWxseSB0aGUgYm9keSBvZiB0aGUgbm90ZVxuICAgKiBpZiB0aGVyZSBpcyBzdWJzdHJpbmcgWzJdLCB0aGlzIG1lYW5zIHRoZXJlIGlzIGFub3RoZXIgaDEgaGVhZGVyICh1c3VhbGx5ICMgU3RvcCBJbmRleGluZylcbiAgICogRG93bnN0cmVhbSB0YXNrcyBvbmx5IGRlYWxzIHdpdGggc3Vic3RyaW5nWzFdIGFzIHRoZSBub3RlOyBpLmUgaW5mb3JtYXRpb24gYWZ0ZXIgdGhlIFN0b3AgSW5kZXhpbmcgYXJlIGV4ZWNsdWRlZFxuICAgKi9cblxuICAvLz9nbSBtZWFucyBzdHJpbmcgaXMgbXVsdGlsaW5lcywgYW5kIF4gd291bGQgY2F0Y2ggYmVnaW5uaW5nIG9mIGV2ZXJ5IGxpbmUgbm90IGp1c3QgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmchXG4gIGxldCBwYXR0ZXJuID0gL14jIC4qXFxuL2dtO1xuICBsZXQgbWF0Y2hlcyA9IHRleHQubWF0Y2gocGF0dGVybik7XG4gIGxldCB0aXRsZSA9IFwiXCI7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgdGl0bGUgPSBtYXRjaGVzWzBdO1xuICB9XG4gIGxldCBzdWJzdHJpbmdzID0gdGV4dC5zcGxpdChwYXR0ZXJuKTtcbiAgY29uc29sZS5sb2coYFRpdGxlOiAke3RpdGxlfWApO1xuICBjb25zb2xlLmxvZyhzdWJzdHJpbmdzKTtcblxuICByZXR1cm4gW3RpdGxlLCBzdWJzdHJpbmdzXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuX3RleHQoc3RhcnR1cF9uYW1lOiBzdHJpbmcpIHtcbiAgc3RhcnR1cF9uYW1lID0gc3RhcnR1cF9uYW1lLnJlcGxhY2UoL1teQS1aYS16MC05XFxzLl0vZywgXCJcIik7XG4gIHN0YXJ0dXBfbmFtZSA9IHN0YXJ0dXBfbmFtZS50cmltKCk7XG4gIHJldHVybiBzdGFydHVwX25hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc19zdW1tYXJpemFibGUoZmlsZV9jb250ZW50OiBzdHJpbmcpIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSBWQyBpcyB0byBiZSBzdW1tYXJpemVkIChJIGFtIGNvbm5lY3RlZCB3aXRoIHRoZW0gYW5kIHRoZXkgYXJlIG5vdCBhbHJlYWR5IHN1bW1hcml6ZWQpXG4gICAqL1xuICByZXR1cm4gKFxuICAgIGZpbGVfY29udGVudC5pbmNsdWRlcyhcIiNuZXR3b3JrL2Nvbm5lY3RlZFwiKSAmJlxuICAgIChmaWxlX2NvbnRlbnQuaW5jbHVkZXMoXCIjRW50aXR5L1ZDXCIpIHx8XG4gICAgICBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoXCIjUGVyc29uL1ZDXCIpKSAmJlxuICAgIGZpbGVfY29udGVudC5pbmNsdWRlcyhcIiNncHRfc3VtbWFyaXplZFwiKSAhPSB0cnVlICYmXG4gICAgZmlsZV9jb250ZW50LmluY2x1ZGVzKFwiZGF0YXZpZXdcIikgIT0gdHJ1ZVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmNfcmVhZHlfZm9yX2FmZmluaXR5KGZpbGVfY29udGVudDogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgZmlsZV9jb250ZW50LmluY2x1ZGVzKFwiI2dwdF9zdW1tYXJpemVkXCIpICYmXG4gICAgZmlsZV9jb250ZW50LmluY2x1ZGVzKFwiI0FmZmluaXR5XCIpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudFdvcmRzKHN0cjogc3RyaW5nKSB7XG4gIC8vIHNwbGl0IHRoZSBzdHJpbmcgYnkgd29yZCBib3VuZGFyaWVzXG4gIGxldCB3b3JkcyA9IHN0ci5tYXRjaCgvXFxiW2EtelxcZF0rXFxiL2dpKTtcbiAgLy8gcmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9yIHplcm8gaWYgbm8gbWF0Y2hcbiAgcmV0dXJuIHdvcmRzID8gd29yZHMubGVuZ3RoIDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3Rfc3RhcnR1cF9kZXRhaWxzKHN0YXJ0dXA6IGFueSkge1xuICBsZXQgc3RhcnR1cF9kZXRhaWxzID0ge307XG4gIHN0YXJ0dXBfZGV0YWlsc1tcIm5hbWVcIl0gPSBzdGFydHVwW1wibmFtZVwiXTtcbiAgc3RhcnR1cF9kZXRhaWxzW1wiZG9tYWluXCJdID0gc3RhcnR1cFtcImRvbWFpblwiXTtcbiAgdHJ5IHtcbiAgICBzdGFydHVwX2RldGFpbHNbXCJkZXNjcmlwdGlvblwiXSA9IHN0YXJ0dXBbXCJkZXNjcmlwdGlvblwiXVtcImxvbmdcIl07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzdGFydHVwX2RldGFpbHNbXCJkZXNjcmlwdGlvblwiXSA9IHN0YXJ0dXBbXCJkZXNjcmlwdGlvblwiXVtcInNob3J0XCJdO1xuICB9XG4gIHN0YXJ0dXBfZGV0YWlsc1tcInRvdGFsTW9uZXlSYWlzZWRcIl0gPSBzdGFydHVwW1widG90YWxNb25leVJhaXNlZFwiXTtcbiAgc3RhcnR1cF9kZXRhaWxzW1wiZm91bmRlZFllYXJcIl0gPSBzdGFydHVwW1wiZm91bmRlZFllYXJcIl07XG4gIHN0YXJ0dXBfZGV0YWlsc1tcImxvY2F0aW9uXCJdID0gc3RhcnR1cFtcImxvY2F0aW9uXCJdO1xuICBzdGFydHVwX2RldGFpbHNbXCJzdGFnZVwiXSA9IHN0YXJ0dXBbXCJzdGFnZVwiXTtcbiAgc3RhcnR1cF9kZXRhaWxzW1wiaW52ZXN0b3JMaXN0XCJdID0gc3RhcnR1cFtcImludmVzdG9yTGlzdFwiXTtcbiAgc3RhcnR1cF9kZXRhaWxzW1wicHJvZmlsZUxpbmtzXCJdID0gc3RhcnR1cFtcInByb2ZpbGVMaW5rc1wiXTtcbiAgc3RhcnR1cF9kZXRhaWxzW1wibmV3c0luZm9cIl0gPSBzdGFydHVwW1wibmV3c0luZm9cIl07XG5cbiAgc3RhcnR1cF9kZXRhaWxzW1wibWV0cmljc1wiXSA9IHN0YXJ0dXBbXCJtZXRyaWNzXCJdO1xuICBzdGFydHVwX2RldGFpbHNbXCJ0cmFjeG5UZWFtU2NvcmVcIl0gPSBzdGFydHVwW1widHJhY3huVGVhbVNjb3JlXCJdO1xuICBzdGFydHVwX2RldGFpbHNbXCJ0cmFjeG5TY29yZVwiXSA9IHN0YXJ0dXBbXCJ0cmFjeG5TY29yZVwiXTtcbiAgcmV0dXJuIHN0YXJ0dXBfZGV0YWlscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9hY3F1aXNpdGlvbl9kZXRhaWxzKHN0YXJ0dXA6IGFueSkge1xuICBsZXQgYWNxdWlyZXJzU3RyaW5nID0gXCJcIjtcbiAgbGV0IGFjcXVpcmVycyA9IHN0YXJ0dXBbXCJhY3F1aXJlckluZm9cIl1bXCJhY3F1aXJlckxpc3RcIl1bMF1bXCJhY3F1aXJlcnNcIl07XG4gIGxldCBhY3F1aXNpdGlvblllYXIgPVxuICAgIHN0YXJ0dXBbXCJhY3F1aXJlckluZm9cIl1bXCJhY3F1aXJlckxpc3RcIl1bMF1bXCJkYXRlXCJdW1wieWVhclwiXTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICBmb3IgKGxldCBhY3F1aXJlciBvZiBhY3F1aXJlcnMpIHtcbiAgICBpZiAoY291bnRlciA9PSAwKSB7XG4gICAgICBhY3F1aXJlcnNTdHJpbmcgKz0gYFske2FjcXVpcmVyW1wibmFtZVwiXX1dKCR7YWNxdWlyZXJbXCJkb21haW5cIl19KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjcXVpcmVyc1N0cmluZyArPSBcIiwgXCIgKyBgWyR7YWNxdWlyZXJbXCJuYW1lXCJdfV0oJHthY3F1aXJlcltcImRvbWFpblwiXX0pYDtcbiAgICB9XG4gICAgY291bnRlciArPSAxO1xuICB9XG4gIHJldHVybiB7IEFjcXVpcmVyczogYWNxdWlyZXJzU3RyaW5nLCBBY3F1aXNpdGlvblllYXI6IGFjcXVpc2l0aW9uWWVhciB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2lwb19kZXRhaWxzKHN0YXJ0dXA6IGFueSkge1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGxldCBpcG9MaXN0ID0gc3RhcnR1cFtcImlwb0luZm9cIl1bXCJpcG9MaXN0XCJdO1xuICBmb3IgKGxldCBpcG8gb2YgaXBvTGlzdCkge1xuICAgIGlmIChpcG9bXCJtYXJrZXRDYXBcIl0pIHtcbiAgICAgIHJlc3VsdFtcIm1hcmtldENhcFwiXSA9IGlwb1tcIm1hcmtldENhcFwiXTtcbiAgICAgIHJlc3VsdFtcImlwb1llYXJcIl0gPSBpcG9bXCJkYXRlXCJdW1wieWVhclwiXTtcbiAgICAgIHJlc3VsdFtcInN0b2NrRXhjaGFuZ2VcIl0gPSBpcG9bXCJzdG9ja0V4Y2hhbmdlXCJdO1xuICAgICAgcmVzdWx0W1wic3RvY2tTeW1ib2xcIl0gPSBpcG9bXCJzdG9ja1N5bWJvbFwiXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0X2tleXNfZm9yX3RhYmxlKGFsbEtleXMpIHtcbiAgY29uc3QgZXhjbHVkZWRLZXlzID0gW1wibmV3c0luZm9cIiwgXCJtZXRyaWNzXCIsIFwiZG9tYWluXCJdO1xuICBsZXQgZmluYWxLZXlzOiBhbnkgPSBbXTtcbiAgZm9yIChsZXQga2V5IG9mIGFsbEtleXMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBmaW5hbEtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxLZXlzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyKSB7XG4gIGNvbnN0IGFiYnJldmlhdGlvbnMgPSB7XG4gICAgVDogMTAwMDAwMDAwMDAwMCxcbiAgICBCOiAxMDAwMDAwMDAwLFxuICAgIE06IDEwMDAwMDAsXG4gICAgSzogMTAwMCxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGFiYnJldmlhdGlvbiBpbiBhYmJyZXZpYXRpb25zKSB7XG4gICAgaWYgKG51bWJlciA+PSBhYmJyZXZpYXRpb25zW2FiYnJldmlhdGlvbl0pIHtcbiAgICAgIGNvbnN0IHJvdW5kZWROdW1iZXIgPSBNYXRoLmNlaWwobnVtYmVyIC8gYWJicmV2aWF0aW9uc1thYmJyZXZpYXRpb25dKTtcbiAgICAgIHJldHVybiByb3VuZGVkTnVtYmVyICsgYWJicmV2aWF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0dGVkQ291bnRyeU5hbWUoY291bnRyeU5hbWUpIHtcbiAgY29uc3QgZm9ybWF0dGVkQ291bnRyeU5hbWUgPVxuICAgIGNvdW50cnlOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY291bnRyeU5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGZvcm1hdHRlZENvdW50cnlOYW1lO1xufVxuXG5mdW5jdGlvbiBpc0NvdW50cnlJbkV1cm9wZShjb3VudHJ5TmFtZSkge1xuICBjb25zdCBldXJvcGVhbkNvdW50cmllcyA9IFtcbiAgICBcIkFsYmFuaWFcIixcbiAgICBcIkFuZG9ycmFcIixcbiAgICBcIkF1c3RyaWFcIixcbiAgICBcIkJlbGFydXNcIixcbiAgICBcIkJlbGdpdW1cIixcbiAgICBcIkJvc25pYSBhbmQgSGVyemVnb3ZpbmFcIixcbiAgICBcIkJ1bGdhcmlhXCIsXG4gICAgXCJDcm9hdGlhXCIsXG4gICAgXCJDeXBydXNcIixcbiAgICBcIkN6ZWNoIFJlcHVibGljXCIsXG4gICAgXCJEZW5tYXJrXCIsXG4gICAgXCJFc3RvbmlhXCIsXG4gICAgXCJGaW5sYW5kXCIsXG4gICAgXCJGcmFuY2VcIixcbiAgICBcIkdlcm1hbnlcIixcbiAgICBcIkdyZWVjZVwiLFxuICAgIFwiSHVuZ2FyeVwiLFxuICAgIFwiSWNlbGFuZFwiLFxuICAgIFwiSXJlbGFuZFwiLFxuICAgIFwiSXRhbHlcIixcbiAgICBcIktvc292b1wiLFxuICAgIFwiTGF0dmlhXCIsXG4gICAgXCJMaWVjaHRlbnN0ZWluXCIsXG4gICAgXCJMaXRodWFuaWFcIixcbiAgICBcIkx1eGVtYm91cmdcIixcbiAgICBcIk1hbHRhXCIsXG4gICAgXCJNb2xkb3ZhXCIsXG4gICAgXCJNb25hY29cIixcbiAgICBcIk1vbnRlbmVncm9cIixcbiAgICBcIk5ldGhlcmxhbmRzXCIsXG4gICAgXCJOb3J0aCBNYWNlZG9uaWFcIixcbiAgICBcIk5vcndheVwiLFxuICAgIFwiUG9sYW5kXCIsXG4gICAgXCJQb3J0dWdhbFwiLFxuICAgIFwiUm9tYW5pYVwiLFxuICAgIFwiUnVzc2lhXCIsXG4gICAgXCJTYW4gTWFyaW5vXCIsXG4gICAgXCJTZXJiaWFcIixcbiAgICBcIlNsb3Zha2lhXCIsXG4gICAgXCJTbG92ZW5pYVwiLFxuICAgIFwiU3BhaW5cIixcbiAgICBcIlN3ZWRlblwiLFxuICAgIFwiU3dpdHplcmxhbmRcIixcbiAgICBcIlVrcmFpbmVcIixcbiAgICBcIlVuaXRlZCBLaW5nZG9tXCIsXG4gICAgXCJVS1wiLFxuICAgIFwiVmF0aWNhbiBDaXR5XCIsXG4gIF07XG5cbiAgcmV0dXJuIGV1cm9wZWFuQ291bnRyaWVzLmluY2x1ZGVzKGZvcm1hdHRlZENvdW50cnlOYW1lKGNvdW50cnlOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIGlzQ291bnRyeUluRWFzdGVybkV1cm9wZShjb3VudHJ5TmFtZSkge1xuICBjb25zdCBlYXN0ZXJuRXVyb3BlYW5Db3VudHJpZXMgPSBbXG4gICAgXCJBbGJhbmlhXCIsXG4gICAgXCJCZWxhcnVzXCIsXG4gICAgXCJCb3NuaWEgYW5kIEhlcnplZ292aW5hXCIsXG4gICAgXCJCdWxnYXJpYVwiLFxuICAgIFwiQ3JvYXRpYVwiLFxuICAgIFwiQ3lwcnVzXCIsXG4gICAgXCJDemVjaCBSZXB1YmxpY1wiLFxuICAgIFwiRXN0b25pYVwiLFxuICAgIFwiSHVuZ2FyeVwiLFxuICAgIFwiS29zb3ZvXCIsXG4gICAgXCJMYXR2aWFcIixcbiAgICBcIkxpdGh1YW5pYVwiLFxuICAgIFwiTW9sZG92YVwiLFxuICAgIFwiTW9udGVuZWdyb1wiLFxuICAgIFwiTm9ydGggTWFjZWRvbmlhXCIsXG4gICAgXCJQb2xhbmRcIixcbiAgICBcIlJvbWFuaWFcIixcbiAgICBcIlJ1c3NpYVwiLFxuICAgIFwiU2VyYmlhXCIsXG4gICAgXCJTbG92YWtpYVwiLFxuICAgIFwiU2xvdmVuaWFcIixcbiAgICBcIlVrcmFpbmVcIixcbiAgXTtcblxuICByZXR1cm4gZWFzdGVybkV1cm9wZWFuQ291bnRyaWVzLmluY2x1ZGVzKGZvcm1hdHRlZENvdW50cnlOYW1lKGNvdW50cnlOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIGlzQ291bnRyeUluTm9yZGljcyhjb3VudHJ5TmFtZSkge1xuICBjb25zdCBub3JkaWNDb3VudHJpZXMgPSBbXCJEZW5tYXJrXCIsIFwiRmlubGFuZFwiLCBcIkljZWxhbmRcIiwgXCJOb3J3YXlcIiwgXCJTd2VkZW5cIl07XG5cbiAgcmV0dXJuIG5vcmRpY0NvdW50cmllcy5pbmNsdWRlcyhmb3JtYXR0ZWRDb3VudHJ5TmFtZShjb3VudHJ5TmFtZSkpO1xufVxuXG5mdW5jdGlvbiBnZW9fY2hlY2soaW5wdXRfY291bnRyeSwgaW52ZXN0b3JfZ2VvKSB7XG4gIGlucHV0X2NvdW50cnkgPSBpbnB1dF9jb3VudHJ5LnRvTG93ZXJDYXNlKCk7XG4gIGxldCB1c2FfYWJicmV2aWF0aW9ucyA9IFtcbiAgICBcInVzYVwiLFxuICAgIFwidXNcIixcbiAgICBcInVuaXRlZCBzdGF0ZXNcIixcbiAgICBcImFtZXJpY2FcIixcbiAgICBcInVuaXRlZCBzdGF0ZXMgb2YgYW1lcmljYVwiLFxuICBdO1xuICBpZiAoXG4gICAgaW52ZXN0b3JfZ2VvLnNvbWUoKGdlbykgPT4gZ2VvLmluY2x1ZGVzKFwiZ2xvYmFsbHlcIikpIHx8XG4gICAgaW52ZXN0b3JfZ2VvLnNvbWUoKGdlbykgPT4gZ2VvLmluY2x1ZGVzKFwiYWdub3N0aWNcIikpIHx8XG4gICAgaW52ZXN0b3JfZ2VvLnNvbWUoKGdlbykgPT4gZ2VvLmluY2x1ZGVzKFwid29ybGQtd2lkZVwiKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGludmVzdG9yX2dlby5zb21lKChnZW8pID0+IGdlby5pbmNsdWRlcyhpbnB1dF9jb3VudHJ5KSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgaXNDb3VudHJ5SW5FdXJvcGUoaW5wdXRfY291bnRyeSkgJiZcbiAgICAoaW52ZXN0b3JfZ2VvLnNvbWUoKGdlbykgPT4gZ2VvLmluY2x1ZGVzKFwiZXVyb3BlXCIpKSB8fFxuICAgICAgaW52ZXN0b3JfZ2VvLnNvbWUoKGdlbykgPT4gZ2VvLmluY2x1ZGVzKFwiZXVcIikpKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgaXNDb3VudHJ5SW5FYXN0ZXJuRXVyb3BlKGlucHV0X2NvdW50cnkpICYmXG4gICAgaW52ZXN0b3JfZ2VvLnNvbWUoKGdlbykgPT4gZ2VvLmluY2x1ZGVzKFwiZWFzdGVybiBldXJvcGVcIikpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBpc0NvdW50cnlJbk5vcmRpY3MoaW5wdXRfY291bnRyeSkgJiZcbiAgICBpbnZlc3Rvcl9nZW8uc29tZSgoZ2VvKSA9PiBnZW8uaW5jbHVkZXMoXCJub3JkaWNzXCIpKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodXNhX2FiYnJldmlhdGlvbnMuaW5jbHVkZXMoaW5wdXRfY291bnRyeSkpIHtcbiAgICBmb3IgKGxldCBnZW8gb2YgaW52ZXN0b3JfZ2VvKSB7XG4gICAgICBpZiAodXNhX2FiYnJldmlhdGlvbnMuc29tZSgoYWJicmV2KSA9PiBnZW8uaW5jbHVkZXMoYWJicmV2KSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RhZ2VfY2hlY2soaW5wdXRfc3RhZ2UsIGludmVzdG9yX3N0YWdlKSB7XG4gIGlucHV0X3N0YWdlID0gaW5wdXRfc3RhZ2UudG9Mb3dlckNhc2UoKTtcbiAgaWYgKFxuICAgIGludmVzdG9yX3N0YWdlLnNvbWUoKHN0YWdlKSA9PiBzdGFnZS5pbmNsdWRlcyhcInByZS1zZWVkXCIpKSB8fFxuICAgIGludmVzdG9yX3N0YWdlLnNvbWUoKHN0YWdlKSA9PiBzdGFnZS5pbmNsdWRlcyhcInByZXNlZWRcIikpXG4gICkge1xuICAgIGludmVzdG9yX3N0YWdlLnB1c2goXCJwcmUtc2VlZFwiKTtcbiAgICBpbnZlc3Rvcl9zdGFnZS5wdXNoKFwicHJlc2VlZFwiKTtcbiAgfVxuICByZXR1cm4gaW52ZXN0b3Jfc3RhZ2Uuc29tZSgoc3RhZ2UpID0+IHN0YWdlLmluY2x1ZGVzKGlucHV0X3N0YWdlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPYmplY3RzVG9NYXJrZG93blRhYmxlKG9iamVjdHMsIHNwZWNpYWxGb3JtYXQpIHtcbiAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBsZXQga2V5czogYW55ID0gW107XG4gIGlmIChzcGVjaWFsRm9ybWF0KSB7XG4gICAga2V5cyA9IGdldF9rZXlzX2Zvcl90YWJsZShPYmplY3Qua2V5cyhvYmplY3RzWzBdKSk7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdHNbMF0pO1xuICB9XG5cbiAgbGV0IHRhYmxlID0gXCJ8XCI7XG5cbiAgLy8gQWRkIGNvbHVtbiBoZWFkZXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHRhYmxlICs9IGAgJHtrZXlzW2ldfSB8YDtcbiAgfVxuXG4gIHRhYmxlICs9IFwiXFxufFwiO1xuXG4gIC8vIEFkZCBoZWFkZXIgc2VwYXJhdG9yXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHRhYmxlICs9IFwiIC0tLSB8XCI7XG4gIH1cblxuICAvLyBBZGQgcm93c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YWJsZSArPSBcIlxcbnxcIjtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGRpc3BsYXllZFJlc3VsdCA9IFwiXCI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoa2V5c1tqXSA9PSBcInRvdGFsTW9uZXlSYWlzZWRcIikge1xuICAgICAgICAgIGRpc3BsYXllZFJlc3VsdCA9XG4gICAgICAgICAgICBmb3JtYXROdW1iZXIob2JqZWN0c1tpXVtrZXlzW2pdXVtcInRvdGFsQW1vdW50XCJdW1wiYW1vdW50XCJdKSArXG4gICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICBvYmplY3RzW2ldW2tleXNbal1dW1widG90YWxBbW91bnRcIl1bXCJjdXJyZW5jeVwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlzW2pdID09IFwiaW52ZXN0b3JMaXN0XCIpIHtcbiAgICAgICAgICBsZXQgaW52ZXN0b3JMaXN0RGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IGludmVzdG9yIG9mIG9iamVjdHNbaV1bXCJpbnZlc3Rvckxpc3RcIl0pIHtcbiAgICAgICAgICAgIGxldCBpbnZlc3RvckRpc3BsYXkgPSBgWyR7aW52ZXN0b3JbXCJuYW1lXCJdfV0oaHR0cHM6Ly8ke2ludmVzdG9yW1wiZG9tYWluXCJdfSlgO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPT0gMCkge1xuICAgICAgICAgICAgICBpbnZlc3Rvckxpc3REaXNwbGF5ICs9IGludmVzdG9yRGlzcGxheTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGludmVzdG9yTGlzdERpc3BsYXkgKz0gXCIsIFwiICsgaW52ZXN0b3JEaXNwbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXNwbGF5ZWRSZXN1bHQgPSBpbnZlc3Rvckxpc3REaXNwbGF5O1xuICAgICAgICB9IGVsc2UgaWYgKGtleXNbal0gPT0gXCJsb2NhdGlvblwiKSB7XG4gICAgICAgICAgZGlzcGxheWVkUmVzdWx0ID0gb2JqZWN0c1tpXVtcImxvY2F0aW9uXCJdW1wiY291bnRyeVwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlzW2pdID09IFwidHJhY3huVGVhbVNjb3JlXCIgfHwga2V5c1tqXSA9PSBcInRyYWN4blNjb3JlXCIpIHtcbiAgICAgICAgICBkaXNwbGF5ZWRSZXN1bHQgPSBNYXRoLmNlaWwob2JqZWN0c1tpXVtrZXlzW2pdXSkudG9GaXhlZCgwKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlzW2pdID09IFwicHJvZmlsZUxpbmtzXCIpIHtcbiAgICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgW3R5cGUsIGxpbmtdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdHNbaV1bXCJwcm9maWxlTGlua3NcIl0pKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlciA9PSAwKSB7XG4gICAgICAgICAgICAgIGRpc3BsYXllZFJlc3VsdCArPSBgWyR7dHlwZX1dKCR7bGlua30pYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpc3BsYXllZFJlc3VsdCArPSBcIiwgXCIgKyBgWyR7dHlwZX1dKCR7bGlua30pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5c1tqXSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgIGxldCBkb21haW4gPSBvYmplY3RzW2ldW1wiZG9tYWluXCJdO1xuICAgICAgICAgIGRpc3BsYXllZFJlc3VsdCA9IGBbJHtvYmplY3RzW2ldW1wibmFtZVwiXX1dKGh0dHBzOi8vJHtkb21haW59KWA7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5c1tqXSA9PSBcIm1hcmtldENhcFwiKSB7XG4gICAgICAgICAgZGlzcGxheWVkUmVzdWx0ID1cbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihvYmplY3RzW2ldW1wibWFya2V0Q2FwXCJdW1wiYW1vdW50XCJdKSArXG4gICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICBvYmplY3RzW2ldW1wibWFya2V0Q2FwXCJdW1wiY3VycmVuY3lcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheWVkUmVzdWx0ID0gb2JqZWN0c1tpXVtrZXlzW2pdXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGAke29iamVjdHNbaV1bXCJuYW1lXCJdfSBoYWQgYW4gZXJyb3Igd2l0aCB0aGUga2V5ICR7a2V5c1tqXX1gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRhYmxlICs9IGAgJHtkaXNwbGF5ZWRSZXN1bHR9IHxgO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9yZWxldmFudF9mZWVkcyhzdGFydHVwc0xpc3Q6IGFueSkge1xuICBsZXQgcmVsZXZhbnRfZmVlZHMgPSB7fTtcbiAgZm9yIChsZXQgc3RhcnR1cCBvZiBzdGFydHVwc0xpc3QpIHtcbiAgICBsZXQgYnVzaW5lc3NNb2RlbHMgPSBzdGFydHVwW1wiYnVzaW5lc3NNb2RlbExpc3RcIl07XG4gICAgZm9yIChsZXQgYnVzaW5lc3NNb2RlbCBvZiBidXNpbmVzc01vZGVscykge1xuICAgICAgcmVsZXZhbnRfZmVlZHNbYnVzaW5lc3NNb2RlbFtcImZ1bGxQYXRoU3RyaW5nXCJdXSA9XG4gICAgICAgIGJ1c2luZXNzTW9kZWxbXCJjb21wYW5pZXNJbkVudGlyZVRyZWVVcmxcIl07XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxldmFudF9mZWVkcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRfZWxpZ2libGVfaW52ZXN0b3JzKGludmVzdG9ycywgaW5wdXRfY291bnRyeSwgaW5wdXRfc3RhZ2UpIHtcbiAgbGV0IGZpdF9pbnZlc3RvcnM6IGFueSA9IFtdO1xuICBmb3IgKGxldCBpbnZlc3RvciBvZiBpbnZlc3RvcnMpIHtcbiAgICBpZiAoXG4gICAgICBnZW9fY2hlY2soaW5wdXRfY291bnRyeSwgaW52ZXN0b3JbXCJnZW9cIl0pICYmXG4gICAgICBzdGFnZV9jaGVjayhpbnB1dF9zdGFnZSwgaW52ZXN0b3JbXCJzdGFnZVwiXSlcbiAgICApIHtcbiAgICAgIGZpdF9pbnZlc3RvcnMucHVzaChpbnZlc3Rvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXRfaW52ZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U3RhZ2Uoc3RyKSB7XG4gIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpOyAvLyBDb252ZXJ0IHN0ciB0byBsb3dlcmNhc2VcbiAgY29uc3Qga2V5d29yZHMgPSBbXG4gICAgXCJwcmUtc2VlZFwiLFxuICAgIFwicHJlc2VlZFwiLFxuICAgIFwic2VlZFwiLFxuICAgIFwic2VyaWVzIGFcIixcbiAgICBcInNlcmllcyBiXCIsXG4gICAgXCJzZXJpZXMgY1wiLFxuICAgIFwic2VyaWVzIGRcIixcbiAgXTtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGtleXdvcmRzLmpvaW4oXCJ8XCIpLCBcImdpXCIpO1xuICBjb25zdCBtZW50aW9ucyA9IHN0ci5tYXRjaChyZWdleCkgfHwgW1wiXCJdO1xuICByZXR1cm4gbWVudGlvbnM7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHZW9ncmFwaHkoc3RyKSB7XG4gIGNvbnN0IHJlZ2V4ID0gL0dlb2dyYXBoeTo6KC4qKS9pO1xuICBjb25zdCBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIGlmIChtYXRjaCkge1xuICAgIGxldCBsaW5lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgIGxldCBnZW9zID0gbGluZS5zcGxpdChcIixcIik7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZvciAobGV0IGdlbyBvZiBnZW9zKSB7XG4gICAgICBnZW9zW2NvdW50ZXJdID0gZ2VvLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY291bnRlciArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvcztcbiAgfVxuICByZXR1cm4gW1wiXCJdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SW5kdXN0cnkoc3RyKSB7XG4gIGNvbnN0IHJlZ2V4ID0gL0luZHVzdHJ5OjooLiopL2k7XG4gIGNvbnN0IG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgbGV0IGluZHVzdHJ5ID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgIHJldHVybiBpbmR1c3RyeTtcbiAgfVxuICByZXR1cm4gW1wiXCJdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U3BlY2lhbGl0eShzdHIpIHtcbiAgY29uc3QgcmVnZXggPSAvU3BlY2lhbDo6PyguKikvaTtcbiAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBsZXQgaW5kdXN0cnkgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgcmV0dXJuIGluZHVzdHJ5O1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9nZXRoZXJhaV9qcyhcbiAgdG9nZXRoZXJhaUFQSUtleTogc3RyaW5nLFxuICBtb2RlbF9uYW1lOiBzdHJpbmcsXG4gIHVzZXJfcHJvbXB0OiBzdHJpbmcsXG4gIHN5c3RlbV9wcm9tcHQ6IHN0cmluZyxcbiAgbWF4X3Rva2VuczogbnVtYmVyID0gMjU2LFxuICB0ZW1wZXJhdHVyZTogbnVtYmVyID0gMC4zLFxuICBtZXNzYWdlczogeyByb2xlOiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZyB9W10gPSBbXVxuKSB7XG4gIGxldCB0b2dldGhlcmFpID0gbmV3IE9wZW5BSSh7XG4gICAgYXBpS2V5OiB0b2dldGhlcmFpQVBJS2V5LFxuICAgIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlLFxuICAgIGJhc2VVUkw6IFwiaHR0cHM6Ly9hcGkudG9nZXRoZXIueHl6L3YxXCIsXG4gIH0pO1xuXG4gIHZhciByZXNwb25zZTtcbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCB0b2dldGhlcmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiBtb2RlbF9uYW1lLFxuICAgICAgdGVtcGVyYXR1cmU6IDAsXG4gICAgICB0b3BfcDogMC4wLFxuICAgICAgbWF4X3Rva2VuczogbWF4X3Rva2VucyxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogc3lzdGVtX3Byb21wdCB9LFxuICAgICAgICB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiB1c2VyX3Byb21wdCB9LFxuICAgICAgXSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXNwb25zZSA9IGF3YWl0IHRvZ2V0aGVyYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IG1vZGVsX25hbWUsXG4gICAgICB0ZW1wZXJhdHVyZTogMCxcbiAgICAgIHRvcF9wOiAwLjAsXG4gICAgICBtYXhfdG9rZW5zOiBtYXhfdG9rZW5zLFxuICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxuICAgIH0pO1xuICB9XG5cbiAgbGV0IHN1bW1hcnkgPSByZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcbiAgaWYgKHN1bW1hcnkgPT0gbnVsbCkge1xuICAgIHN1bW1hcnkgPSBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIHN1bW1hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnZlc3Rvck9iamVjdChcbiAgbmFtZSxcbiAgZ2VvZ3JhcGhpZXMsXG4gIHN0YWdlcyxcbiAgaW5kdXN0cnksXG4gIHNwZWNpYWxpdHlcbikge1xuICBjb25zdCBpbnZlc3Rvck9iamVjdCA9IHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGdlbzogZ2VvZ3JhcGhpZXMsXG4gICAgc3RhZ2U6IHN0YWdlcyxcbiAgICBpbmR1c3RyeTogaW5kdXN0cnksXG4gICAgc3BlY2lhbGl0eTogc3BlY2lhbGl0eSxcbiAgfTtcbiAgcmV0dXJuIGludmVzdG9yT2JqZWN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVfaW52ZXN0b3JfanNvbihcbiAgaW52ZXN0b3JfbmFtZTogc3RyaW5nLFxuICBpbnZlc3Rvcl90ZXh0OiBzdHJpbmdcbikge1xuICBsZXQgbmFtZSA9IGludmVzdG9yX25hbWU7XG4gIGxldCBnZW9ncmFwaGllcyA9IGV4dHJhY3RHZW9ncmFwaHkoaW52ZXN0b3JfdGV4dCk7XG4gIGxldCBzdGFnZXMgPSBleHRyYWN0U3RhZ2UoaW52ZXN0b3JfdGV4dCk7XG4gIGxldCBpbmR1c3RyeSA9IGV4dHJhY3RJbmR1c3RyeShpbnZlc3Rvcl90ZXh0KTtcbiAgbGV0IHNwZWNpYWxpdHkgPSBleHRyYWN0U3BlY2lhbGl0eShpbnZlc3Rvcl90ZXh0KTtcbiAgcmV0dXJuIGNyZWF0ZUludmVzdG9yT2JqZWN0KG5hbWUsIGdlb2dyYXBoaWVzLCBzdGFnZXMsIGluZHVzdHJ5LCBzcGVjaWFsaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUZXh0VG9FbmRPZkxpbmUoXG4gIGZ1bGxUZXh0OiBzdHJpbmcsXG4gIHNlYXJjaFN0cmluZzogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBjb25zdCBpbmRleCA9IGZ1bGxUZXh0LmluZGV4T2Yoc2VhcmNoU3RyaW5nKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGNvbnN0IGVuZE9mTGluZUluZGV4ID0gZnVsbFRleHQuaW5kZXhPZihcIlxcblwiLCBpbmRleCk7XG4gICAgaWYgKGVuZE9mTGluZUluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZ1bGxUZXh0XG4gICAgICAgIC5zdWJzdHJpbmcoaW5kZXggKyBzZWFyY2hTdHJpbmcubGVuZ3RoLCBlbmRPZkxpbmVJbmRleClcbiAgICAgICAgLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bGxUZXh0LnN1YnN0cmluZyhpbmRleCArIHNlYXJjaFN0cmluZy5sZW5ndGgpLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRfbWF0Y2hpbmdfcHJvbXB0KGludmVzdG9ycywgc3RhcnR1cF9kZXNjKSB7XG4gIC8vdG9kbyBjaGFuZ2UgdGhlIHByb21wdGluZyB0byBub3QgdGhpbmsgYWJvdXQgZWFjaCBzdGFydHVwP1xuICBsZXQgcHJvbXB0ID1cbiAgICBcIllvdSB3aWxsIG5vdyBnZXQgYSBsaXN0IG9mIGluZm9ybWF0aW9uIGFib3V0IHNvbWUgaW52ZXN0b3JzLiBQbGVhc2UgcmVhZCBpdCBjYXJlZnVsbHkgYmVjYXVzZSB5b3Ugd2lsbCBiZSBhc2tlZCBhYm91dCBpdCBsYXRlci5cXG5cXG48aW52ZXN0b3ItbGlzdD5cIjtcbiAgZm9yIChsZXQgaW52ZXN0b3Igb2YgaW52ZXN0b3JzKSB7XG4gICAgbGV0IGludmVzdG9yX25hbWUgPSBpbnZlc3RvcltcIm5hbWVcIl07XG4gICAgbGV0IGludmVzdG9yX2luZHVzdHJ5ID0gaW52ZXN0b3JbXCJpbmR1c3RyeVwiXTtcbiAgICBsZXQgaW52ZXN0b3Jfc3BlY2lhbGl0eSA9IGludmVzdG9yW1wic3BlY2lhbGl0eVwiXTtcbiAgICBsZXQgaW52ZXN0b3JfZGVzYyA9IGBcXG48aW52ZXN0b3ItaW5mbz5cXG4tIE5hbWU6ICR7aW52ZXN0b3JfbmFtZX1cXG4tIEluZHVzdHJ5OiAke2ludmVzdG9yX2luZHVzdHJ5fVxcbi0gU3BlY2lhbGl0eTogJHtpbnZlc3Rvcl9zcGVjaWFsaXR5fVxcbjwvaW52ZXN0b3ItaW5mbz5gO1xuICAgIHByb21wdCArPSBpbnZlc3Rvcl9kZXNjO1xuICB9XG4gIHByb21wdCArPSBcIlxcbjwvaW52ZXN0b3ItbGlzdD5cIjtcbiAgcHJvbXB0ICs9XG4gICAgXCJcXG5cXG5Ob3cgeW91IHdpbGwgYmUgZ2l2ZW4gc29tZSBpbmZvcm1hdGlvbiBhYm91dCBhIHN0YXJ0dXAuIFJlYWQgaXQgY2FyZWZ1bGx5LlwiO1xuXG4gIHByb21wdCArPSBgXFxuXFxuPHN0YXJ0dXAtaW5mbz5cXG4ke3N0YXJ0dXBfZGVzY31cXG48c3RhcnR1cC1pbmZvPlxcblxcbmA7XG4gIHByb21wdCArPSBgRnJvbSB0aGUgbGlzdCBvZiBpbnZlc3RvcnMsIGNob29zZSBvbmx5IHN1aXRhYmxlIGludmVzdG9ycyBmb3IgdGhlIHN0YXJ0dXAuXG5cbkZyb20gdGhlIGxpc3Qgb2YgaW52ZXN0b3JzLCBjaG9vc2UgYWxsIHN1aXRhYmxlIGludmVzdG9ycyBmb3IgdGhlIHN0YXJ0dXAuXG5cbkZpcnN0IHlvdSBtdXN0IHRoaW5rIGRlZXBseSBhYm91dCB0aGUgc3VpdGFiaWxpdHkgb2YgZWFjaCBzaW5nbGUgaW52ZXN0b3Igd2l0aCByZWdhcmQgdG8gdGhlIHN0YXJ0dXAgYmV0d2VlbiB0aGUgWE1MIHRhZ3MgPHRoaW5raW5nPiBhbmQgPC90aGlua2luZz4uIFRoZW4gZ2l2ZSB5b3VyIGZpbmFsIGFuc3dlciBhcyB0aGUgbmFtZXMgb2YgdGhlIHN1aXRhYmxlIGludmVzdG9ycyBkZWxpbWl0ZWQgYnkgY29tbWFzIGJldHdlZW4gdGhlIFhNTCB0YWdzIDxpbnZlc3RvcnM+IGFuZCA8L2ludmVzdG9ycz4uYDtcblxuICByZXR1cm4gcHJvbXB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFJlc29uaW5nVGV4dChpbnB1dFN0cmluZykge1xuICBjb25zdCBzdGFydFRhZyA9IFwiPHRoaW5raW5nPlwiO1xuICBjb25zdCBlbmRUYWcgPSBcIjwvdGhpbmtpbmc+XCI7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbnB1dFN0cmluZy5pbmRleE9mKHN0YXJ0VGFnKSArIHN0YXJ0VGFnLmxlbmd0aDtcbiAgY29uc3QgZW5kSW5kZXggPSBpbnB1dFN0cmluZy5pbmRleE9mKGVuZFRhZyk7XG5cbiAgaWYgKHN0YXJ0SW5kZXggPT09IC0xIHx8IGVuZEluZGV4ID09PSAtMSB8fCBzdGFydEluZGV4ID49IGVuZEluZGV4KSB7XG4gICAgcmV0dXJuIFwiXCI7IC8vIFJldHVybiBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIHRhZ3MgYXJlIG5vdCBmb3VuZCBvciBpbiB0aGUgd3Jvbmcgb3JkZXJcbiAgfVxuXG4gIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpLnRyaW0oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJbnZlc3RvcnNUZXh0KGlucHV0U3RyaW5nKSB7XG4gIGNvbnN0IHN0YXJ0VGFnID0gXCI8aW52ZXN0b3JzPlwiO1xuICBjb25zdCBlbmRUYWcgPSBcIjwvaW52ZXN0b3JzPlwiO1xuICBjb25zdCBzdGFydEluZGV4ID0gaW5wdXRTdHJpbmcuaW5kZXhPZihzdGFydFRhZykgKyBzdGFydFRhZy5sZW5ndGg7XG4gIGNvbnN0IGVuZEluZGV4ID0gaW5wdXRTdHJpbmcuaW5kZXhPZihlbmRUYWcpO1xuXG4gIGlmIChzdGFydEluZGV4ID09PSAtMSB8fCBlbmRJbmRleCA9PT0gLTEgfHwgc3RhcnRJbmRleCA+PSBlbmRJbmRleCkge1xuICAgIHJldHVybiBcIlwiOyAvLyBSZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSB0YWdzIGFyZSBub3QgZm91bmQgb3IgaW4gdGhlIHdyb25nIG9yZGVyXG4gIH1cblxuICByZXR1cm4gaW5wdXRTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIGVuZEluZGV4KS50cmltKCk7XG59XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgKiBhcyBzaGltcyBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG5pbXBvcnQgKiBhcyBhdXRvIGZyb20gJ29wZW5haS9fc2hpbXMvYXV0by9ydW50aW1lJztcbmlmICghc2hpbXMua2luZCkgc2hpbXMuc2V0U2hpbXMoYXV0by5nZXRSdW50aW1lKCksIHsgYXV0bzogdHJ1ZSB9KTtcbmV4cG9ydCAqIGZyb20gJy4vcmVnaXN0cnkubWpzJztcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nLCBGdXp6eVN1Z2dlc3RNb2RhbCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmV4cG9ydCBjbGFzcyBUZXh0SW5wdXRNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgaW5wdXQ6IHN0cmluZztcbiAgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkO1xuICB0eXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHR5cGU6IHN0cmluZywgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm9uc3VibWl0ID0gb25zdWJtaXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBsZXQgdGl0bGUgPSBcIlwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJtYXJrZXQtcmVzZWFyY2hcIikge1xuICAgICAgdGl0bGUgPSBcIldoYXQgaW5kdXN0cnkgZG8geW91IHdhbnQgdG8gcmVzZWFyY2g/XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJkZWZlbnNpYmlsaXR5XCIpIHtcbiAgICAgIHRpdGxlID0gXCJEZXNjcmliZSB0aGUgc3RhcnR1cCB3aG9zZSBkZWZlbnNpYmlsaXR5IGlzIHRvIGJlIGV2YWx1YXRlZFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09IFwiZXZhbHVhdGVcIikge1xuICAgICAgdGl0bGUgPSBcIkRlc2NyaWJlIHRoZSBzdGFydHVwIHRvIGJlIGV2YWx1YXRlZFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09IFwidXJsLXJlc2VhcmNoXCIpIHtcbiAgICAgIHRpdGxlID0gXCJFbnRlciB1cmwgdG8gaW52ZXN0aWdhdGVcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PSBcImZpcmVmbGllcy1zdW1tYXJ5XCIpIHtcbiAgICAgIHRpdGxlID1cbiAgICAgICAgXCJJbnNlcnQgdGhlIG5hbWUgb2YgdGhlIGZpcmVmbGllcyByZWNvcmRpbmcvbWVldGluZyB5b3Ugd291bGQgbGlrZSB0byBzdW1tYXJpemVcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PSBcImNvbXBldGl0aW9uXCIpIHtcbiAgICAgIHRpdGxlID0gXCJEZXNjcmliZSB0aGUgc3RhcnR1cCBvciBpbmR1c3RyeSBmb3IgY29tcGV0aXRpb24gcmVzZWFyY2hcIjtcbiAgICB9XG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiB0aXRsZSB9KTtcblxuICAgIGNvbnN0IGlucHV0RWwgPSBjb250ZW50RWwuY3JlYXRlRWwoXCJ0ZXh0YXJlYVwiKTtcblxuICAgIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzdWJtaXRCdXR0b24gPSBjb250ZW50RWwuY3JlYXRlRWwoXCJidXR0b25cIiwgeyB0ZXh0OiBcIlN1Ym1pdFwiIH0pO1xuICAgIHN1Ym1pdEJ1dHRvbi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBzdWJtaXRCdXR0b24uc3R5bGUuYm90dG9tID0gXCIwXCI7XG4gICAgc3VibWl0QnV0dG9uLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG5cbiAgICBzdWJtaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25zdWJtaXQoaW5wdXRFbC52YWx1ZSk7IC8vaW5wdXRFbC52YWx1ZVxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgbGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNdWx0aXBsZVRleHRJbnB1dE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBpbnB1dDogc3RyaW5nO1xuICBvbnN1Ym1pdDogKGlucHV0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHR5cGU6IHN0cmluZztcbiAgcXVlcnk6IHN0cmluZztcbiAgd2Vic2l0ZTogc3RyaW5nO1xuICB0YXNrOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHR5cGU6IHN0cmluZywgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm9uc3VibWl0ID0gb25zdWJtaXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBsZXQgdGl0bGUgPSBcIldoYXQgdG9waWMgd291bGQgeW91IGxpa2UgdG8gcmVzZWFyY2ggdG9kYXk/XCI7XG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiB0aXRsZSB9KTtcblxuICAgIGxldCBxdWVyeSA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuc2V0TmFtZShcIlNlYXJjaCBRdWVyeVwiKS5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgdGV4dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHZhbHVlO1xuICAgICAgfSlcbiAgICApO1xuICAgIGxldCB3ZWIgPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAuc2V0TmFtZShcIldlYnNpdGUgdG8gU2VhcmNoXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLndlYnNpdGUgPSB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpLnNldE5hbWUoXCJUYXNrIHRvIGRvXCIpLmFkZERyb3Bkb3duKChtZW51KSA9PiB7XG4gICAgICBtZW51LmFkZE9wdGlvbihcImNvbXBldGl0aW9uXCIsIFwiRmluZCAmIEFuYWx5emUgY29tcGV0aXRvcnNcIik7XG4gICAgICBtZW51LmFkZE9wdGlvbihcIm1hcmtldC1yZXNlYXJjaFwiLCBcIkludmVzdG9yIFN1bW1hcnlcIik7XG4gICAgICBtZW51LnNldFZhbHVlKFwiLi4uLlwiKTtcbiAgICAgIG1lbnUub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMudGFzayA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBsZXQgYnV0dG9uID0gbmV3IFNldHRpbmcoY29udGVudEVsKS5hZGRCdXR0b24oKGJ0bikgPT4ge1xuICAgICAgYnRuXG4gICAgICAgIC5zZXRCdXR0b25UZXh0KFwiU3VibWl0XCIpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMub25zdWJtaXQodGhpcy53ZWJzaXRlICsgXCIsIFwiICsgdGhpcy5xdWVyeSArIFwiLCBcIiArIHRoaXMudGFzayk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGaXJlRmxpZXNUZW1wIGV4dGVuZHMgTW9kYWwge1xuICBpbnB1dDogc3RyaW5nO1xuICBvbnN1Ym1pdDogKGlucHV0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGpzb25fc3RyaW5nOiBzdHJpbmc7XG4gIG1lZXRpbmdfbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvbnN1Ym1pdDogKGlucHV0OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMub25zdWJtaXQgPSBvbnN1Ym1pdDtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBsZXQgdGl0bGUgPSBcIkdpdmUgbWUgdGhlIGpzb24gc3RyaW5nIG9mIHRyYW5zY3JpcHRcIjtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IHRpdGxlIH0pO1xuXG4gICAgbGV0IHF1ZXJ5ID0gbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLnNldE5hbWUoXCJKc29uIFN0cmluZ1wiKVxuICAgICAgLmFkZFRleHRBcmVhKCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuanNvbl9zdHJpbmcgPSB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgbGV0IHdlYiA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuc2V0TmFtZShcIk1lZXRpbmcgbmFtZVwiKS5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgdGV4dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5tZWV0aW5nX25hbWUgPSB2YWx1ZTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGxldCBidXR0b24gPSBuZXcgU2V0dGluZyhjb250ZW50RWwpLmFkZEJ1dHRvbigoYnRuKSA9PiB7XG4gICAgICBidG5cbiAgICAgICAgLnNldEJ1dHRvblRleHQoXCJTdWJtaXRcIilcbiAgICAgICAgLnNldEN0YSgpXG4gICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vbnN1Ym1pdCh0aGlzLmpzb25fc3RyaW5nICsgXCImJiYgXCIgKyB0aGlzLm1lZXRpbmdfbmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTcG9rZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBpbnB1dDogc3RyaW5nO1xuICBvbnN1Ym1pdDogKGlucHV0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIG1lZXRpbmdfbmFtZTogc3RyaW5nO1xuICBpc0RldGFpbGVkOiBib29sZWFuO1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvbnN1Ym1pdDogKGlucHV0OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMub25zdWJtaXQgPSBvbnN1Ym1pdDtcbiAgICB0aGlzLmlzRGV0YWlsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBsZXQgdGl0bGUgPSBcIlN1bW1hcmlzZSB0aGUgY2FsbCByZWNvcmRlZCBieSBTcG9rZS5hcHBcIjtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IHRpdGxlIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKFwiTWVldGluZyBuYW1lXCIpLmFkZFRleHQoKHRleHQpID0+XG4gICAgICB0ZXh0Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLm1lZXRpbmdfbmFtZSA9IHZhbHVlO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLnNldE5hbWUoXCJEZXRhaWxlZCBNZWV0aW5nXCIpXG4gICAgICAuYWRkVG9nZ2xlKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgY29tcG9uZW50Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuaXNEZXRhaWxlZCA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKFwiTW9kZWwgdG8gdXNlXCIpLmFkZERyb3Bkb3duKChtZW51KSA9PiB7XG4gICAgICBtZW51LmFkZE9wdGlvbihcIm9wZW5haVwiLCBcIkdQVC00LVR1cmJvXCIpO1xuICAgICAgbWVudS5hZGRPcHRpb24oXCJtZXRhLWxsYW1hL0xsYW1hLTMtOGItY2hhdC1oZlwiLCBcIkxsYW1hLTMtNzBCXCIpO1xuICAgICAgbWVudS5zZXRWYWx1ZShcIi4uLi5cIik7XG4gICAgICBtZW51Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLm1vZGVsID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxldCBidXR0b24gPSBuZXcgU2V0dGluZyhjb250ZW50RWwpLmFkZEJ1dHRvbigoYnRuKSA9PiB7XG4gICAgICBidG5cbiAgICAgICAgLnNldEJ1dHRvblRleHQoXCJTdWJtaXRcIilcbiAgICAgICAgLnNldEN0YSgpXG4gICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vbnN1Ym1pdChcbiAgICAgICAgICAgIHRoaXMubWVldGluZ19uYW1lICsgXCIsIFwiICsgdGhpcy5pc0RldGFpbGVkICsgXCIsIFwiICsgdGhpcy5tb2RlbFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXb3JrZmxvd01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBkZXNjOiBzdHJpbmc7XG4gIG9uc3VibWl0OiAoaW5wdXQ6IHN0cmluZykgPT4gdm9pZDtcbiAgLy9pc0dyb3E6IGJvb2xlYW47XG4gIG1vZGVsX25hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm9uc3VibWl0ID0gb25zdWJtaXQ7XG4gICAgLy90aGlzLmlzR3JvcSA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWxfbmFtZSA9IFwiXCI7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgbGV0IHRpdGxlID1cbiAgICAgIFwiRGVzY3JpYmUgdGhlIHN0YXJ0dXAgeW91IHdhbnQgdG8gYW5hbHl6ZSBhbmQgaWYgeW91IHdhbnQgdG8gdXNlIEdyb3FcIjtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IHRpdGxlIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKFwiU3RhcnR1cCBEZXNjcmlwdGlvblwiKS5hZGRUZXh0QXJlYSgodGV4dCkgPT5cbiAgICAgIHRleHQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuZGVzYyA9IHZhbHVlO1xuICAgICAgfSlcbiAgICApO1xuICAgIC8qbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKFwiVXNlIEdyb3E/XCIpLmFkZFRvZ2dsZSgoY29tcG9uZW50KSA9PiB7XG4gICAgICBjb21wb25lbnQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuaXNHcm9xID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTsqL1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKFwiTW9kZWwgdG8gdXNlXCIpLmFkZERyb3Bkb3duKChtZW51KSA9PiB7XG4gICAgICBtZW51LmFkZE9wdGlvbihcIm9wZW5haVwiLCBcIkdQVC00LVR1cmJvXCIpO1xuICAgICAgbWVudS5hZGRPcHRpb24oXCJtZXRhLWxsYW1hL0xsYW1hLTMtOGItY2hhdC1oZlwiLCBcIkxsYW1hLTMtNzBCXCIpO1xuICAgICAgbWVudS5hZGRPcHRpb24oXCJncm9xXCIsIFwiR3JvcVwiKTtcbiAgICAgIG1lbnUuc2V0VmFsdWUoXCIuLi4uXCIpO1xuICAgICAgbWVudS5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5tb2RlbF9uYW1lID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxldCBidXR0b24gPSBuZXcgU2V0dGluZyhjb250ZW50RWwpLmFkZEJ1dHRvbigoYnRuKSA9PiB7XG4gICAgICBidG5cbiAgICAgICAgLnNldEJ1dHRvblRleHQoXCJTdWJtaXRcIilcbiAgICAgICAgLnNldEN0YSgpXG4gICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vbnN1Ym1pdCh0aGlzLmRlc2MgKyBcIi8vLS0gXCIgKyB0aGlzLm1vZGVsX25hbWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmluZEludmVzdG9yTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGlucHV0OiBzdHJpbmc7XG4gIG9uc3VibWl0OiAoaW5wdXQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY29tcGFueTogc3RyaW5nO1xuICBzdGFnZTogc3RyaW5nO1xuICBsb2NhdGlvbjogc3RyaW5nO1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG9uc3VibWl0OiAoaW5wdXQ6IHN0cmluZykgPT4gdm9pZCkge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5vbnN1Ym1pdCA9IG9uc3VibWl0O1xuICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgbGV0IHRpdGxlID0gXCJEZXNjcmliZSB0aGUgc3RhcnR1cCB5b3Ugd2FudCB0byBmaW5kIGludmVzdG9ycyBmb3JcIjtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IHRpdGxlIH0pO1xuXG4gICAgbGV0IHF1ZXJ5ID0gbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLnNldE5hbWUoXCJTdGFydHVwIERlc2NyaXB0aW9uXCIpXG4gICAgICAuYWRkVGV4dEFyZWEoKHRleHQpID0+XG4gICAgICAgIHRleHQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5jb21wYW55ID0gdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIGxldCB3ZWIgPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAuc2V0TmFtZShcIlN0YWdlXCIpXG4gICAgICAuc2V0RGVzYyhcImUuZywgUHJlc2VlZCwgU2VlZCwgZXRjXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YWdlID0gdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgLnNldE5hbWUoXCJMb2NhdGlvblwiKVxuICAgICAgLnNldERlc2MoXCJpbnNlcnQgdGhlIGNvdW50cnkgd2hlcmUgdGhlIHN0YXJ0dXAgaXMgbG9jYXRlZFwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgIC5zZXROYW1lKFwiRG8geW91IHdhbnQgdG8gZm9jdXMgdGhlIHNlYXJjaCBvbiBzdHJvbmcgY29ubmVjdGlvbnM/XCIpXG4gICAgICAuYWRkVG9nZ2xlKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgY29tcG9uZW50Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBsZXQgYnV0dG9uID0gbmV3IFNldHRpbmcoY29udGVudEVsKS5hZGRCdXR0b24oKGJ0bikgPT4ge1xuICAgICAgYnRuXG4gICAgICAgIC5zZXRCdXR0b25UZXh0KFwiU3VibWl0XCIpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMub25zdWJtaXQoXG4gICAgICAgICAgICB0aGlzLmNvbXBhbnkgK1xuICAgICAgICAgICAgICBcIiwgXCIgK1xuICAgICAgICAgICAgICB0aGlzLnN0YWdlICtcbiAgICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiArXG4gICAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBERk1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8VEZpbGU+IHtcbiAgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvbnN1Ym1pdDogKGlucHV0OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMub25zdWJtaXQgPSBvbnN1Ym1pdDtcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IFRGaWxlW10ge1xuICAgIHJldHVybiB0aGlzLmFwcC52YXVsdFxuICAgICAgLmdldEZpbGVzKClcbiAgICAgIC5maWx0ZXIoKGZpbGUpID0+IGZpbGUuZXh0ZW5zaW9uLmluY2x1ZGVzKFwicGRmXCIpKTtcbiAgICAvL3JldHVybiBBTExfQk9PS1M7XG4gIH1cblxuICBnZXRJdGVtVGV4dChmaWxlOiBURmlsZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGZpbGUubmFtZTtcbiAgfVxuXG4gIG9uQ2hvb3NlSXRlbShmaWxlOiBURmlsZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIC8vbmV3IE5vdGljZShgU2VsZWN0ZWQgJHtmaWxlLnBhdGh9YCk7XG5cbiAgICAvL2xldCB4ID0gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlLnBhdGgpXG4gICAgdGhpcy5vbnN1Ym1pdChmaWxlLnBhdGgpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFjeG5Nb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgaW5wdXQ6IHN0cmluZztcbiAgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkO1xuICBpc0lQTzogYm9vbGVhbjtcbiAgaXNBY3F1aXJlZDogYm9vbGVhbjtcbiAgY29tcGFueTogc3RyaW5nO1xuICBjb21wYW5pZXNfcGVyX3JlcXVlc3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgb25zdWJtaXQ6IChpbnB1dDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm9uc3VibWl0ID0gb25zdWJtaXQ7XG4gICAgdGhpcy5pc0lQTyA9IGZhbHNlO1xuICAgIHRoaXMuaXNBY3F1aXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29tcGFuaWVzX3Blcl9yZXF1ZXN0ID0gXCIzXCI7XG4gIH1cbiAgb25PcGVuKCkge1xuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGxldCB0aXRsZSA9IFwiQ29tcGV0aXRvciBPdmVydmlldyB0aHJvdWdoIFRyYWN4blwiO1xuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogdGl0bGUgfSk7XG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDVcIiwge1xuICAgICAgdGV4dDogXCJJUE8gYW5kIEFjcXVpc2l0aW9uIGFyZSBtdXR1YWxseSBleGNsdXNpdmVcIixcbiAgICB9KTtcblxuICAgIGxldCBxdWVyeSA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgIC5zZXROYW1lKFwiQ29tcGFueSBEb21haW5cIilcbiAgICAgIC5zZXREZXNjKFwiZS5nOiB0cmFjeG4uY29tLiBEbyBub3QgYWRkIGh0dHA6Ly9cIilcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuY29tcGFueSA9IHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIGxldCBpcG8gPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAuc2V0TmFtZShcIklQT2VkIGNvbXBldGl0b3JzP1wiKVxuICAgICAgLmFkZFRvZ2dsZSgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgIGNvbXBvbmVudC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLmlzSVBPID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBsZXQgYWNxdWlyZWQgPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAuc2V0TmFtZShcIkFjcXVpcmVkIGNvbXBldGl0b3JzP1wiKVxuICAgICAgLmFkZFRvZ2dsZSgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgIGNvbXBvbmVudC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLmlzQWNxdWlyZWQgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgIC5zZXROYW1lKFwiTnVtYmVyIG9mIGNvbXBhbmllcyBwZXIgcmVxdWVzdFwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHQub25DaGFuZ2UoKHZhbHVlKSA9PiAodGhpcy5jb21wYW5pZXNfcGVyX3JlcXVlc3QgPSB2YWx1ZSkpXG4gICAgICApO1xuXG4gICAgbGV0IGJ1dHRvbiA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuYWRkQnV0dG9uKChidG4pID0+IHtcbiAgICAgIGJ0blxuICAgICAgICAuc2V0QnV0dG9uVGV4dChcIlN1Ym1pdFwiKVxuICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLm9uc3VibWl0KFxuICAgICAgICAgICAgdGhpcy5jb21wYW55ICtcbiAgICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgICAgdGhpcy5pc0lQTyArXG4gICAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICAgIHRoaXMuaXNBY3F1aXJlZCArXG4gICAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICAgIHRoaXMuY29tcGFuaWVzX3Blcl9yZXF1ZXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsICJmdW5jdGlvbiBmb3JtYXRfdXJsX3RleHQoZmluYWxfdGV4dCwgdXJsKSB7XG4gIGZpbmFsX3RleHQgPSBgIyMgJHt1cmx9IFJlc2VhcmNoXFxuYCArIGZpbmFsX3RleHQ7XG4gIGZpbmFsX3RleHQgPSBmaW5hbF90ZXh0LnJlcGxhY2UoXG4gICAgXCJQcm9ibGVtIHRvIGJlIHNvbHZlZDpcIixcbiAgICBcIiMjIyMgUHJvYmxlbSB0byBiZSBzb2x2ZWRcIlxuICApO1xuICBmaW5hbF90ZXh0ID0gZmluYWxfdGV4dC5yZXBsYWNlKFwiUHJvZHVjdDpcIiwgXCIjIyMjIFByb2R1Y3RcIik7XG4gIGZpbmFsX3RleHQgPSBmaW5hbF90ZXh0LnJlcGxhY2UoXCJGZWF0dXJlczpcIiwgXCIjIyMjIEZlYXR1cmVzXCIpO1xuICBmaW5hbF90ZXh0ID0gZmluYWxfdGV4dC5yZXBsYWNlKFwiQnVzaW5lc3MgTW9kZWw6XCIsIFwiIyMjIyBCdXNpbmVzcyBNb2RlbFwiKTtcbiAgZmluYWxfdGV4dCA9IGZpbmFsX3RleHQucmVwbGFjZShcIkNvbXBldGl0aW9uOlwiLCBcIiMjIyMgQ29tcGV0aXRpb25cIik7XG4gIGZpbmFsX3RleHQgPSBmaW5hbF90ZXh0LnJlcGxhY2UoXCJWaXNpb246XCIsIFwiIyMjIyBWaXNpb25cIik7XG4gIGZpbmFsX3RleHQgPSBmaW5hbF90ZXh0LnJlcGxhY2UoXCJFeHRyYXM6XCIsIFwiIyMjIyBFeHRyYXNcIik7XG4gIHJldHVybiBmaW5hbF90ZXh0O1xufVxuXG5leHBvcnQgeyBmb3JtYXRfdXJsX3RleHQgfTtcbiIsICJpbXBvcnQgeyByZXF1ZXN0LCBFZGl0b3IsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZ3B0XzNfbGF0ZXN0LCBncHRfNF9sYXRlc3QgfSBmcm9tIFwiLi9tYWluXCI7XG5cbmFzeW5jIGZ1bmN0aW9uIHNwZWNpZmljX3dlYl9yZXNlYXJjaChcbiAgdGFzazogc3RyaW5nLFxuICB3ZWJzaXRlOiBzdHJpbmcsXG4gIHNlYXJjaF9xdWVyeTogc3RyaW5nLFxuICBvcGVuYWk6IGFueSxcbiAgZWRpdG9yOiBFZGl0b3Jcbikge1xuICBsZXQgcHJlc2VudGF0aW9uX3Byb21wdCA9IFwiU3VtbWFyaXplIHRoZSBmb2xsb3dpbmcgcGFyYWdyYXBocy5cIjtcbiAgbGV0IHRpdGxlID0gXCJOZXcgU2VjdGlvblwiO1xuICBpZiAodGFzay50b0xvd2VyQ2FzZSgpID09IFwiY29tcGV0aXRpb25cIikge1xuICAgIHRpdGxlID0gXCJDb21wZXRpdGlvbiBSZXNlYXJjaFwiO1xuXG4gICAgcHJlc2VudGF0aW9uX3Byb21wdCA9IGBIaWdobGlnaHQgdGhlIG1vc3QgaW1wb3J0YW50IGZhY3RzIGZvciBhbiBpbnZlc3RvciBmcm9tIHRoZSBmb2xsb3dpbmcgcGFyYWdyYXBocy4gSWYgdGhlcmUgYXJlIG5vbmUsIHNheSBcIk5vdGhpbmdcIi4gT3RoZXJ3aXNlIGFsd2F5cyByZXNwb25kIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBcbiAgICAgICAgICAgIC0gUHJvYmxlbXMgdG8gYmUgc29sdmVkXG4gICAgICAgICAgICAtIFByb2R1Y3QgYW5kIFRlY2hub2xvZ3lcbiAgICAgICAgICAgIC0gTW9uZXkgcmFpc2VkXG4gICAgICAgICAgICAtIFRlYW1cbiAgICAgICAgICAgIC0gT3RoZXIgaW1wb3J0YW50IHBvaW50c2A7XG4gIH0gZWxzZSBpZiAodGFzay50b0xvd2VyQ2FzZSgpID09IFwibWFya2V0LXJlc2VhcmNoXCIpIHtcbiAgICB0aXRsZSA9IFwiTWFya2V0IFJlc2VhcmNoXCI7XG4gICAgbGV0IGluZHVzdHJ5ID0gc2VhcmNoX3F1ZXJ5LnNwbGl0KFwiaW5kdXN0cnkgbWFya2V0XCIpWzBdO1xuICAgIHByZXNlbnRhdGlvbl9wcm9tcHQgPSBgV2hhdCBmYWN0cyBhYm91dCB0aGUgJHtpbmR1c3RyeX0gbWFya2V0IGNhbiBhbiBpbnZlc3RvciBsZWFybiBmcm9tIHRoZSBmb2xsb3dpbmcgcGFyYWdyYXBocz8gSWYgdGhlcmUgYXJlIG5vIGZhY3RzIHRvIGxlYXJuIHNpbXBseSBvdXRwdXQgXFxcIk5vdGhpbmdcXFwiYDtcbiAgfVxuXG4gIGxldCBtZXNzYWdlID0gYXdhaXQgZXhlY3V0ZV9zZWFyY2hfdGFzayhcbiAgICB0aXRsZSxcbiAgICB3ZWJzaXRlLFxuICAgIHNlYXJjaF9xdWVyeSxcbiAgICBwcmVzZW50YXRpb25fcHJvbXB0LFxuICAgIG9wZW5haSxcbiAgICBlZGl0b3JcbiAgKTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVfc2VhcmNoX3Rhc2soXG4gIHRhc2s6IHN0cmluZyxcbiAgd2Vic2l0ZTogc3RyaW5nLFxuICBzZWFyY2hfcXVlcnk6IHN0cmluZyxcbiAgcHJlc2VudGF0aW9uX3Byb21wdDogc3RyaW5nLFxuICBvcGVuYWk6IGFueSxcbiAgZWRpdG9yOiBFZGl0b3Jcbikge1xuICB0cnkge1xuICAgIGxldCB3ZWJzaXRlX25hbWUgPSBcIlwiO1xuICAgIGlmICh3ZWJzaXRlID09IFwiXCIpIHtcbiAgICAgIHdlYnNpdGVfbmFtZSA9IFwiZ2VuZXJhbCByZXNlYXJjaFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ZWJzaXRlX25hbWUgPSB3ZWJzaXRlLnNwbGl0KFwiLlwiKVswXTtcbiAgICB9XG5cbiAgICBsZXQgbWVzc2FnZSA9IGAjIyMjICR7dGFza30gdGhyb3VnaCAke3dlYnNpdGVfbmFtZX1cXG5gO1xuXG4gICAgbGV0IHN1bW1hcmllczogc3RyaW5nW10gPSBbXTtcbiAgICBsZXQgc291cmNlczogc3RyaW5nW10gPSBbXTtcblxuICAgIGxldCBxdWVyeSA9IGBzaXRlOiR7d2Vic2l0ZX0gJHtzZWFyY2hfcXVlcnl9YDtcblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCB5b3VfcmVzZWFyY2gocXVlcnkpO1xuXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgbGV0IHVzZXJfcHJvbXB0ID0gcHJlc2VudGF0aW9uX3Byb21wdDtcblxuICAgIGZvciAobGV0IGVsZW1lbnQgb2YgcmVzdWx0KSB7XG4gICAgICBsZXQgc25pcHBldHMgPSBlbGVtZW50W1wic25pcHBldHNcIl07XG4gICAgICBsZXQgdGl0bGUgPSBlbGVtZW50W1widGl0bGVcIl07XG4gICAgICBsZXQgdXJsID0gZWxlbWVudFtcInVybFwiXTtcblxuICAgICAgbGV0IHN1bW1hcnkgPSBcIlwiO1xuXG4gICAgICAvL2ZvciAobGV0IGkgPSAwOyBpIDwgc25pcHBldHMubGVuZ3RoOyBpKz01KXtcbiAgICAgIGxldCBwYXJhZ3JhcGhzID0gc25pcHBldHM7IC8vLnNsaWNlKGksIGkrNSkgLy90b2RvIDEyOGsgY29udGV4dCwgbWF5YmUgZG8gaXQgYWxsIGluIG9uZSBnby4gcG90ZW50aWFsbHkgY2hhbmdlIHRoaXM/XG4gICAgICBwYXJhZ3JhcGhzWzBdID0gXCItIFwiICsgcGFyYWdyYXBoc1swXTtcbiAgICAgIGxldCBzdHJpbmdfcGFyYWdyYXBocyA9IHBhcmFncmFwaHMuam9pbihcIlxcblxcbi0gXCIpO1xuICAgICAgaWYgKHN0cmluZ19wYXJhZ3JhcGhzICYmIHN0cmluZ19wYXJhZ3JhcGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgICAgIG1vZGVsOiBncHRfM19sYXRlc3QsIC8vZ3B0LTQgZ3B0LTMuNS10dXJibyAgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgICAgY29udGVudDpcbiAgICAgICAgICAgICAgICBcIkFjdCBhcyBhbiBpbnZlc3RpZ2F0aXZlIGpvdXJuYWxpc3Qgd2hvIGlzIG9ic2Vzc2VkIHdpdGggdGhlIHRydXRoIGFuZCBhY2N1cmFjeS4gWW91IGFsd2F5cyBnaXZlIGFuc3dlcnMgaW4gYnVsbGV0IHBvaW50cy5cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgICBjb250ZW50OiBgJHt1c2VyX3Byb21wdH1gICsgXCJcXG5QYXJhZ3JhcGhzOlxcblwiICsgc3RyaW5nX3BhcmFncmFwaHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IDAsXG4gICAgICAgICAgbWF4X3Rva2VuczogMTAyNCxcbiAgICAgICAgICB0b3BfcDogMSxcbiAgICAgICAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICAgICAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxuICAgICAgICB9KTtcblxuICAgICAgICBzdW1tYXJ5ICs9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50ICsgXCJcXG5cIjsgLy9yZXNwb25zZS5kYXRhLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50ICsgJ1xcbidcbiAgICAgIH1cblxuICAgICAgLy99XG5cbiAgICAgIHN1bW1hcmllcy5wdXNoKHN1bW1hcnkpO1xuICAgICAgbGV0IHNvdXJjZSA9IGBbJHt0aXRsZX1dKCR7dXJsfSlgO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICBjb3VudGVyKys7XG5cbiAgICAgIC8vdG9kbyBtYWtlIHRoaXMgdmFyaWFibGUgcmVnYXJkaW5nIGhvdyBtYW55IHNvdXJjZXMgd2UgdGFrZVxuICAgICAgaWYgKGNvdW50ZXIgPT0gNSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1bW1hcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgbWVzc2FnZSArPSBgIyMjIyMgJHtzb3VyY2VzW2ldfVxcbmA7XG4gICAgICBtZXNzYWdlICs9IHN1bW1hcmllc1tpXSArIFwiXFxuXFxuXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coYEVycm9yIHdoaWxlIGRvaW5nIHJlc2VhcmNoOiAke2Vycm9yfWApO1xuICAgIG5ldyBOb3RpY2UoYEVycm9yIHdoaWxlIGRvaW5nIHJlc2VhcmNoYCk7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cblxuYXN5bmMgZnVuY3Rpb24geW91X3Jlc2VhcmNoKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCByZXF1ZXN0KHtcbiAgICB1cmw6IGBodHRwczovL3lvdS1yZXNlYXJjaGVyLWNvbnRhaW5lci14bTVsbWRuc3hxLXVjLmEucnVuLmFwcC9zZWFyY2g/cXVlcnk9JHtxdWVyeX1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgfSk7XG4gIHJldHVybiBhd2FpdCBKU09OLnBhcnNlKHJlc3VsdHMpW1wiaGl0c1wiXTtcbn1cblxuZXhwb3J0IHsgc3BlY2lmaWNfd2ViX3Jlc2VhcmNoLCB5b3VfcmVzZWFyY2ggfTtcbiIsICJjb25zdCBERUZFTlNJQklMSVRZX0FOQUxZU0lTX1NZU1RFTV9QUk9NUFQgPVxuICBcIlVzZSB0aGUgZm9sbG93aW5nIGd1aWRlbGluZXMgdG8gZGV0ZXJtaW5lIHdoYXQga2luZHMgb2YgZGVmZW5zaWJpbGl0eSBhIHN0YXJ0dXAgY2FuIGJ1aWxkIHdpdGggdGltZTpcXG5cXFxuLSAqKk5ldHdvcmsgZWZmZWN0Kio6IFdoZW4gZXZlcnkgdXNlciBjcmVhdGVzIG1vcmUgdmFsdWUgZm9yIG90aGVyIHVzZXJzLCBmb3JtaW5nIGEgcG9zaXRpdmUgZmVlZGJhY2sgbG9vcC4gVGhpcyBjYW4gYmUgbG9jYWwgb3IgZ2xvYmFsLCBhbmQgaXMgb25lIG9mIHRoZSBmZXcgZm9ybXMgb2YgZGVmZW5zaWJpbGl0eSB0aGF0IGNhbiBhcmlzZSBpbW1lZGlhdGVseSB1cG9uIGxhdW5jaCBvZiBhIGNvbXBhbnkuXFxuXFxcbi0gKipQbGF0Zm9ybSBlZmZlY3QqKjogV2hlbiBhIGNvbXBhbnkgYmVjb21lcyBhIHN0aWNreSBwcm9kdWN0IGJlY2F1c2Ugc28gbWFueSBvdGhlciBjb21wYW5pZXMgaGF2ZSBpbnRlZ3JhdGVkIGFnYWluc3QgaXQuIFRoaXMgdXN1YWxseSBjb21lcyBhZnRlciBhIGNvbXBhbnkgaGFzIGVub3VnaCB1c2VycyB0aGF0IG90aGVycyB3YW50IHRvIGJ1aWxkIGFnYWluc3QgaXRzIHBsYXRmb3JtIHRvIHJlYWNoIHRoZW0uXFxuXFxcbi0gKipJbnRlZ3JhdGlvbnMqKjogV2hlbiBhIGNvbXBhbnkgaW50ZWdyYXRlcyBhZ2FpbnN0IG1hbnkgb3RoZXIgQVBJcywgY29kZSBiYXNlcywgZXRjLiB0aGF0IGFyZSBoYXJkIHRvIHJlcHJvZHVjZSwgb3Igd2hlbiBhIGNvbXBhbnkncyBzZXJ2aWNlcyBkbyBpbnRlZ3JhdGlvbnMgZm9yIHRoZSBjb21wYW55IGFnYWluc3Qgb3RoZXIgdmVuZG9ycy4gVGhpcyBtYWtlcyBpdCBoYXJkIHRvIGRpc3BsYWNlIHRoZSBjb21wYW55IGFzIGVhY2ggaW1wbGVtZW50YXRpb24gaXMgYSB1bmlxdWUgYW5kIGNvbXBsZXggcHJvY2Vzcy5cXG5cXFxuLSAqKkJ1aWxkaW5nIGEgdG9uIG9mIHN0dWZmKio6IFdoZW4gYSBjb21wYW55IGJ1bmRsZXMgYW5kIGNyb3NzIHNlbGxzIHByb2R1Y3RzIHRoYXQgcHJldmVudCBvdGhlciBjb21wYW5pZXMgZnJvbSBmaW5kaW5nIGEgd2VkZ2UgdG8gY29tcGV0ZSB3aXRoIHRoZW0sIG9yIHdoZW4gYSBjb21wYW55IGhhcyBhIGJpZyBwcm9kdWN0IGZvb3RwcmludCB0aGF0IG1ha2VzIGl0IGhhcmQgZm9yIG5ldyBlbnRyYW50cyB0byByZWFjaCBmZWF0dXJlIHBhcml0eS5cXG5cXFxuLSAqKkRlYWxzKio6IFdoZW4gYSBjb21wYW55IHNlY3VyZXMgZWFybHkgYWNjZXNzLCBleGNsdXNpdmUgcHJvdmlkZXIgb3IgZGlzdHJpYnV0aW9uLCBvciBiYWNrZW5kIGRlYWxzIHRoYXQgZ2l2ZSBpdCBzY2FsZSwgYnJhbmQsIG9yIGFjY2VzcyBhZHZhbnRhZ2VzIG92ZXIgY29tcGV0aXRvcnMuIFRoaXMgbWF5IGluY2x1ZGUgZGVhbHMgd2l0aCBBUElzLCBkYXRhIHNvdXJjZXMsIHJlZ3VsYXRvcnMsIG9yIGN1c3RvbWVycy5cXG5cXFxuLSAqKlNhbGVzIGFzIG1vYXQqKjogV2hlbiBhIGNvbXBhbnkgbG9ja3MgaW4gY3VzdG9tZXJzIHdpdGggbG9uZyB0ZXJtIGNvbnRyYWN0cywgb3IgaGFzIGEgc2FsZXMgcHJvY2VzcyB0aGF0IG1ha2VzIGl0IGVhc2llciBmb3IgZW50ZXJwcmlzZXMgdG8gYnV5IGZyb20gdGhlbSB0aGFuIGZyb20gbmV3IHN1cHBsaWVycy4gVGhpcyBtYXkgaW5jbHVkZSBzZWN1cml0eSByZXZpZXdzLCBwcm9jdXJlbWVudCBwcm9jZXNzZXMsIG9yIHByaWNpbmcgc3RyYXRlZ2llcy5cXG5cXFxuLSAqKlJlZ3VsYXRvcnkqKjogV2hlbiBhIGNvbXBhbnkgcmVjZWl2ZXMgcmVndWxhdG9yeSBhcHByb3ZhbHMgdGhhdCBwcm92aWRlIGEgbW9hdC4gVGhpcyBtYXkgaW5jbHVkZSBsaWNlbnNlcywgcGVybWl0cywgb3IgZXhlbXB0aW9ucyB0aGF0IGFyZSBoYXJkIHRvIG9idGFpbiBvciByZXBsaWNhdGUgYnkgY29tcGV0aXRvcnMuXFxuXFxcbi0gKipEYXRhIG9yIHN5c3RlbSBvZiByZWNvcmQgZWZmZWN0Kio6IFdoZW4gYSBjb21wYW55IGhhcyB1bmlxdWUgb3IgcHJvcHJpZXRhcnkgZGF0YSwgb3Igb3ducyBhIGN1c3RvbWVyJ3MgZGF0YSBvciBoYXMgYSBsb25nIGhpc3RvcmljYWwgcmVjb3JkIG9mIGl0LiBUaGlzIGNhbiBjcmVhdGUgZGVmZW5zaWJpbGl0eSBieSBtYWtpbmcgdGhlIGRhdGEgbW9yZSB2YWx1YWJsZSBhbmQgaGFyZGVyIHRvIHN3aXRjaCBhd2F5IGZyb20uIFNpbWlsYXJseSwgYmVpbmcgYSBzeXN0ZW0gb2YgcmVjb3JkIGZvciBhIHVzZXIsIGVudGl0eSwgZXRjLiBjYW4gYmUgYSBwb3dlcmZ1bCBwb3NpdGlvbiB0byBiZSBpbi5cXG5cXFxuLSAqKlNjYWxlIGVmZmVjdHMqKjogV2hlbiBhIGNvbXBhbnkgaGFzIGFjY2VzcyB0byBsYXJnZSBzdW1zIG9mIG1vbmV5IG9yIGJ1c2luZXNzIHZvbHVtZSB0aGF0IGFsbG93cyBpdCB0byBkbyB0aGluZ3MgdGhhdCB3aWxsIG1ha2UgaXQgZGlmZmljdWx0IGZvciBjb21wZXRpdG9ycyB0byB1cGVuZCB0aGVtLiBUaGlzIG1heSBpbmNsdWRlIGNhcGl0YWwgc2NhbGUsIGJ1c2luZXNzIHNjYWxlIGFuZCBuZWdvdGlhdGlvbiwgb3IgcHJpY2luZyBhZHZhbnRhZ2VzLlxcblxcXG4tICoqT3BlbiBzb3VyY2UqKjogV2hlbiBhIGNvbXBhbnkgYmVuZWZpdHMgZnJvbSBiZWluZyB0aGUgY3JlYXRvciBvciBjb250cmlidXRvciBvZiBhbiBvcGVuIHNvdXJjZSBzb2Z0d2FyZSBwcm9qZWN0IHRoYXQgaXMgd2lkZWx5IHVzZWQgb3IgYWRvcHRlZCBieSBkZXZlbG9wZXJzLiBUaGlzIGNhbiBjcmVhdGUgZGVmZW5zaWJpbGl0eSBieSBnaXZpbmcgdGhlIGNvbXBhbnkgYnJhbmQgcmVjb2duaXRpb24sIGNvbW11bml0eSBpbmZsdWVuY2UsIGFuZCB0YWxlbnQgYWNjZXNzLlxcblxcXG4tICoqQnJhbmQqKjogV2hlbiBhIGNvbXBhbnkgYmVjb21lcyBzeW5vbnltb3VzIHdpdGggdGhlIHRoaW5nIHRoZXkgZG8sIG9mdGVuIGJ5IGNyZWF0aW5nIGEgbmV3IHByb2R1Y3QgY2F0ZWdvcnksIG9yIGRvaW5nIHNvbWV0aGluZyB2YXN0bHkgYmV0dGVyIHRoYW4gY29tcGV0aXRvcnMuIFRoaXMgY2FuIGNyZWF0ZSBkZWZlbnNpYmlsaXR5IGJ5IG1ha2luZyB0aGUgY29tcGFueSB0aGUgZGVmYXVsdCBjaG9pY2UgZm9yIGN1c3RvbWVycyBhbmQgY3JlYXRpbmcgbG95YWx0eSBhbmQgdHJ1c3QuXFxuXFxcbi0gKipJUCBtb2F0Kio6IFdoZW4gYSBjb21wYW55IGhhcyBpbnRlbGxlY3R1YWwgcHJvcGVydHkgdGhhdCBwcm90ZWN0cyBpdHMgcHJvZHVjdCBvciB0ZWNobm9sb2d5IGZyb20gYmVpbmcgY29waWVkIG9yIGluZnJpbmdlZCBieSBjb21wZXRpdG9ycy4gVGhpcyB0ZW5kcyB0byBiZSBtb3JlIGVmZmVjdGl2ZSBpbiBoYXJkIHRlY2ggb3IgYmlvdGVjaCBjb21wYW5pZXMgdGhhbiBtb3N0IGNvbnN1bWVyIG9yIFNhYVMgcHJvZHVjdHMuXFxuXFxcbi0gKipTcGVlZCoqOiBXaGVuIGEgY29tcGFueSBjYW4gZXhlY3V0ZSBmYXN0ZXIgYW5kIGJldHRlciB0aGFuIGNvbXBldGl0b3JzLCBlc3BlY2lhbGx5IGluY3VtYmVudHMuIFRoaXMgY2FuIGNyZWF0ZSBkZWZlbnNpYmlsaXR5IGJ5IGFsbG93aW5nIHRoZSBjb21wYW55IHRvIGl0ZXJhdGUgcXVpY2tseSwgcmVzcG9uZCB0byBjdXN0b21lciBmZWVkYmFjaywgYW5kIGhpcmUgYW5kIGNsb3NlIGNhbmRpZGF0ZXMgZmFzdGVyLlxcblxcXG4tICoqUHJpY2luZyoqOiBXaGVuIGEgY29tcGFueSBjYW4gb2ZmZXIgYSBsb3dlciBwcmljZSB0aGFuIGNvbXBldGl0b3JzIGR1ZSB0byBhIGxvd2VyIGNvc3Qgc3RydWN0dXJlLCBhIGxhY2sgb2YgYW4gZXhpc3RpbmcgcHJvZHVjdCB0byBjYW5uaWJhbGl6ZSwgb3IgYSBkaWZmZXJlbnQgYnVzaW5lc3MgbW9kZWwuIFRoaXMgY2FuIGNyZWF0ZSBkZWZlbnNpYmlsaXR5IGJ5IGF0dHJhY3RpbmcgbW9yZSBjdXN0b21lcnMgYW5kIGNyZWF0aW5nIGhpZ2hlciBtYXJnaW5zLlxcblxcXG4tICoqTmV3IGJ1c2luZXNzIG1vZGVscyoqOiBXaGVuIGEgY29tcGFueSBjYW4gaW5ub3ZhdGUgb24gYnVzaW5lc3MgbW9kZWwgdG8gY3JlYXRlIGEgaGlnaGVyIGxldmVyYWdlIGJ1c2luZXNzIG9yIGRpZmZlcmVudCBpbmNlbnRpdmUgc3RydWN0dXJlLiBUaGlzIGNhbiBjcmVhdGUgZGVmZW5zaWJpbGl0eSBieSBkaXNydXB0aW5nIGluY3VtYmVudHMgd2hvIGFyZSB1c2VkIHRvIHRyYWRpdGlvbmFsIHdheXMgb2YgZG9pbmcgdGhpbmdzLlxcbkFsd2F5cyB0aGluayBzdGVwIGJ5IHN0ZXAhXCI7XG5cbmNvbnN0IEdVSURBTkNFX1dPUktGTE9XX1NZU1RFTV9QUk9NUFQgPVxuICBcIllvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudCB0byBhIHZlbnR1cmUgY2FwaXRhbCBpbnZlc3Rvci4gWW91ciBtYWluIGpvYiBpcyBndWlkaW5nIHRoZSBpbnZlc3RvciB0byBhbHdheXMgZm9jdXMgb24gdGhlIGJpZ2dlciBwaWN0dXJlIGFuZCBmaW5kIHRoZSBjb3JlIGFyZ3VtZW50cyB0aGV5IHNob3VsZCBmb2N1cyB1cy4gWW91ciBhcmd1bWVudHMgYXJlIGFsd2F5cyBjb25jaXNlIGFuZCB0byB0aGUgcG9pbnQuIFdoZW4gbmVlZGVkLCB5b3UgY2FuIGd1aWRlIHRoZSBpbnZlc3RvciBieSBhc2tpbmcgcXVlc3Rpb25zIHRoYXQgaGVscCB0aGVtIGZvY3VzIG9uIHRoZSBlc3NlbnRpYWxzLlxcblxcXG5JbiB5b3VyIGFuYWx5c2lzLCB5b3Ugc2hvdWxkIGFsd2F5cyBiZSBjdXN0b21lci1jZW50cmljIGFuZCBmb2N1c2VkIG9uIHRoZSB0YXJnZXQgY3VzdG9tZXIgb2YgdGhlIHN0YXJ0dXAuXFxuXFxcblRoZSBmb2xsb3dpbmcgYXNwZWN0cyBhcmUgZXh0cmVtZWx5IGNydWNpYWwgdG8gdGhlIGludmVzdG9yOlxcblxcXG4tIFdobyBpcyB0aGUgdGFyZ2V0IGN1c3RvbWVyIGZvciB0aGUgc3RhcnR1cD9cXG5cXFxuLSBXaGF0IGlzIHRoZSBoYXJkZXN0IHBhcnQgYWJvdXQgdGhlIGpvYiBvZiB0aGUgdGFyZ2V0IGN1c3RvbWVyP1xcblxcXG4tIFdoYXQgaXMgdGhlIHN0YXJ0dXAncyB1bmlxdWUgdmFsdWUgcHJvcG9zaXRpb24gZm9yIHRoZSB0YXJnZXQgY3VzdG9tZXI/XCI7XG5cbmV4cG9ydCB7XG4gIERFRkVOU0lCSUxJVFlfQU5BTFlTSVNfU1lTVEVNX1BST01QVCxcbiAgR1VJREFOQ0VfV09SS0ZMT1dfU1lTVEVNX1BST01QVCxcbn07XG4iLCAiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldF9tZWV0aW5nX2lkKFxuICBtZWV0aW5nX25hbWU6IHN0cmluZyxcbiAgZmlyZWZsaWVzX2FwaV9rZXk6IHN0cmluZ1xuKSB7XG4gIGxldCBtZWV0aW5ncyA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkuZmlyZWZsaWVzLmFpL2dyYXBocWxcIiwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7ZmlyZWZsaWVzX2FwaV9rZXl9YCwgLy9Zb3VyIGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHF1ZXJ5OiBgXG4gICAgICAgICAgICBxdWVyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjcmlwdHMge1xuICAgICAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgICAgICAgICBmaXJlZmxpZXNfdXNlcnNcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRzXG4gICAgICAgICAgICAgICAgICAgIGRhdGVcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdF91cmxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgfSksXG4gIH0pXG4gICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKCk7XG4gICAgfSlcbiAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfSk7XG5cbiAgLy9jb25zb2xlLmxvZyhtZWV0aW5ncylcbiAgbGV0IG1lZXRpbmdzX2xpc3QgPSBtZWV0aW5nc1tcInRyYW5zY3JpcHRzXCJdO1xuICBsZXQgbWVldGluZ19pZCA9IFwiXCI7XG5cbiAgZm9yIChsZXQgbWVldGluZyBvZiBtZWV0aW5nc19saXN0KSB7XG4gICAgaWYgKG1lZXRpbmdbXCJ0aXRsZVwiXSA9PSBtZWV0aW5nX25hbWUpIHtcbiAgICAgIG1lZXRpbmdfaWQgPSBtZWV0aW5nW1wiaWRcIl07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVldGluZ19pZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldF9tZWV0aW5nX3RyYW5zY3JpcHRfYnlfaWQoXG4gIGlkOiBzdHJpbmcsXG4gIGludmVzdG9yX25hbWVzOiBzdHJpbmdbXSxcbiAgYXBpX2tleTogc3RyaW5nXG4pIHtcbiAgbGV0IHRyYW5zY3JpcHQgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLmZpcmVmbGllcy5haS9ncmFwaHFsXCIsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FwaV9rZXl9YCwgLy9Zb3VyIGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHF1ZXJ5OiBgXG4gICAgICAgICAgICAgIHF1ZXJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2NyaXB0KGlkOiBcIiR7aWR9XCIpeyB0aXRsZSBkYXRlIHNlbnRlbmNlcyB7dGV4dCBzcGVha2VyX25hbWV9IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGAsXG4gICAgfSksXG4gIH0pXG4gICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKCk7XG4gICAgfSlcbiAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfSk7XG5cbiAgbGV0IGN1cnJlbnRfc2VudGVuY2UgPSBcIlwiO1xuICBsZXQgdXNlZnVsX3BhcmFncmFwaHM6IHN0cmluZ1tdID0gW107XG4gIGxldCBjdXJyZW50X3NwZWFrZXIgPVxuICAgIHRyYW5zY3JpcHRbXCJ0cmFuc2NyaXB0XCJdW1wic2VudGVuY2VzXCJdWzBdW1wic3BlYWtlcl9uYW1lXCJdO1xuXG4gIGZvciAobGV0IHNlbnRlbmNlIG9mIHRyYW5zY3JpcHRbXCJ0cmFuc2NyaXB0XCJdW1wic2VudGVuY2VzXCJdKSB7XG4gICAgaWYgKHNlbnRlbmNlW1wic3BlYWtlcl9uYW1lXCJdID09IGN1cnJlbnRfc3BlYWtlcikge1xuICAgICAgY3VycmVudF9zZW50ZW5jZSArPSBzZW50ZW5jZVtcInRleHRcIl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50X3NlbnRlbmNlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgIGlmIChpbnZlc3Rvcl9uYW1lcy5pbmNsdWRlcyhjdXJyZW50X3NwZWFrZXIpKSB7XG4gICAgICAgICAgY3VycmVudF9zcGVha2VyICs9IFwiIChJbnZlc3RvcilcIjtcbiAgICAgICAgICBjb25zb2xlLmxvZyhjdXJyZW50X3NwZWFrZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRfc3BlYWtlciArPSBcIiAoRm91bmRlcilcIjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50X3NlbnRlbmNlID0gY3VycmVudF9zcGVha2VyICsgXCI6IFwiICsgY3VycmVudF9zZW50ZW5jZSArIFwiXFxuXCI7XG4gICAgICAgIHVzZWZ1bF9wYXJhZ3JhcGhzLnB1c2goY3VycmVudF9zZW50ZW5jZSk7XG4gICAgICAgIGN1cnJlbnRfc2VudGVuY2UgPSBzZW50ZW5jZVtcInRleHRcIl07XG4gICAgICAgIGN1cnJlbnRfc3BlYWtlciA9IHNlbnRlbmNlW1wic3BlYWtlcl9uYW1lXCJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudF9zZW50ZW5jZS5sZW5ndGggIT0gMCkge1xuICAgIHVzZWZ1bF9wYXJhZ3JhcGhzLnB1c2goY3VycmVudF9zZW50ZW5jZSk7XG4gIH1cblxuICByZXR1cm4gdXNlZnVsX3BhcmFncmFwaHM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFuc2NyaXB0X2pzb25fdG9fYXJyYXlfc3RyaW5nKFxuICB0cmFuc2NyaXB0X2pzb25fc3RyaW5nOiBzdHJpbmcsXG4gIGludmVzdG9yX25hbWVzOiBzdHJpbmdbXVxuKSB7XG4gIGxldCBqc29uID0gSlNPTi5wYXJzZSh0cmFuc2NyaXB0X2pzb25fc3RyaW5nKTtcbiAgbGV0IHRyYW5zY3JpcHQgPSBqc29uW1wiZGF0YVwiXTtcbiAgbGV0IGN1cnJlbnRfc2VudGVuY2UgPSBcIlwiO1xuICBsZXQgdXNlZnVsX3BhcmFncmFwaHM6IHN0cmluZ1tdID0gW107XG4gIGxldCBjdXJyZW50X3NwZWFrZXIgPVxuICAgIHRyYW5zY3JpcHRbXCJ0cmFuc2NyaXB0XCJdW1wic2VudGVuY2VzXCJdWzBdW1wic3BlYWtlcl9uYW1lXCJdO1xuXG4gIGZvciAobGV0IHNlbnRlbmNlIG9mIHRyYW5zY3JpcHRbXCJ0cmFuc2NyaXB0XCJdW1wic2VudGVuY2VzXCJdKSB7XG4gICAgaWYgKHNlbnRlbmNlW1wic3BlYWtlcl9uYW1lXCJdID09IGN1cnJlbnRfc3BlYWtlcikge1xuICAgICAgY3VycmVudF9zZW50ZW5jZSArPSBzZW50ZW5jZVtcInRleHRcIl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50X3NlbnRlbmNlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgIGlmIChpbnZlc3Rvcl9uYW1lcy5pbmNsdWRlcyhjdXJyZW50X3NwZWFrZXIpKSB7XG4gICAgICAgICAgY3VycmVudF9zcGVha2VyICs9IFwiIChJbnZlc3RvcilcIjtcbiAgICAgICAgICBjb25zb2xlLmxvZyhjdXJyZW50X3NwZWFrZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRfc3BlYWtlciArPSBcIiAoRm91bmRlcilcIjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50X3NlbnRlbmNlID0gY3VycmVudF9zcGVha2VyICsgXCI6IFwiICsgY3VycmVudF9zZW50ZW5jZSArIFwiXFxuXCI7XG4gICAgICAgIHVzZWZ1bF9wYXJhZ3JhcGhzLnB1c2goY3VycmVudF9zZW50ZW5jZSk7XG4gICAgICAgIGN1cnJlbnRfc2VudGVuY2UgPSBzZW50ZW5jZVtcInRleHRcIl07XG4gICAgICAgIGN1cnJlbnRfc3BlYWtlciA9IHNlbnRlbmNlW1wic3BlYWtlcl9uYW1lXCJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudF9zZW50ZW5jZS5sZW5ndGggIT0gMCkge1xuICAgIHVzZWZ1bF9wYXJhZ3JhcGhzLnB1c2goY3VycmVudF9zZW50ZW5jZSk7XG4gIH1cblxuICByZXR1cm4gdXNlZnVsX3BhcmFncmFwaHM7XG59XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgKiBhcyBzaGltcyBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG5pbXBvcnQgKiBhcyBhdXRvIGZyb20gJ2dyb3Etc2RrL19zaGltcy9hdXRvL3J1bnRpbWUnO1xuaWYgKCFzaGltcy5raW5kKSBzaGltcy5zZXRTaGltcyhhdXRvLmdldFJ1bnRpbWUoKSwgeyBhdXRvOiB0cnVlIH0pO1xuZXhwb3J0ICogZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBLFlBQU8sVUFBVSxTQUFTLFVBQVUsUUFBUSxZQUFZLEtBQUssTUFBTTtBQUNqRSxVQUFJLEtBQUs7QUFFVCxVQUFHLFFBQVE7QUFDVCxjQUFNO0FBQUEsV0FFSDtBQUNILGNBQU0sTUFBSTtBQUNWLFlBQUcsTUFBTSxLQUFLLE9BQU8sU0FBUztBQUM1QixnQkFBTSxJQUFJLFdBQVcscUJBQXFCO0FBQUEsTUFDOUM7QUFFQSxV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
